from dataclasses import dataclass
from typing import Optional, Tuple, Callable
import sympy as syp
import numpy as np
from numpy.typing import NDArray

@dataclass
class TimeHorizon:
    """
    Time horizon T subset of R for non-autonomous systems.
    
    Factories:
    - Unbounded: T = R (default)
    - Closed Interval: T = [a, b]
    - Open Interval: T = (a, b) 
    
    Supports:
    - Predicate: T = {t : constraint(t) = True}
    
    Fields:
        symbolic_set (syp.Set | None): Optional SymPy set representation
        constraint (Callable[[float], bool] | None): Optional callable for fast membership testing
        
    - At least one of symbolic_set or constraint must be provided, or a ValueError will be raised upon construction.
    """
    symbolic_set: Optional[syp.Set] = None
    constraint: Optional[Callable[[float], bool]] = None
    
    
        ### --- Construction --- ###
        
        
    ## __init__ autogenerated by @dataclass decorator
    
    def __post_init__(
        self
    ):
        """
        Post-construction Validation:   
        
        Raises: 
            ValueError: If both symbolic_set and constraint are None
        """
        if self.symbolic_set is None and self.constraint is None:
            raise ValueError(
                "PhaseSpace requires at least one representation: "
                "symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided"
            )
        
        if self.constraint is None and self.symbolic_set is not None:
            # Compile constraint from symbolic set: yields slow containment checks
            ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs
            self.constraint = self._compile_constraint() 
            
            
            ### --- Public Methods --- ### 
            
    
    def contains_time(self, t: float) -> bool:
        """
        Check if t is in T.
        
        Args:
            t: Time point to test
            
        Returns:
            bool: True if t in T, False otherwise
        """
        return self.constraint(t)
        
    def contains_times(self, t: NDArray[np.float64]) -> bool:
        """
        Check if all times in t are in T.
        
        Args:
            t: Times to test
            
        Returns:
            bool: True if all times in t are in T, False otherwise
        """
        return np.all([self.contains_time(t) for t in t])
    
    
        ### --- Factory Methods --- ### 
    
    
    @classmethod
    def real_line(cls) -> 'TimeHorizon':
        """
        Factory: T = R (entire real line).
        
        This is the DEFAULT time horizon for non-autonomous systems.
        
        Returns:
            TimeHorizon representing R
        """
        return cls(symbolic_set=syp.Reals, constraint=lambda t: True)
    
    @classmethod
    def closed_interval(cls, t_min: float, t_max: float) -> 'TimeHorizon':
        """
        Factory: T = [t_min, t_max] (bounded interval).
        
        Args:
            t_min: Lower bound
            t_max: Upper bound
            
        Returns:
            TimeHorizon with interval constraints
            
        Raises:
            ValueError: If t_min >= t_max
        """
        if t_min >= t_max:
            raise ValueError(f"Interval time horizon must have t_min < t_max, got ({t_min}, {t_max})")
        return cls(symbolic_set=syp.Interval(t_min, t_max), constraint=lambda t: t_min <= t <= t_max)
    
    @classmethod
    def open_interval(cls, t_min: float, t_max: float) -> 'TimeHorizon':
        """
        Factory: T = (t_min, t_max) (open interval).
        
        Args:
            t_min: Lower bound
            t_max: Upper bound
        """
        if t_min >= t_max:
            raise ValueError(f"Interval time horizon must have t_min < t_max, got ({t_min}, {t_max})")
        return cls(symbolic_set=syp.Interval(t_min, t_max, True, True), constraint=lambda t: t_min < t < t_max)
    
    
        ### --- Properties --- ### 
        
        
    @property
    def length(self) -> float:
        """
        CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS
        
        Returns:
            float: Volume of T
        """
        raise NotImplementedError("Length is not implemented for TimeHorizon")
    
    
        ### --- Dunder Methods --- ### 
        
        
    def __str__(self) -> str: 
        if self.symbolic_set is not None:
            return str(self.symbolic_set)
        else: 
            return f"TimeHorizon(constraint={self.constraint.__name__}): No symbolic representation"
    
    
    def __repr__(self) -> str: 
        return (
            f"TimeHorizon("
                f"symbolic_set={str(self.symbolic_set) if self.symbolic_set is not None else 'None'}, "
                f"constraint={self.constraint.__name__ if self.constraint is not None else 'None'})"
        )
    
    
    def __eq__(self, other: 'TimeHorizon') -> bool:
        if not isinstance(other, TimeHorizon):
            return NotImplemented  # type: ignore[return-value]
        # Equality iff mutual subset
        left = self._subseteq(other)
        if left is False:
            return False
        right = other._subseteq(self)
        return bool(left and right)
    
    
    def __ne__(self, other: 'TimeHorizon') -> bool:
        eq = self.__eq__(other)
        if eq is NotImplemented:  # type: ignore[comparison-overlap]
            return NotImplemented  # type: ignore[return-value]
        return not eq
    
    
    def __lt__(self, other: 'TimeHorizon') -> bool:
        if not isinstance(other, TimeHorizon):
            return NotImplemented  # type: ignore[return-value]
        le = self._subseteq(other)
        if le is False:
            return False
        return not self.__eq__(other)
    
    
    def __le__(self, other: 'TimeHorizon') -> bool:
        if not isinstance(other, TimeHorizon):
            return NotImplemented  # type: ignore[return-value]
        return self._subseteq(other)
    
    
    def __gt__(self, other: 'TimeHorizon') -> bool:
        if not isinstance(other, TimeHorizon):
            return NotImplemented  # type: ignore[return-value]
        ge = other._subseteq(self)
        if ge is False:
            return False
        return not self.__eq__(other)
    
    
    def __ge__(self, other: 'TimeHorizon') -> bool:
        if not isinstance(other, TimeHorizon):
            return NotImplemented  # type: ignore[return-value]
        return other._subseteq(self)  
    
    
        ### --- Private Methods --- ### 
        
    def _compile_constraint(self) -> Callable[[NDArray[np.float64]], bool]:
        """
        Compile symbolic set to callable for fast numerical membership testing.
        
        Only called when symbolic_set is provided but constraint is not.
        
        Strategy:
        - For R (unbounded): return lambda x: True (no constraint)
        - For Intervals: extract bounds, compile to numpy checks
        - For general sets: use sympy's contains (slow, but general)
        
        Raises:
            AssertionError: If symbolic_set is None (should never happen)
        """
        assert self.symbolic_set is not None, "Cannot compile constraint without symbolic_set"
        
        # Special case: R 
        if self.symbolic_set == syp.Reals:
            return lambda x: True
        
        # Special case: Interval
            ## NOTE: Open/Closed logic not yet implemented. Consumers should be using the factories, 
            ## this is just an emergency fallback.
        if isinstance(self.symbolic_set, syp.Interval):
            a = float(self.symbolic_set.start) if self.symbolic_set.start.is_finite else -np.inf
            b = float(self.symbolic_set.end) if self.symbolic_set.end.is_finite else np.inf
            return lambda t: a <= t <= b
        
        # General case: use sympy (slow, potentially problematic)
        def symbolic_constraint(t: float) -> bool:
            try:
                elem = syp.Float(t)
                contains_expr = self.symbolic_set.contains(elem)
                # SymPy returns a Boolean or a symbolic expression; coerce if possible
                return bool(contains_expr)
            except Exception:
                return False
        
        return symbolic_constraint