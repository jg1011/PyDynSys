
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://jg1011.github.io/PyDynSys/api/core/euclidean/trajectory/">
      
      
        <link rel="prev" href="../trajectory_segment/">
      
      
        <link rel="next" href="../../../vis/">
      
      
      <link rel="icon" href="../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>Trajectory - PyDynSys</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.84d31ad4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#trajectory" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="PyDynSys" class="md-header__button md-logo" aria-label="PyDynSys" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            PyDynSys
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Trajectory
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/jg1011/PyDynSys" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../getting_started/installation/" class="md-tabs__link">
          
  
  
  Getting Started

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../" class="md-tabs__link">
          
  
  
  API Reference

        </a>
      </li>
    
  

    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../examples/phase_spaces_and_time_horizons/" class="md-tabs__link">
          
  
  
  Examples

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="PyDynSys" class="md-nav__button md-logo" aria-label="PyDynSys" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    PyDynSys
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jg1011/PyDynSys" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Getting Started
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Getting Started
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../getting_started/installation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" checked>
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Core
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            Core
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_2" checked>
        
          
          <label class="md-nav__link" for="__nav_3_1_2" id="__nav_3_1_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Euclidean
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_1_2">
            <span class="md-nav__icon md-icon"></span>
            Euclidean
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../phase_space/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PhaseSpace
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../time_horizon/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    TimeHorizon
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../trajectory_segment/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    TrajectorySegment
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Trajectory
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Trajectory
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#full-docs" class="md-nav__link">
    <span class="md-ellipsis">
      Full Docs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory" class="md-nav__link">
    <span class="md-ellipsis">
      Trajectory
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Trajectory">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.message" class="md-nav__link">
    <span class="md-ellipsis">
      message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.success" class="md-nav__link">
    <span class="md-ellipsis">
      success
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.t" class="md-nav__link">
    <span class="md-ellipsis">
      t
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.y" class="md-nav__link">
    <span class="md-ellipsis">
      y
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.from_segments" class="md-nav__link">
    <span class="md-ellipsis">
      from_segments
    </span>
  </a>
  
    <nav class="md-nav" aria-label="from_segments">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.from_segments--merge-algorithm-iterative-fixed-point-approach" class="md-nav__link">
    <span class="md-ellipsis">
      MERGE ALGORITHM: Iterative Fixed-Point Approach
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.in_domain" class="md-nav__link">
    <span class="md-ellipsis">
      in_domain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.interpolate" class="md-nav__link">
    <span class="md-ellipsis">
      interpolate
    </span>
  </a>
  
    <nav class="md-nav" aria-label="interpolate">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.interpolate--key-feature-unified-interface-across-composite-trajectories" class="md-nav__link">
    <span class="md-ellipsis">
      KEY FEATURE: Unified interface across composite trajectories
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.merge" class="md-nav__link">
    <span class="md-ellipsis">
      merge
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Vis
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            Vis
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../vis/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2_2" id="__nav_3_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Euclidean
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2_2">
            <span class="md-nav__icon md-icon"></span>
            Euclidean
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../vis/euclidean/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../vis/euclidean/phase_space/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PhaseSpace
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../examples/phase_spaces_and_time_horizons/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Using Custom Phase Spaces and Time Horizons
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#full-docs" class="md-nav__link">
    <span class="md-ellipsis">
      Full Docs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory" class="md-nav__link">
    <span class="md-ellipsis">
      Trajectory
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Trajectory">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.message" class="md-nav__link">
    <span class="md-ellipsis">
      message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.success" class="md-nav__link">
    <span class="md-ellipsis">
      success
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.t" class="md-nav__link">
    <span class="md-ellipsis">
      t
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.y" class="md-nav__link">
    <span class="md-ellipsis">
      y
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.from_segments" class="md-nav__link">
    <span class="md-ellipsis">
      from_segments
    </span>
  </a>
  
    <nav class="md-nav" aria-label="from_segments">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.from_segments--merge-algorithm-iterative-fixed-point-approach" class="md-nav__link">
    <span class="md-ellipsis">
      MERGE ALGORITHM: Iterative Fixed-Point Approach
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.in_domain" class="md-nav__link">
    <span class="md-ellipsis">
      in_domain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.interpolate" class="md-nav__link">
    <span class="md-ellipsis">
      interpolate
    </span>
  </a>
  
    <nav class="md-nav" aria-label="interpolate">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.interpolate--key-feature-unified-interface-across-composite-trajectories" class="md-nav__link">
    <span class="md-ellipsis">
      KEY FEATURE: Unified interface across composite trajectories
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#PyDynSys.core.euclidean.trajectory.Trajectory.merge" class="md-nav__link">
    <span class="md-ellipsis">
      merge
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="trajectory">Trajectory</h1>
<h2 id="full-docs">Full Docs</h2>


<div class="doc doc-object doc-class">



<h2 id="PyDynSys.core.euclidean.trajectory.Trajectory" class="doc doc-heading">
            <code>PyDynSys.core.euclidean.trajectory.Trajectory</code>


</h2>


    <div class="doc doc-contents first">


        <p>Represents a numerically computed trajectory on a subset of the real line ‚Ñù.</p>
<p>A trajectory is a composition of one or more segments with disjoint domains,
providing seamless access to the complete solution across potentially
non-contiguous time intervals.</p>
<p>Key invariant: All segment domains are disjoint (validated in from_segments).</p>


<details class="fields" open>
  <summary>Fields</summary>
  <p>segments (List[EuclideanTrajectorySegment]): Trajectory segments in ascending domain order
domains (List[Tuple[float, float]]): Domain intervals [t_i, t_{i+1}] in ascending order
meta (Dict[str, Any]): Aggregate metadata from all segments</p>
</details>

<details class="properties" open>
  <summary>Properties</summary>
  <p>t: Concatenated evaluation times from all segments
y: Concatenated states from all segments</p>
</details>

<details class="usage" open>
  <summary>Usage</summary>
  <p>Created via from_segments() factory. Primary user-facing class returned by
system.trajectory() method. Provides seamless interpolation across segments.</p>
</details>

<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>sys = AutonomousDS(...)
traj = sys.trajectory(x0, t_span=(0, 10), t_eval=np.linspace(0, 10, 100))
x_at_5 = traj.interpolate(5.0)</p>
</blockquote>
</blockquote>
</blockquote>
</details>







              <details class="quote">
                <summary>Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Trajectory</span><span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a numerically computed trajectory on a subset of the real line ‚Ñù.</span>

<span class="sd">    A trajectory is a composition of one or more segments with disjoint domains,</span>
<span class="sd">    providing seamless access to the complete solution across potentially</span>
<span class="sd">    non-contiguous time intervals.</span>

<span class="sd">    Key invariant: All segment domains are disjoint (validated in from_segments).</span>

<span class="sd">    Fields: </span>
<span class="sd">        segments (List[EuclideanTrajectorySegment]): Trajectory segments in ascending domain order</span>
<span class="sd">        domains (List[Tuple[float, float]]): Domain intervals [t_i, t_{i+1}] in ascending order</span>
<span class="sd">        meta (Dict[str, Any]): Aggregate metadata from all segments</span>

<span class="sd">    Properties:</span>
<span class="sd">        t: Concatenated evaluation times from all segments</span>
<span class="sd">        y: Concatenated states from all segments</span>

<span class="sd">    Usage:</span>
<span class="sd">        Created via from_segments() factory. Primary user-facing class returned by</span>
<span class="sd">        system.trajectory() method. Provides seamless interpolation across segments.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; sys = AutonomousDS(...)</span>
<span class="sd">        &gt;&gt;&gt; traj = sys.trajectory(x0, t_span=(0, 10), t_eval=np.linspace(0, 10, 100))</span>
<span class="sd">        &gt;&gt;&gt; x_at_5 = traj.interpolate(5.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1">### --- Factory Methods --- ###</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_segments</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">segments</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TrajectorySegment</span><span class="p">],</span>
        <span class="n">merge_policy</span><span class="p">:</span> <span class="n">TrajectorySegmentMergePolicy</span> <span class="o">=</span> <span class="s1">&#39;average&#39;</span>  <span class="c1"># Default: average overlapping values</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory: Create trajectory from list of segments, merging overlaps if needed.</span>

<span class="sd">        MERGE ALGORITHM: Iterative Fixed-Point Approach</span>
<span class="sd">        ------------------------------------------------</span>
<span class="sd">        This method implements an iterative fixed-point algorithm to merge overlapping</span>
<span class="sd">        segments until all domains are disjoint (class invariant).</span>

<span class="sd">        Problem: Cascading overlaps require multiple merge passes.</span>
<span class="sd">        Example: Segments [[0,1], [0.5,2], [1,3]] have:</span>
<span class="sd">          - Pass 1: Merge [0,1] + [0.5,2] ‚Üí [0,2]</span>
<span class="sd">          - Pass 2: Merge [0,2] + [1,3] ‚Üí [0,3]</span>

<span class="sd">        Algorithm:</span>
<span class="sd">          1. Sort segments by domain start time (ensures left-to-right processing)</span>
<span class="sd">          2. Fixed-point iteration:</span>
<span class="sd">             a. Scan through current segment list left-to-right</span>
<span class="sd">             b. For each consecutive pair, detect overlap</span>
<span class="sd">             c. If overlap exists, merge the pair and add to result</span>
<span class="sd">             d. If no overlap, add current segment to result</span>
<span class="sd">             e. If any merges occurred, repeat from step 2a</span>
<span class="sd">             f. If no merges occurred, fixed point reached ‚Üí done</span>

<span class="sd">        Invariant: At each iteration, segments in the working list are sorted by start time.</span>
<span class="sd">        This ensures that after merging two consecutive segments, the merged segment</span>
<span class="sd">        cannot overlap with any previously processed segments (they all ended before</span>
<span class="sd">        the current segment started, by the inductive property of sorted order).</span>

<span class="sd">        Termination: Guaranteed because:</span>
<span class="sd">          - Each merge reduces the number of segments by 1</span>
<span class="sd">          - Minimum segments = 1 (fully merged trajectory)</span>
<span class="sd">          - Maximum iterations = n-1 (worst case: chain of n segments)</span>

<span class="sd">        Args:</span>
<span class="sd">            segments (List[EuclideanTrajectorySegment]): Segments to compose</span>
<span class="sd">            merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps</span>
<span class="sd">                - &#39;average&#39; (DEFAULT): Average y values in overlap region</span>
<span class="sd">                - &#39;left&#39;: Use left segment in overlap</span>
<span class="sd">                - &#39;right&#39;: Use right segment in overlap</span>
<span class="sd">                - &#39;stitch&#39;: Left interpolant until midpoint, then right</span>

<span class="sd">        Returns:</span>
<span class="sd">            EuclideanTrajectory: Composite trajectory with disjoint segment domains</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If final domains are not disjoint (merging failed)</span>
<span class="sd">            RuntimeError: If merge algorithm fails to converge (indicates bug)</span>
<span class="sd">            NotImplementedError: If merge_policy is not &#39;average&#39; (others not yet implemented)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; seg1 = TrajectorySegment.from_scipy_solution(sol1, &#39;RK45&#39;)</span>
<span class="sd">            &gt;&gt;&gt; seg2 = TrajectorySegment.from_scipy_solution(sol2, &#39;RK45&#39;)</span>
<span class="sd">            &gt;&gt;&gt; traj = Trajectory.from_segments([seg1, seg2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">segments</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot create trajectory from empty segment list&quot;</span><span class="p">)</span>

        <span class="c1"># Sort segments by domain start time (critical for correct merge order)</span>
        <span class="n">working_segments</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">seg</span><span class="p">:</span> <span class="n">seg</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


        <span class="c1"># ITERATIVE FIXED-POINT MERGE ALGORITHM #</span>
        <span class="c1">## o(num_segments^2) worst case complexity</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>  <span class="c1"># Safety limit (should never be reached)</span>
        <span class="k">while</span> <span class="n">changed</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">max_iterations</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">merged_segments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># pass through working segments, merging consecutive overlaps</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">working_segments</span><span class="p">):</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">working_segments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">working_segments</span><span class="p">):</span>
                    <span class="n">next_seg</span> <span class="o">=</span> <span class="n">working_segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">overlap</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_detect_overlap</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Overlapping segments detected - merge them</span>
                        <span class="k">if</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
                            <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_average</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                            <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                        <span class="k">elif</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                            <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_left</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                            <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                        <span class="k">elif</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                            <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_right</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                            <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                        <span class="k">elif</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;stitch&#39;</span><span class="p">:</span>
                            <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_stitch</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                            <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown merge policy: </span><span class="si">{</span><span class="n">merge_policy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Disjoint segments - keep current and move forward</span>
                        <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Last segment - no next segment to check for overlap</span>
                    <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Update working list for next iteration (if needed)</span>
            <span class="n">working_segments</span> <span class="o">=</span> <span class="n">merged_segments</span>
            <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;=</span> <span class="n">max_iterations</span><span class="p">:</span>
            <span class="c1"># This should never happen in practice, but safety check</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Merge algorithm failed to converge after </span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2"> iterations. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;This indicates a bug in the merge logic.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Final merged segments (guaranteed disjoint by fixed-point property)</span>
        <span class="n">merged_segments</span> <span class="o">=</span> <span class="n">working_segments</span>

        <span class="c1"># Create trajectory instance</span>
        <span class="n">trajectory</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">trajectory</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="n">merged_segments</span>
        <span class="n">trajectory</span><span class="o">.</span><span class="n">domains</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">domain</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">]</span>

        <span class="c1"># Aggregate metadata</span>
        <span class="n">trajectory</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;all_successful&#39;</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">),</span>
            <span class="s1">&#39;messages&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">],</span>
            <span class="s1">&#39;methods&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">method</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">],</span>
        <span class="p">}</span>


        <span class="n">trajectory</span><span class="o">.</span><span class="n">_validate_disjoint_domains</span><span class="p">()</span> <span class="c1"># Validate disjoint domains (class invariant)</span>
        <span class="k">return</span> <span class="n">trajectory</span>


        <span class="c1">### --- Public Methods --- ###</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">,</span>
        <span class="n">merge_policy</span><span class="p">:</span> <span class="n">TrajectorySegmentMergePolicy</span> <span class="o">=</span> <span class="s1">&#39;average&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join this trajectory with another trajectory.</span>

<span class="sd">        Combines segments from both trajectories and merges any overlaps using</span>
<span class="sd">        the specified merge policy. Uses the same iterative fixed-point merge</span>
<span class="sd">        algorithm as from_segments() to handle cascading overlaps.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Trajectory): The other trajectory to join with self</span>
<span class="sd">            merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps</span>
<span class="sd">                - &#39;average&#39; (DEFAULT): Average y values in overlap region</span>
<span class="sd">                - &#39;left&#39;: Use left segment in overlap</span>
<span class="sd">                - &#39;right&#39;: Use right segment in overlap</span>
<span class="sd">                - &#39;stitch&#39;: Left interpolant until midpoint, then right</span>

<span class="sd">        Returns:</span>
<span class="sd">            Trajectory: New trajectory containing all segments from both trajectories,</span>
<span class="sd">                with overlaps merged according to merge_policy</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If final domains are not disjoint (merging failed)</span>
<span class="sd">            RuntimeError: If merge algorithm fails to converge (indicates bug)</span>
<span class="sd">            NotImplementedError: If merge_policy is not &#39;average&#39; (others not yet implemented)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; traj1 = sys1.trajectory(x0, t_span=(0, 5))</span>
<span class="sd">            &gt;&gt;&gt; traj2 = sys2.trajectory(x1, t_span=(3, 10))</span>
<span class="sd">            &gt;&gt;&gt; combined = traj1.join(traj2)  # Merges overlap in [3, 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Combine segments from both trajectories</span>
        <span class="n">combined_segments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

        <span class="c1"># Use from_segments factory to merge overlaps and create new trajectory</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">from_segments</span><span class="p">(</span><span class="n">combined_segments</span><span class="p">,</span> <span class="n">merge_policy</span><span class="o">=</span><span class="n">merge_policy</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">in_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if time t is within trajectory domain (any segment).</span>

<span class="sd">        Args:</span>
<span class="sd">            t (float): Time point to check</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if t is in any segment&#39;s domain, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">in_domain</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seamlessly interpolate trajectory at time t.</span>

<span class="sd">        KEY FEATURE: Unified interface across composite trajectories</span>
<span class="sd">        ------------------------------------------------------------</span>
<span class="sd">        This method provides seamless interpolation even when the trajectory is</span>
<span class="sd">        composed of multiple disjoint segments. The user doesn&#39;t need to know</span>
<span class="sd">        which segment contains t - we handle the dispatch automatically.</span>

<span class="sd">        Example use case:</span>
<span class="sd">          Bidirectional trajectory with domains [(-5, 0], [0, 5]]:</span>
<span class="sd">            traj.interpolate(-3.0) ‚Üí dispatches to backward segment</span>
<span class="sd">            traj.interpolate(0.0)  ‚Üí dispatches to forward segment (both have it, we pick first)</span>
<span class="sd">            traj.interpolate(3.0)  ‚Üí dispatches to forward segment</span>
<span class="sd">            traj.interpolate(10.0) ‚Üí raises ValueError (not in any domain)</span>

<span class="sd">        Implementation: O(n) linear search through segments (optimize with binary search later)</span>

<span class="sd">        Automatically finds the segment containing t and delegates to that segment&#39;s</span>
<span class="sd">        interpolant. Provides unified interface across potentially disjoint domains.</span>

<span class="sd">        Args:</span>
<span class="sd">            t (float): Time point for evaluation</span>

<span class="sd">        Returns:</span>
<span class="sd">            NDArray[np.float64]: State vector x(t) at time t</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If t not in any segment domain</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; traj = sys.trajectory(...)  # May have multiple segments</span>
<span class="sd">            &gt;&gt;&gt; x_5 = traj.interpolate(5.0)  # Seamlessly finds right segment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_segment_containing</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">segment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Time t=</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> not in any segment domain. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available domains: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># This may further raise ValueError if segment has no interpolant (dense_output=False)</span>
        <span class="k">return</span> <span class="n">segment</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>


        <span class="c1">### -- Properties --- ###</span>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenated evaluation times from all segments.</span>

<span class="sd">        Note: May contain duplicate values at segment boundaries (tangent domains).</span>

<span class="sd">        Returns:</span>
<span class="sd">            NDArray[np.float64]: All evaluation times, shape (total_points,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">seg</span><span class="o">.</span><span class="n">t</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenated states from all segments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            NDArray[np.float64]: All states, shape (n_dim, total_points)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">seg</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">success</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether all segment integrations succeeded.</span>

<span class="sd">        Convenience property for backwards compatibility with SciPyIvpSolution.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if all segments successful, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;all_successful&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">message</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregated messages from all segments.</span>

<span class="sd">        Convenience property for backwards compatibility with SciPyIvpSolution.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Combined message from all segments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;messages&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">messages</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;No messages&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">messages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">messages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">messages</span><span class="p">)</span>


        <span class="c1">### --- Dunder Methods --- ### </span>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Trajectory(domains=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Trajectory(domains=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TrajectorySegment</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">TrajectorySegment</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>  
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>      

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>


        <span class="c1">### --- Private Methods --- ###</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_detect_overlap</span><span class="p">(</span>
        <span class="n">seg1</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span>
        <span class="n">seg2</span><span class="p">:</span> <span class="n">TrajectorySegment</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect if two segments have overlapping domains.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg1, seg2: Segments to check (assumed seg1.domain[0] &lt;= seg2.domain[0])</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[float, float]: Overlap interval [a, b] if overlap exists, else None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># seg1 ends before seg2 starts ‚Üí disjoint</span>
        <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Overlapping: intersection is [max(starts), min(ends)]</span>
        <span class="n">overlap_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg2</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">overlap_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg2</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">overlap_start</span><span class="p">,</span> <span class="n">overlap_end</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_merged_interpolant</span><span class="p">(</span>
        <span class="n">seg1</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span>
        <span class="n">seg2</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">merged_domain</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create piecewise interpolant for merged segment.</span>

<span class="sd">        PIECEWISE DEFINITION:</span>
<span class="sd">        ---------------------</span>
<span class="sd">        For merged segment with overlap [overlap_start, overlap_end]:</span>

<span class="sd">        1. Pre-overlap region [seg1.domain[0], overlap_start):</span>
<span class="sd">           c(t) = seg1.interpolant(t)</span>

<span class="sd">        2. Overlap region [overlap_start, overlap_end]:</span>
<span class="sd">           c(t) = (seg1.interpolant(t) + seg2.interpolant(t)) / 2</span>

<span class="sd">        3. Post-overlap region (overlap_end, seg2.domain[1]]:</span>
<span class="sd">           c(t) = seg2.interpolant(t)</span>

<span class="sd">        This matches the discrete averaging policy: where both segments provide</span>
<span class="sd">        values, we average them; elsewhere, we use the single available value.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg1, seg2: Overlapping segments (seg1.domain[0] &lt;= seg2.domain[0] assumed)</span>
<span class="sd">            overlap: Overlap interval [overlap_start, overlap_end]</span>
<span class="sd">            merged_domain: Final domain [t_min, t_max] of merged segment</span>

<span class="sd">        Returns:</span>
<span class="sd">            Callable interpolant function, or None if either segment lacks interpolant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlap_start</span><span class="p">,</span> <span class="n">overlap_end</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="n">seg1_start</span><span class="p">,</span> <span class="n">seg1_end</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">seg2_start</span><span class="p">,</span> <span class="n">seg2_end</span> <span class="o">=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">merged_start</span><span class="p">,</span> <span class="n">merged_end</span> <span class="o">=</span> <span class="n">merged_domain</span>

        <span class="c1"># If either segment lacks interpolant, cannot create merged interpolant</span>
        <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">interpolant</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">seg2</span><span class="o">.</span><span class="n">interpolant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">merged_interpolant</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Piecewise merged interpolant evaluating at time t.</span>

<span class="sd">            Handles shape normalization for scipy interpolants which may return</span>
<span class="sd">            shape (n_dim,) or (n_dim, 1).</span>
<span class="sd">            &quot;&quot;&quot;</span>         
            <span class="c1"># Helper to normalize scipy interpolant output shape</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">normalize_result</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Normalize scipy interpolant output to shape (n_dim,).&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="c1"># Region 1: Pre-overlap (only seg1)</span>
            <span class="k">if</span> <span class="n">seg1_start</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">overlap_start</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">interpolant</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">normalize_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

            <span class="c1"># Region 2: Overlap (average both segments)</span>
            <span class="k">elif</span> <span class="n">overlap_start</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">overlap_end</span><span class="p">:</span>
                <span class="n">result1</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">interpolant</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">result2</span> <span class="o">=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">interpolant</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="c1"># Normalize shapes, then average</span>
                <span class="n">result1</span> <span class="o">=</span> <span class="n">normalize_result</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span>
                <span class="n">result2</span> <span class="o">=</span> <span class="n">normalize_result</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">result1</span> <span class="o">+</span> <span class="n">result2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="c1"># Region 3: Post-overlap (only seg2)</span>
            <span class="k">elif</span> <span class="n">overlap_end</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">seg2_end</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">interpolant</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">normalize_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_interpolant</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_segments_average</span><span class="p">(</span>
        <span class="n">seg1</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span>
        <span class="n">seg2</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajectorySegment</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two overlapping segments by averaging y values in overlap region.</span>

<span class="sd">        MATHEMATICAL CONTEXT:</span>
<span class="sd">        --------------------</span>
<span class="sd">        When we have two numerical approximations of the same trajectory x(t) over</span>
<span class="sd">        overlapping time intervals, we need to reconcile the competing values.</span>

<span class="sd">        Example scenario:</span>
<span class="sd">          Segment 1: [0, 1.5] computed with RK45, gives x(1.0) ‚âà 0.5403</span>
<span class="sd">          Segment 2: [0.5, 2] computed with DOP853, gives x(1.0) ‚âà 0.5404</span>

<span class="sd">        In overlap [0.5, 1.5], both segments provide approximations. The &#39;average&#39;</span>
<span class="sd">        policy takes the midpoint: x_merged(1.0) = (0.5403 + 0.5404)/2 = 0.54035</span>

<span class="sd">        This is optimal when both segments have similar accuracy/trust levels.</span>

<span class="sd">        Strategy:</span>
<span class="sd">        1. Identify evaluation points in each region (pre-overlap, overlap, post-overlap)</span>
<span class="sd">        2. In overlap: average y values at shared t points (within tolerance 1e-9)</span>
<span class="sd">        3. Concatenate regions to form merged segment</span>
<span class="sd">        4. Interpolant: Create piecewise interpolant matching the averaging policy</span>

<span class="sd">        Args:</span>
<span class="sd">            seg1, seg2: Overlapping segments (seg1.domain[0] &lt;= seg2.domain[0] assumed)</span>
<span class="sd">            overlap: Overlap interval [a, b] where both segments are defined</span>

<span class="sd">        Returns:</span>
<span class="sd">            TrajectorySegment: Merged segment spanning union of domains</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlap_start</span><span class="p">,</span> <span class="n">overlap_end</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="c1"># Two points at t1 and t2 are considered &quot;same&quot; if |t1 - t2| &lt; 1e-4</span>

        <span class="c1"># Split both segments into three regions:</span>
        <span class="c1">#   1. Pre-overlap (only in seg1)</span>
        <span class="c1">#   2. Overlap (in both segments)</span>
        <span class="c1">#   3. Post-overlap (only in seg2)</span>
        <span class="n">t1_before</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">seg1</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">overlap_start</span><span class="p">]</span>
        <span class="n">y1_before</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="n">seg1</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">overlap_start</span><span class="p">]</span>
        <span class="n">t1_overlap</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">t</span><span class="p">[(</span><span class="n">seg1</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">overlap_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">overlap_end</span><span class="p">)]</span>
        <span class="n">y1_overlap</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">overlap_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">overlap_end</span><span class="p">)]</span>
        <span class="n">t2_overlap</span> <span class="o">=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">t</span><span class="p">[(</span><span class="n">seg2</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">overlap_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">overlap_end</span><span class="p">)]</span>
        <span class="n">y2_overlap</span> <span class="o">=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">overlap_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">overlap_end</span><span class="p">)]</span>
        <span class="n">t2_after</span> <span class="o">=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">seg2</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">overlap_end</span><span class="p">]</span>
        <span class="n">y2_after</span> <span class="o">=</span> <span class="n">seg2</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="n">seg2</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">overlap_end</span><span class="p">]</span>


        <span class="c1"># Merge overlap region by averaging at shared t points</span>
        <span class="c1">## Strategy: Take union of all t values, average where both exist</span>
        <span class="n">t_overlap_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">t1_overlap</span><span class="p">,</span> <span class="n">t2_overlap</span><span class="p">]))</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="n">seg1</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Phase space dimension</span>
        <span class="n">y_overlap_merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_overlap_all</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t_overlap_all</span><span class="p">):</span>
            <span class="c1"># Check if this time point exists in each segment (within tolerance)</span>
            <span class="n">in_seg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t1_overlap</span> <span class="o">-</span> <span class="n">t_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">in_seg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t2_overlap</span> <span class="o">-</span> <span class="n">t_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">in_seg1</span> <span class="ow">and</span> <span class="n">in_seg2</span><span class="p">:</span>
                <span class="c1"># CASE 1: Shared point (exists in both segments)</span>
                <span class="n">idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t1_overlap</span> <span class="o">-</span> <span class="n">t_val</span><span class="p">))</span>  <span class="c1"># Find closest point in seg1</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t2_overlap</span> <span class="o">-</span> <span class="n">t_val</span><span class="p">))</span>  <span class="c1"># Find closest point in seg2</span>
                <span class="n">y_overlap_merged</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1_overlap</span><span class="p">[:,</span> <span class="n">idx1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y2_overlap</span><span class="p">[:,</span> <span class="n">idx2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">elif</span> <span class="n">in_seg1</span><span class="p">:</span>
                <span class="c1"># CASE 2: Only in seg1 (seg2 didn&#39;t evaluate here)</span>
                <span class="n">idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t1_overlap</span> <span class="o">-</span> <span class="n">t_val</span><span class="p">))</span>
                <span class="n">y_overlap_merged</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1_overlap</span><span class="p">[:,</span> <span class="n">idx1</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># CASE 3: Only in seg2 (seg1 didn&#39;t evaluate here)</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t2_overlap</span> <span class="o">-</span> <span class="n">t_val</span><span class="p">))</span>
                <span class="n">y_overlap_merged</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y2_overlap</span><span class="p">[:,</span> <span class="n">idx2</span><span class="p">]</span>

        <span class="c1"># Concatenate all three regions to form the complete merged segment</span>
        <span class="c1"># Order: [pre-overlap from seg1] + [merged overlap] + [post-overlap from seg2]</span>
        <span class="n">t_merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">t1_before</span><span class="p">,</span> <span class="n">t_overlap_all</span><span class="p">,</span> <span class="n">t2_after</span><span class="p">])</span>
        <span class="n">y_merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y1_before</span><span class="p">,</span> <span class="n">y_overlap_merged</span><span class="p">,</span> <span class="n">y2_after</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create merged segment</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">TrajectorySegment</span><span class="p">()</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t_merged</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y_merged</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t_merged</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">t_merged</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Create piecewise merged interpolant</span>
        <span class="c1"># Piecewise definition:</span>
        <span class="c1">#   - Pre-overlap: use seg1.interpolant</span>
        <span class="c1">#   - Overlap: average (seg1.interpolant + seg2.interpolant) / 2</span>
        <span class="c1">#   - Post-overlap: use seg2.interpolant</span>
        <span class="c1"># Returns None if either segment lacks interpolant (dense_output=False)</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">_create_merged_interpolant</span><span class="p">(</span>
            <span class="n">seg1</span><span class="p">,</span> <span class="n">seg2</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">merged</span><span class="o">.</span><span class="n">domain</span>
        <span class="p">)</span>

        <span class="c1"># Method string indicates multi-method composition</span>
        <span class="c1"># e.g., &quot;RK45+DOP853&quot; shows this segment combines two different solvers</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">seg1</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">+</span><span class="si">{</span><span class="n">seg2</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Metadata: Aggregate success flags and messages from both segments</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="n">seg1</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">seg2</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">],</span>
            <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Merged: </span><span class="si">{</span><span class="n">seg1</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">seg2</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">merged</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_segments_stitch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">seg1</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span> 
        <span class="n">seg2</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span> 
        <span class="n">overlap</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajectorySegment</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two segments by stitching their interpolants at the overlap point.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg1 (TrajectorySegment): First segment</span>
<span class="sd">            seg2 (TrajectorySegment): Second segment</span>
<span class="sd">            overlap (Tuple[float, float]): Overlap interval [a, b]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Merge policy &#39;stitch&#39; not yet implemented for Trajectory class&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_segments_left</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">seg1</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span> 
        <span class="n">seg2</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span> 
        <span class="n">overlap</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajectorySegment</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two segments by using the left segment&#39;s interpolant in the overlap region.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg1 (TrajectorySegment): First segment</span>
<span class="sd">            seg2 (TrajectorySegment): Second segment</span>
<span class="sd">            overlap (Tuple[float, float]): Overlap interval [a, b]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Merge policy &#39;left&#39; not yet implemented for Trajectory class&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_segments_right</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">seg1</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span> 
        <span class="n">seg2</span><span class="p">:</span> <span class="n">TrajectorySegment</span><span class="p">,</span> 
        <span class="n">overlap</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajectorySegment</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two segments by using the right segment&#39;s interpolant in the overlap region.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg1 (TrajectorySegment): First segment</span>
<span class="sd">            seg2 (TrajectorySegment): Second segment</span>
<span class="sd">            overlap (Tuple[float, float]): Overlap interval [a, b]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Merge policy &#39;right&#39; not yet implemented for Trajectory class&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_disjoint_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that all segment domains are disjoint (class invariant).</span>

<span class="sd">        CLASS INVARIANT:</span>
<span class="sd">        ---------------</span>
<span class="sd">        After merging, all segment domains MUST be disjoint (non-overlapping).</span>
<span class="sd">        This is enforced by:</span>
<span class="sd">          - from_segments(): Detects and merges all overlaps before validation</span>
<span class="sd">          - This method: Final check that merging succeeded</span>

<span class="sd">        Mathematically: For domains [a_i, b_i], we require:</span>
<span class="sd">          b_i &lt;= a_{i+1} for all consecutive pairs i, i+1</span>

<span class="sd">        Tangent domains ([a,b] and [b,c]) are allowed (b_i = a_{i+1}).</span>
<span class="sd">        Disjoint domains ([a,b] and [c,d] with b &lt; c) are allowed.</span>
<span class="sd">        Overlapping domains ([a,b] and [c,d] with c &lt; b &lt; d) are NOT allowed after merging.</span>

<span class="sd">        Checks that domains[i][1] &lt;= domains[i+1][0] for all consecutive pairs.</span>
<span class="sd">        This ensures no overlap remains after merging.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If any domains overlap (indicates bug in merge logic)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">current_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">next_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Check for overlap: current segment extends past start of next segment</span>
            <span class="k">if</span> <span class="n">current_end</span> <span class="o">&gt;</span> <span class="n">next_start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Segment domains are not disjoint: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;domain </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> ends at </span><span class="si">{</span><span class="n">current_end</span><span class="si">}</span><span class="s2">, but domain </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> starts at </span><span class="si">{</span><span class="n">next_start</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Overlapping domains detected after merging. This is a bug in merge logic.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_segment_containing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TrajectorySegment</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find segment whose domain contains time t.</span>

<span class="sd">        Uses linear search (optimize with binary search later if needed).</span>

<span class="sd">        Args:</span>
<span class="sd">            t (float): Time point to locate</span>

<span class="sd">        Returns:</span>
<span class="sd">            EuclideanTrajectorySegment if found, else None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">in_domain</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">segment</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.message" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">message</span><span class="p">:</span> <span class="nb">str</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Aggregated messages from all segments.</p>
<p>Convenience property for backwards compatibility with SciPyIvpSolution.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>str</code></td>            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Combined message from all segments</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.success" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">success</span><span class="p">:</span> <span class="nb">bool</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Whether all segment integrations succeeded.</p>
<p>Convenience property for backwards compatibility with SciPyIvpSolution.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>bool</code></td>            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>True if all segments successful, False otherwise</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.t" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">t</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Concatenated evaluation times from all segments.</p>
<p>Note: May contain duplicate values at segment boundaries (tangent domains).</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="numpy.typing.NDArray">NDArray</span>[<span title="numpy.float64">float64</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>NDArray[np.float64]: All evaluation times, shape (total_points,)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.y" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">y</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Concatenated states from all segments.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="numpy.typing.NDArray">NDArray</span>[<span title="numpy.float64">float64</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>NDArray[np.float64]: All states, shape (n_dim, total_points)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>




<div class="doc doc-object doc-function">


<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.from_segments" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">from_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TrajectorySegment</span><span class="p">],</span> <span class="n">merge_policy</span><span class="p">:</span> <span class="n">TrajectorySegmentMergePolicy</span> <span class="o">=</span> <span class="s1">&#39;average&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trajectory</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Factory: Create trajectory from list of segments, merging overlaps if needed.</p>
<h5 id="PyDynSys.core.euclidean.trajectory.Trajectory.from_segments--merge-algorithm-iterative-fixed-point-approach">MERGE ALGORITHM: Iterative Fixed-Point Approach</h5>
<p>This method implements an iterative fixed-point algorithm to merge overlapping
segments until all domains are disjoint (class invariant).</p>
<p>Problem: Cascading overlaps require multiple merge passes.
Example: Segments [[0,1], [0.5,2], [1,3]] have:
  - Pass 1: Merge [0,1] + [0.5,2] ‚Üí [0,2]
  - Pass 2: Merge [0,2] + [1,3] ‚Üí [0,3]</p>


<details class="algorithm" open>
  <summary>Algorithm</summary>
  <ol>
<li>Sort segments by domain start time (ensures left-to-right processing)</li>
<li>Fixed-point iteration:
   a. Scan through current segment list left-to-right
   b. For each consecutive pair, detect overlap
   c. If overlap exists, merge the pair and add to result
   d. If no overlap, add current segment to result
   e. If any merges occurred, repeat from step 2a
   f. If no merges occurred, fixed point reached ‚Üí done</li>
</ol>
</details>        <p>Invariant: At each iteration, segments in the working list are sorted by start time.
This ensures that after merging two consecutive segments, the merged segment
cannot overlap with any previously processed segments (they all ended before
the current segment started, by the inductive property of sorted order).</p>


<details class="termination" open>
  <summary>Guaranteed because:</summary>
  <ul>
<li>Each merge reduces the number of segments by 1</li>
<li>Minimum segments = 1 (fully merged trajectory)</li>
<li>Maximum iterations = n-1 (worst case: chain of n segments)</li>
</ul>
</details>

<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>segments</code>
            </td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="PyDynSys.core.euclidean.trajectory.EuclideanTrajectorySegment">EuclideanTrajectorySegment</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Segments to compose</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>merge_policy</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="TrajectorySegmentMergePolicy = Literal['average', 'left', 'right', 'stitch']

  
      module-attribute
   (PyDynSys.core.types.TrajectorySegmentMergePolicy)" href="../../#PyDynSys.core.TrajectorySegmentMergePolicy">TrajectorySegmentMergePolicy</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Strategy for handling overlaps
- 'average' (DEFAULT): Average y values in overlap region
- 'left': Use left segment in overlap
- 'right': Use right segment in overlap
- 'stitch': Left interpolant until midpoint, then right</p>
              </div>
            </td>
            <td>
                  <code>&#39;average&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>EuclideanTrajectory</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="PyDynSys.core.euclidean.trajectory.Trajectory" href="#PyDynSys.core.euclidean.trajectory.Trajectory">Trajectory</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Composite trajectory with disjoint segment domains</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If final domains are not disjoint (merging failed)</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="RuntimeError">RuntimeError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If merge algorithm fails to converge (indicates bug)</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="NotImplementedError">NotImplementedError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If merge_policy is not 'average' (others not yet implemented)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>seg1 = TrajectorySegment.from_scipy_solution(sol1, 'RK45')
seg2 = TrajectorySegment.from_scipy_solution(sol2, 'RK45')
traj = Trajectory.from_segments([seg1, seg2])</p>
</blockquote>
</blockquote>
</blockquote>
</details>

            <details class="quote">
              <summary>Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_segments</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">segments</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TrajectorySegment</span><span class="p">],</span>
    <span class="n">merge_policy</span><span class="p">:</span> <span class="n">TrajectorySegmentMergePolicy</span> <span class="o">=</span> <span class="s1">&#39;average&#39;</span>  <span class="c1"># Default: average overlapping values</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory: Create trajectory from list of segments, merging overlaps if needed.</span>

<span class="sd">    MERGE ALGORITHM: Iterative Fixed-Point Approach</span>
<span class="sd">    ------------------------------------------------</span>
<span class="sd">    This method implements an iterative fixed-point algorithm to merge overlapping</span>
<span class="sd">    segments until all domains are disjoint (class invariant).</span>

<span class="sd">    Problem: Cascading overlaps require multiple merge passes.</span>
<span class="sd">    Example: Segments [[0,1], [0.5,2], [1,3]] have:</span>
<span class="sd">      - Pass 1: Merge [0,1] + [0.5,2] ‚Üí [0,2]</span>
<span class="sd">      - Pass 2: Merge [0,2] + [1,3] ‚Üí [0,3]</span>

<span class="sd">    Algorithm:</span>
<span class="sd">      1. Sort segments by domain start time (ensures left-to-right processing)</span>
<span class="sd">      2. Fixed-point iteration:</span>
<span class="sd">         a. Scan through current segment list left-to-right</span>
<span class="sd">         b. For each consecutive pair, detect overlap</span>
<span class="sd">         c. If overlap exists, merge the pair and add to result</span>
<span class="sd">         d. If no overlap, add current segment to result</span>
<span class="sd">         e. If any merges occurred, repeat from step 2a</span>
<span class="sd">         f. If no merges occurred, fixed point reached ‚Üí done</span>

<span class="sd">    Invariant: At each iteration, segments in the working list are sorted by start time.</span>
<span class="sd">    This ensures that after merging two consecutive segments, the merged segment</span>
<span class="sd">    cannot overlap with any previously processed segments (they all ended before</span>
<span class="sd">    the current segment started, by the inductive property of sorted order).</span>

<span class="sd">    Termination: Guaranteed because:</span>
<span class="sd">      - Each merge reduces the number of segments by 1</span>
<span class="sd">      - Minimum segments = 1 (fully merged trajectory)</span>
<span class="sd">      - Maximum iterations = n-1 (worst case: chain of n segments)</span>

<span class="sd">    Args:</span>
<span class="sd">        segments (List[EuclideanTrajectorySegment]): Segments to compose</span>
<span class="sd">        merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps</span>
<span class="sd">            - &#39;average&#39; (DEFAULT): Average y values in overlap region</span>
<span class="sd">            - &#39;left&#39;: Use left segment in overlap</span>
<span class="sd">            - &#39;right&#39;: Use right segment in overlap</span>
<span class="sd">            - &#39;stitch&#39;: Left interpolant until midpoint, then right</span>

<span class="sd">    Returns:</span>
<span class="sd">        EuclideanTrajectory: Composite trajectory with disjoint segment domains</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If final domains are not disjoint (merging failed)</span>
<span class="sd">        RuntimeError: If merge algorithm fails to converge (indicates bug)</span>
<span class="sd">        NotImplementedError: If merge_policy is not &#39;average&#39; (others not yet implemented)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; seg1 = TrajectorySegment.from_scipy_solution(sol1, &#39;RK45&#39;)</span>
<span class="sd">        &gt;&gt;&gt; seg2 = TrajectorySegment.from_scipy_solution(sol2, &#39;RK45&#39;)</span>
<span class="sd">        &gt;&gt;&gt; traj = Trajectory.from_segments([seg1, seg2])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">segments</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot create trajectory from empty segment list&quot;</span><span class="p">)</span>

    <span class="c1"># Sort segments by domain start time (critical for correct merge order)</span>
    <span class="n">working_segments</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">seg</span><span class="p">:</span> <span class="n">seg</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


    <span class="c1"># ITERATIVE FIXED-POINT MERGE ALGORITHM #</span>
    <span class="c1">## o(num_segments^2) worst case complexity</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_iterations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>  <span class="c1"># Safety limit (should never be reached)</span>
    <span class="k">while</span> <span class="n">changed</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">max_iterations</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">merged_segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># pass through working segments, merging consecutive overlaps</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">working_segments</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">working_segments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">working_segments</span><span class="p">):</span>
                <span class="n">next_seg</span> <span class="o">=</span> <span class="n">working_segments</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_detect_overlap</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Overlapping segments detected - merge them</span>
                    <span class="k">if</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
                        <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_average</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                        <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                    <span class="k">elif</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                        <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_left</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                        <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                    <span class="k">elif</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                        <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_right</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                        <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                    <span class="k">elif</span> <span class="n">merge_policy</span> <span class="o">==</span> <span class="s1">&#39;stitch&#39;</span><span class="p">:</span>
                        <span class="n">merged</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_merge_segments_stitch</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next_seg</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                        <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># Skip both segments (merged into one)</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark that we made progress</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown merge policy: </span><span class="si">{</span><span class="n">merge_policy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Disjoint segments - keep current and move forward</span>
                    <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Last segment - no next segment to check for overlap</span>
                <span class="n">merged_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Update working list for next iteration (if needed)</span>
        <span class="n">working_segments</span> <span class="o">=</span> <span class="n">merged_segments</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;=</span> <span class="n">max_iterations</span><span class="p">:</span>
        <span class="c1"># This should never happen in practice, but safety check</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Merge algorithm failed to converge after </span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2"> iterations. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;This indicates a bug in the merge logic.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Final merged segments (guaranteed disjoint by fixed-point property)</span>
    <span class="n">merged_segments</span> <span class="o">=</span> <span class="n">working_segments</span>

    <span class="c1"># Create trajectory instance</span>
    <span class="n">trajectory</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
    <span class="n">trajectory</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="n">merged_segments</span>
    <span class="n">trajectory</span><span class="o">.</span><span class="n">domains</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">domain</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">]</span>

    <span class="c1"># Aggregate metadata</span>
    <span class="n">trajectory</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;all_successful&#39;</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">),</span>
        <span class="s1">&#39;messages&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">],</span>
        <span class="s1">&#39;methods&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">method</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">merged_segments</span><span class="p">],</span>
    <span class="p">}</span>


    <span class="n">trajectory</span><span class="o">.</span><span class="n">_validate_disjoint_domains</span><span class="p">()</span> <span class="c1"># Validate disjoint domains (class invariant)</span>
    <span class="k">return</span> <span class="n">trajectory</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.in_domain" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">in_domain</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if time t is within trajectory domain (any segment).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>t</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Time point to check</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>bool</code></td>            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>True if t is in any segment's domain, False otherwise</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">in_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if time t is within trajectory domain (any segment).</span>

<span class="sd">    Args:</span>
<span class="sd">        t (float): Time point to check</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if t is in any segment&#39;s domain, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">in_domain</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.interpolate" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Seamlessly interpolate trajectory at time t.</p>
<h5 id="PyDynSys.core.euclidean.trajectory.Trajectory.interpolate--key-feature-unified-interface-across-composite-trajectories">KEY FEATURE: Unified interface across composite trajectories</h5>
<p>This method provides seamless interpolation even when the trajectory is
composed of multiple disjoint segments. The user doesn't need to know
which segment contains t - we handle the dispatch automatically.</p>


<details class="example-use-case" open>
  <summary>Example use case</summary>
  <p>Bidirectional trajectory with domains [(-5, 0], [0, 5]]:
  traj.interpolate(-3.0) ‚Üí dispatches to backward segment
  traj.interpolate(0.0)  ‚Üí dispatches to forward segment (both have it, we pick first)
  traj.interpolate(3.0)  ‚Üí dispatches to forward segment
  traj.interpolate(10.0) ‚Üí raises ValueError (not in any domain)</p>
</details>        <p>Implementation: O(n) linear search through segments (optimize with binary search later)</p>
<p>Automatically finds the segment containing t and delegates to that segment's
interpolant. Provides unified interface across potentially disjoint domains.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>t</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Time point for evaluation</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="numpy.typing.NDArray">NDArray</span>[<span title="numpy.float64">float64</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>NDArray[np.float64]: State vector x(t) at time t</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If t not in any segment domain</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>traj = sys.trajectory(...)  # May have multiple segments
x_5 = traj.interpolate(5.0)  # Seamlessly finds right segment</p>
</blockquote>
</blockquote>
</blockquote>
</details>

            <details class="quote">
              <summary>Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Seamlessly interpolate trajectory at time t.</span>

<span class="sd">    KEY FEATURE: Unified interface across composite trajectories</span>
<span class="sd">    ------------------------------------------------------------</span>
<span class="sd">    This method provides seamless interpolation even when the trajectory is</span>
<span class="sd">    composed of multiple disjoint segments. The user doesn&#39;t need to know</span>
<span class="sd">    which segment contains t - we handle the dispatch automatically.</span>

<span class="sd">    Example use case:</span>
<span class="sd">      Bidirectional trajectory with domains [(-5, 0], [0, 5]]:</span>
<span class="sd">        traj.interpolate(-3.0) ‚Üí dispatches to backward segment</span>
<span class="sd">        traj.interpolate(0.0)  ‚Üí dispatches to forward segment (both have it, we pick first)</span>
<span class="sd">        traj.interpolate(3.0)  ‚Üí dispatches to forward segment</span>
<span class="sd">        traj.interpolate(10.0) ‚Üí raises ValueError (not in any domain)</span>

<span class="sd">    Implementation: O(n) linear search through segments (optimize with binary search later)</span>

<span class="sd">    Automatically finds the segment containing t and delegates to that segment&#39;s</span>
<span class="sd">    interpolant. Provides unified interface across potentially disjoint domains.</span>

<span class="sd">    Args:</span>
<span class="sd">        t (float): Time point for evaluation</span>

<span class="sd">    Returns:</span>
<span class="sd">        NDArray[np.float64]: State vector x(t) at time t</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If t not in any segment domain</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; traj = sys.trajectory(...)  # May have multiple segments</span>
<span class="sd">        &gt;&gt;&gt; x_5 = traj.interpolate(5.0)  # Seamlessly finds right segment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_segment_containing</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">segment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Time t=</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> not in any segment domain. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Available domains: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">domains</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># This may further raise ValueError if segment has no interpolant (dense_output=False)</span>
    <span class="k">return</span> <span class="n">segment</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="PyDynSys.core.euclidean.trajectory.Trajectory.merge" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Trajectory</span><span class="p">,</span> <span class="n">merge_policy</span><span class="p">:</span> <span class="n">TrajectorySegmentMergePolicy</span> <span class="o">=</span> <span class="s1">&#39;average&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trajectory</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Join this trajectory with another trajectory.</p>
<p>Combines segments from both trajectories and merges any overlaps using
the specified merge policy. Uses the same iterative fixed-point merge
algorithm as from_segments() to handle cascading overlaps.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>other</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="PyDynSys.core.euclidean.trajectory.Trajectory" href="#PyDynSys.core.euclidean.trajectory.Trajectory">Trajectory</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The other trajectory to join with self</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>merge_policy</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="TrajectorySegmentMergePolicy = Literal['average', 'left', 'right', 'stitch']

  
      module-attribute
   (PyDynSys.core.types.TrajectorySegmentMergePolicy)" href="../../#PyDynSys.core.TrajectorySegmentMergePolicy">TrajectorySegmentMergePolicy</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Strategy for handling overlaps
- 'average' (DEFAULT): Average y values in overlap region
- 'left': Use left segment in overlap
- 'right': Use right segment in overlap
- 'stitch': Left interpolant until midpoint, then right</p>
              </div>
            </td>
            <td>
                  <code>&#39;average&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Trajectory</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="PyDynSys.core.euclidean.trajectory.Trajectory" href="#PyDynSys.core.euclidean.trajectory.Trajectory">Trajectory</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>New trajectory containing all segments from both trajectories,
with overlaps merged according to merge_policy</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If final domains are not disjoint (merging failed)</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="RuntimeError">RuntimeError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If merge algorithm fails to converge (indicates bug)</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="NotImplementedError">NotImplementedError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If merge_policy is not 'average' (others not yet implemented)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>traj1 = sys1.trajectory(x0, t_span=(0, 5))
traj2 = sys2.trajectory(x1, t_span=(3, 10))
combined = traj1.join(traj2)  # Merges overlap in [3, 5]</p>
</blockquote>
</blockquote>
</blockquote>
</details>

            <details class="quote">
              <summary>Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">,</span>
    <span class="n">merge_policy</span><span class="p">:</span> <span class="n">TrajectorySegmentMergePolicy</span> <span class="o">=</span> <span class="s1">&#39;average&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Trajectory&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Join this trajectory with another trajectory.</span>

<span class="sd">    Combines segments from both trajectories and merges any overlaps using</span>
<span class="sd">    the specified merge policy. Uses the same iterative fixed-point merge</span>
<span class="sd">    algorithm as from_segments() to handle cascading overlaps.</span>

<span class="sd">    Args:</span>
<span class="sd">        other (Trajectory): The other trajectory to join with self</span>
<span class="sd">        merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps</span>
<span class="sd">            - &#39;average&#39; (DEFAULT): Average y values in overlap region</span>
<span class="sd">            - &#39;left&#39;: Use left segment in overlap</span>
<span class="sd">            - &#39;right&#39;: Use right segment in overlap</span>
<span class="sd">            - &#39;stitch&#39;: Left interpolant until midpoint, then right</span>

<span class="sd">    Returns:</span>
<span class="sd">        Trajectory: New trajectory containing all segments from both trajectories,</span>
<span class="sd">            with overlaps merged according to merge_policy</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If final domains are not disjoint (merging failed)</span>
<span class="sd">        RuntimeError: If merge algorithm fails to converge (indicates bug)</span>
<span class="sd">        NotImplementedError: If merge_policy is not &#39;average&#39; (others not yet implemented)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; traj1 = sys1.trajectory(x0, t_span=(0, 5))</span>
<span class="sd">        &gt;&gt;&gt; traj2 = sys2.trajectory(x1, t_span=(3, 10))</span>
<span class="sd">        &gt;&gt;&gt; combined = traj1.join(traj2)  # Merges overlap in [3, 5]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Combine segments from both trajectories</span>
    <span class="n">combined_segments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="c1"># Use from_segments factory to merge overlaps and create new trajectory</span>
    <span class="k">return</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">from_segments</span><span class="p">(</span><span class="n">combined_segments</span><span class="p">,</span> <span class="n">merge_policy</span><span class="o">=</span><span class="n">merge_policy</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../../..", "features": ["navigation.tabs", "navigation.sections", "search.highlight"], "search": "../../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
      
        <script src="../../../../javascript/katex-config.js"></script>
      
    
  </body>
</html>