{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyDynSys","text":"<p>PyDynSys is a mathematically mature Python dynamical systems library, providing both symbolic and functional support for the analysis of such systems through an object-oriented lens.</p> <p>Our mission, fundamentally, is to consolidate methods and examples concerning dynamical systems\u2014from the elementary to the cutting-edge\u2014in an easily usable Python library; to provide significant pedagogical value for the student and researcher alike, and to further stimulate the curiosity necessary to motivate further developments in this rich branch of mathematics. </p> <p>Our object-oriented architecture facilitates this ambitious mission by structuring both symbolic and numerical capabilities in a unified framework. This allows for both the broad applicability of our utilities and the seamless development of new functionality.</p> <p>This will not be possible without extensive community effort. We discuss contribution here.</p>"},{"location":"#versioning","title":"Versioning","text":"<p>Versions 0.x.y are purely experimental and not intended for consumption. They're poorly documented, and were just the necessary sequence of steps required taken to port over legacy functionality into a framework robust enough to facilitate our ambitious goals.</p> <p>Versions 1.x.y support only Euclidean dynamical systems, but in future versions we plan to support more general systems (e.g. monoid \\(T\\), non-euclidean \\(X\\)) and stochastic systems. To work on these core changes, see the relevant feature branches. </p>"},{"location":"api/core/","title":"PyDynSys.core Module","text":"<p>The <code>PyDynSys.core</code> module provides the foundational classes and utilities for working with Euclidean dynamical systems.</p>"},{"location":"api/core/#submodules","title":"Submodules","text":"<ul> <li>Core.Euclidean Module - Euclidean dynamical systems and related types</li> </ul>"},{"location":"api/core/#main-classes-and-types","title":"Main Classes and Types","text":""},{"location":"api/core/#dynamical-systems","title":"Dynamical Systems","text":"<ul> <li>EuclideanDS - Abstract base class for Euclidean dynamical systems</li> <li>AutonomousEuclideanDS - Systems where dx/dt = F(x)</li> <li>NonAutonomousEuclideanDS - Systems where dx/dt = F(x, t)</li> </ul>"},{"location":"api/core/#trajectory-types","title":"Trajectory Types","text":"<ul> <li>EuclideanTrajectorySegment - Single trajectory segment</li> <li>EuclideanTrajectory - Composed trajectory over multiple segments</li> </ul>"},{"location":"api/core/#phase-space-and-time","title":"Phase Space and Time","text":"<ul> <li>PhaseSpace - Phase space representation with symbolic and callable constraints</li> <li>TimeHorizon - Time domain representation</li> </ul>"},{"location":"api/core/#system-builder","title":"System Builder","text":"<ul> <li>SymbolicSystemBuilder - Build systems from symbolic ODEs</li> </ul>"},{"location":"api/core/#type-definitions","title":"Type Definitions","text":"<ul> <li><code>AutonomousVectorField</code> - Vector field type for autonomous systems</li> <li><code>NonAutonomousVectorField</code> - Vector field type for non-autonomous systems</li> <li><code>VectorField</code> - Union type for any vector field</li> <li><code>SymbolicODE</code> - Symbolic ODE representation</li> <li><code>SystemParameters</code> - Parameter substitution dictionary</li> <li><code>TrajectoryCacheKey</code> - Cache key for trajectory solutions</li> <li><code>SciPyIvpSolution</code> - SciPy IVP solution wrapper</li> <li><code>TrajectorySegmentMergePolicy</code> - Policy for merging trajectory segments</li> </ul>"},{"location":"api/core/#full-docs","title":"Full Docs","text":""},{"location":"api/core/#PyDynSys.core","title":"<code>PyDynSys.core</code>","text":"<p>Core module for PyFlow dynamical systems library.</p>"},{"location":"api/core/#PyDynSys.core.AutonomousVectorField","title":"<code>AutonomousVectorField = Callable[[NDArray[np.float64]], NDArray[np.float64]]</code>  <code>module-attribute</code>","text":"<p>Vector field for autonomous systems: F: R^n \u2192 R^n Maps state vector x to derivative dx/dt = F(x)</p>"},{"location":"api/core/#PyDynSys.core.NonAutonomousVectorField","title":"<code>NonAutonomousVectorField = Callable[[NDArray[np.float64], float], NDArray[np.float64]]</code>  <code>module-attribute</code>","text":"<p>Vector field for non-autonomous systems: F: R^n \u00d7 R \u2192 R^n Maps (state x, time t) to derivative dx/dt = F(x, t)</p>"},{"location":"api/core/#PyDynSys.core.SymbolicODE","title":"<code>SymbolicODE = Union[List[syp.Expr], syp.Expr, str, List[str]]</code>  <code>module-attribute</code>","text":"<p>Union type for symbolic ODE representations. Accepts: single expression, list of expressions, or string forms. Expected format: d(x_i)/dt - F_i(x, t) = 0 (we drop the \"= 0\")</p>"},{"location":"api/core/#PyDynSys.core.SystemParameters","title":"<code>SystemParameters = Union[Dict[str, float], Dict[syp.Symbol, float]]</code>  <code>module-attribute</code>","text":"<p>Parameter substitution dictionary for symbolic systems. Keys: parameter names (str) or SymPy symbols Values: numerical parameter values NOTE: All keys in a single dict must be same type (all str or all Symbol)</p>"},{"location":"api/core/#PyDynSys.core.TrajectorySegmentMergePolicy","title":"<code>TrajectorySegmentMergePolicy = Literal['average', 'left', 'right', 'stitch']</code>  <code>module-attribute</code>","text":"<p>Strategy for merging overlapping trajectory segments in EuclideanTrajectory.from_segments().</p>"},{"location":"api/core/#PyDynSys.core.TrajectorySegmentMergePolicy--when-overlaps-occur","title":"WHEN OVERLAPS OCCUR:","text":"<p>Overlapping domains arise when the same physical trajectory is computed multiple times over intersecting time intervals. Common scenarios:   1. Re-solving for comparison: Solve [0,1.5] with RK45, then [0.5,2] with DOP853   2. Patching numerical errors: Re-solve unstable region with tighter tolerances   3. Composing from cache: Merging cached trajectories to avoid recomputation</p>"},{"location":"api/core/#PyDynSys.core.TrajectorySegmentMergePolicy--merge-policies","title":"MERGE POLICIES:","text":"<p>When two segments overlap on [a, b], we must decide:   - Which y values to use at shared evaluation points?   - Which interpolant to use for continuous evaluation in [a, b]?</p> <p>Available policies: - 'average' (DEFAULT): Average y values at shared evaluation points in overlap region.                        Takes midpoint between competing numerical approximations.                        Interpolant set to None (limitation of current implementation).                        Use case: Equal trust in both segments, want best estimate.</p> <ul> <li> <p>'left': Prioritize left segment's values and interpolant in overlap region.           Use case: Left segment has higher accuracy (tighter tolerance, better method).           Status: Not yet implemented (raises NotImplementedError).</p> </li> <li> <p>'right': Prioritize right segment's values and interpolant in overlap region.            Use case: Right segment has higher accuracy or is more recent computation.            Status: Not yet implemented (raises NotImplementedError).</p> </li> <li> <p>'stitch': Use left segment's interpolant until overlap midpoint, then right's.             Creates continuous transition across overlap region.             Use case: Both segments equally valid, want smooth transition.             Status: Not yet implemented (raises NotImplementedError).</p> </li> </ul>"},{"location":"api/core/#PyDynSys.core.TrajectorySegmentMergePolicy--tangent-domains-special-case","title":"TANGENT DOMAINS (Special Case):","text":"<p>When domains touch at exactly one point (e.g., [0,1] + [1,2]), the \"overlap\" is just the boundary. The average policy automatically handles this by averaging the single shared point, which is correct for tangent segments from bidirectional integration where both segments share x(t_0) at the tangent point.</p> <p>Note: Only 'average' is implemented in current version. Others raise NotImplementedError.</p>"},{"location":"api/core/#PyDynSys.core.VectorField","title":"<code>VectorField = Union[AutonomousVectorField, NonAutonomousVectorField]</code>  <code>module-attribute</code>","text":"<p>Union type for any vector field representation. NOTE: For type safety, prefer specific types in implementations.</p>"},{"location":"api/core/#PyDynSys.core.SymbolicSystemBuilder","title":"<code>SymbolicSystemBuilder</code>","text":"<p>Converts symbolic ODE representations to numerical vector fields.</p> <p>Handles: - Parsing various symbolic input formats (str, syp.Expr, lists) - Parameter substitution - First-order system validation - Autonomous vs non-autonomous detection - Compilation to efficient numerical functions via syp.lambdify</p> Source code in <code>src/PyDynSys/core/sym_utils.py</code> <pre><code>class SymbolicSystemBuilder:\n    \"\"\"\n    Converts symbolic ODE representations to numerical vector fields.\n\n    Handles:\n    - Parsing various symbolic input formats (str, syp.Expr, lists)\n    - Parameter substitution\n    - First-order system validation\n    - Autonomous vs non-autonomous detection\n    - Compilation to efficient numerical functions via syp.lambdify\n    \"\"\"\n\n    @staticmethod\n    def build_vector_field(\n        equations: SymbolicODE,\n        variables: List[syp.Function],\n        parameters: SystemParameters = None\n    ) -&gt; SymbolicToVectorFieldResult:\n        \"\"\"\n        Convert symbolic ODE system to numerical vector field.\n\n        Auto-detects whether system is autonomous by checking if time `t` \n        appears in any derivative after solving for dx/dt.\n\n\n        Args:\n            equations (SymbolicODE): Symbolic system expressed as d(x_i)/dt - F_i(x, t), i=1,...,n\n                -&gt; SymbolicODE = Union[List[syp.Expr], syp.Expr, str, List[str]]\n                -&gt; str use is highly experimental and not recommended. \n            variables (List[syp.Function]): List of dependent variables as SymPy Function objects\n                -&gt; support for strings may be supported later, but not a pressing matter.\n            parameters (SystemParameters): Optional parameter substitution dict \n                -&gt; SystemParameters = Union[Dict[str, float], Dict[syp.Symbol, float]]\n\n\n        Returns:\n            SymbolicToVectorFieldResult wrapper, which itself contains:\n                - vector_field: Callable with appropriate signature\n                - dimension: Phase space dimension n\n                - is_autonomous: True &lt;==&gt;  partial(vector_field, t) = 0\n\n        Raises:\n            ValueError: If system is not first-order \n\n\n        Example:\n            &gt;&gt;&gt; t = syp.symbols('t')\n            &gt;&gt;&gt; x, y = syp.symbols('x y', cls=syp.Function)\n            &gt;&gt;&gt; x, y = x(t), y(t)\n            &gt;&gt;&gt; eqs = [syp.diff(x, t) - y, syp.diff(y, t) + x]\n            &gt;&gt;&gt; result = SymbolicSystemBuilder.build_vector_field(eqs, [x, y])\n            &gt;&gt;&gt; result.is_autonomous  # True (no explicit t dependence)\n            True\n        \"\"\"\n        # Parse symbolic input\n        parsed_equations = SymbolicSystemBuilder._parse_symbolic_input(equations)\n\n        # Validate first-order system\n        if not SymbolicSystemBuilder._is_first_order_system(parsed_equations, variables):\n            raise ValueError(\n                \"Only first-order systems are currently supported. \"\n                \"nth-order systems will be supported in future versions.\"\n            )\n\n        # Get dimension\n        dimension = len(variables)\n\n        # Solve for derivatives: d(x_i)/dt = F_i(x, t)\n        t_sym = syp.symbols('t')\n        derivatives = []\n        for i, equation in enumerate(parsed_equations):\n            derivative = syp.solve(equation, syp.diff(variables[i], t_sym))[0]\n            derivatives.append(derivative)\n\n        # Normalise parameters and substitute\n        normalised_parameters = SymbolicSystemBuilder._normalise_parameters(parameters)\n\n        # Convert Function objects to symbols for substitution\n        state_names = [var.func.__name__ for var in variables]\n        state_symbols = syp.symbols(' '.join(state_names))\n        if dimension == 1:\n            state_symbols = (state_symbols,)  # Ensure tuple\n\n        # Build function \u2192 symbol mapping\n        if dimension == 1:\n            function_to_symbol_map = {variables[0]: state_symbols[0]}\n        else:\n            function_to_symbol_map = {var: state_symbols[i] for i, var in enumerate(variables)}\n\n        # Apply all substitutions\n        all_substitutions = {**function_to_symbol_map, **normalised_parameters}\n        derivatives_substituted = [der.subs(all_substitutions) for der in derivatives]\n\n        # Detect autonomy\n        is_autonomous = SymbolicSystemBuilder._detect_autonomy(derivatives_substituted, t_sym)\n\n        # Build appropriate vector field\n        if is_autonomous:\n            vector_field = SymbolicSystemBuilder._build_autonomous_field(\n                derivatives_substituted, state_symbols, dimension\n            )\n        else:\n            vector_field = SymbolicSystemBuilder._build_nonautonomous_field(\n                derivatives_substituted, state_symbols, t_sym, dimension\n            )\n\n        return SymbolicToVectorFieldResult(\n            vector_field=vector_field,\n            dimension=dimension,\n            is_autonomous=is_autonomous\n        )\n\n    @staticmethod\n    def _parse_symbolic_input(symbolic_system: SymbolicODE) -&gt; List[syp.Expr]:\n        \"\"\"\n        Parse various symbolic input formats into list of expressions.\n\n        Accepts:\n        - Single string: \"d(x)/dt - f(x, t)\"\n        - Single expression: syp.Expr object\n        - List of strings: [\"d(x)/dt - f1\", \"d(y)/dt - f2\"]\n        - List of expressions: [syp.Expr, syp.Expr, ...]\n\n        Returns:\n            List of sympy expressions\n        \"\"\"\n        if isinstance(symbolic_system, str):\n            # Parse string representation\n            return [syp.sympify(symbolic_system)]\n        elif isinstance(symbolic_system, syp.Expr):\n            # Single expression\n            return [symbolic_system]\n        elif isinstance(symbolic_system, list):\n            # List of expressions or strings\n            return [syp.sympify(expr) if isinstance(expr, str) else expr for expr in symbolic_system]\n        else:\n            raise TypeError(\n                f\"Unsupported symbolic system type: {type(symbolic_system)}. \"\n                f\"Expected str, syp.Expr, or list of these.\"\n            )\n\n    @staticmethod\n    def _normalise_parameters(parameters: SystemParameters) -&gt; Dict[syp.Symbol, float]:\n        \"\"\"\n        Convert parameter dict to syp.subs() compatible format.\n\n        Handles both string keys and Symbol keys, converting to Symbol keys\n        for consistency with SymPy's subs() method.\n\n        Args:\n            parameters: Dict with str or syp.Symbol keys, float values\n\n        Returns:\n            Dict with syp.Symbol keys, float values\n        \"\"\"\n        if not parameters:\n            return {}\n\n        first_key = next(iter(parameters.keys()))\n        if isinstance(first_key, str):\n            # Convert string keys to symbols\n            return {syp.Symbol(key): value for key, value in parameters.items()}\n        else:\n            # Already symbols\n            return parameters\n\n    @staticmethod\n    def _is_first_order_system(\n        equations: List[syp.Expr],\n        variables: List[syp.Function]\n    ) -&gt; bool:\n        \"\"\"\n        Validate system is first-order.\n\n        Checks if any equation contains derivatives of order \u2265 2.\n\n        NOTE: Implementation checks up to 100th order. Not exhaustive but\n        catches all practical cases. Higher-order systems are rare and would\n        likely cause performance issues before reaching order 100.\n\n        Args:\n            equations: List of symbolic expressions\n            variables: List of dependent variables\n\n        Returns:\n            bool: True if system is first-order, False otherwise\n        \"\"\"\n        t_sym = syp.symbols('t')\n        # Check for higher-order derivatives\n        for equation in equations:\n            for variable in variables:\n                for order in range(2, 100):  # Check up to 99th order\n                    if equation.has(syp.diff(variable, t_sym, order)):\n                        return False\n\n        return True\n\n    @staticmethod\n    def _detect_autonomy(\n        derivatives: List[syp.Expr],\n        t_symbol: syp.Symbol\n    ) -&gt; bool:\n        \"\"\"\n        Detect if system is autonomous.\n\n        After solving for dx_i/dt = F_i(x, t), checks if time symbol `t`\n        appears in any F_i. If not, system is autonomous (\u2202F/\u2202t \u2261 0).\n\n        Args:\n            derivatives: List of solved derivatives [F_1, F_2, ..., F_n]\n            t_symbol: Time symbol to check for\n\n        Returns:\n            bool: True if autonomous (no t dependence), False otherwise\n\n        Example:\n            &gt;&gt;&gt; t = syp.symbols('t')\n            &gt;&gt;&gt; x, y = syp.symbols('x y')\n            &gt;&gt;&gt; derivatives = [y, -x]  # Harmonic oscillator: autonomous\n            &gt;&gt;&gt; SymbolicSystemBuilder._detect_autonomy(derivatives, t)\n            True\n            &gt;&gt;&gt; derivatives = [y, -x + syp.sin(t)]  # Driven: non-autonomous\n            &gt;&gt;&gt; SymbolicSystemBuilder._detect_autonomy(derivatives, t)\n            False\n        \"\"\"\n        return not any(der.has(t_symbol) for der in derivatives)\n\n    @staticmethod\n    def _build_autonomous_field(\n        derivatives: List[syp.Expr],\n        state_symbols: Tuple[syp.Symbol, ...],\n        dimension: int\n    ) -&gt; AutonomousVectorField:\n        \"\"\"\n        Compile autonomous vector field: F(x) -&gt; dx/dt.\n\n        Uses syp.lambdify with signature (x_1, ..., x_n) -&gt; [F_1, ..., F_n].\n        Time parameter is excluded from lambdified function signature.\n\n        Args:\n            derivatives: Solved derivatives [F_1, ..., F_n] with no time dependence\n            state_symbols: State variable symbols (x_1, ..., x_n)\n            dimension: Phase space dimension n\n\n        Returns:\n            Autonomous vector field function F: R^n \u2192 R^n\n        \"\"\"\n        # Lambdify each derivative component\n        vector_field_funcs = [\n            syp.lambdify(state_symbols, der, 'numpy') for der in derivatives\n        ]\n\n        def vector_field(state: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n            \"\"\"\n            Numerical autonomous vector field function.\n\n            Args:\n                state: Current state vector [x_1, x_2, ..., x_n]\n\n            Returns:\n                Derivative vector [dx_1/dt, dx_2/dt, ..., dx_n/dt]\n            \"\"\"\n            args = tuple(state)\n\n            derivatives_evaluated = np.array([\n                func(*args) for func in vector_field_funcs\n            ], dtype=np.float64)\n\n            return derivatives_evaluated\n\n        return vector_field\n\n    @staticmethod\n    def _build_nonautonomous_field(\n        derivatives: List[syp.Expr],\n        state_symbols: Tuple[syp.Symbol, ...],\n        t_symbol: syp.Symbol,\n        dimension: int\n    ) -&gt; NonAutonomousVectorField:\n        \"\"\"\n        Compile non-autonomous vector field: F(x, t) -&gt; dx/dt.\n\n        Uses syp.lambdify with signature (x_1, ..., x_n, t) -&gt; [F_1, ..., F_n].\n        Time parameter is included in lambdified function signature.\n\n        Args:\n            derivatives: Solved derivatives [F_1, ..., F_n] possibly depending on t\n            state_symbols: State variable symbols (x_1, ..., x_n)\n            t_symbol: Time symbol t\n            dimension: Phase space dimension n\n\n        Returns:\n            Non-autonomous vector field function F: R^n x R \u2192 R^n\n        \"\"\"\n        # Build lambda signature: (x_1, ..., x_n, t)\n        if dimension == 1:\n            state_vars = (state_symbols[0],) + (t_symbol,)\n        else:\n            state_vars = state_symbols + (t_symbol,)\n\n        # Lambdify each derivative component with time\n        vector_field_funcs = [\n            syp.lambdify(state_vars, der, 'numpy') for der in derivatives\n        ]\n\n        def vector_field(state: NDArray[np.float64], time: float) -&gt; NDArray[np.float64]:\n            \"\"\"\n            Numerical non-autonomous vector field function.\n\n            Args:\n                state: Current state vector [x1, x2, ..., xn]\n                time: Current time t\n\n            Returns:\n                Derivative vector [dx1/dt, dx2/dt, ..., dxn/dt]\n            \"\"\"\n            args = tuple(state) + (time,)\n\n            derivatives_evaluated = np.array([\n                func(*args) for func in vector_field_funcs\n            ], dtype=np.float64)\n\n            return derivatives_evaluated\n\n        return vector_field\n</code></pre>"},{"location":"api/core/#PyDynSys.core.SymbolicSystemBuilder.build_vector_field","title":"<code>build_vector_field(equations, variables, parameters=None)</code>  <code>staticmethod</code>","text":"<p>Convert symbolic ODE system to numerical vector field.</p> <p>Auto-detects whether system is autonomous by checking if time <code>t</code>  appears in any derivative after solving for dx/dt.</p> <p>Parameters:</p> Name Type Description Default <code>equations</code> <code>SymbolicODE</code> <p>Symbolic system expressed as d(x_i)/dt - F_i(x, t), i=1,...,n -&gt; SymbolicODE = Union[List[syp.Expr], syp.Expr, str, List[str]] -&gt; str use is highly experimental and not recommended. </p> required <code>variables</code> <code>List[Function]</code> <p>List of dependent variables as SymPy Function objects -&gt; support for strings may be supported later, but not a pressing matter.</p> required <code>parameters</code> <code>SystemParameters</code> <p>Optional parameter substitution dict  -&gt; SystemParameters = Union[Dict[str, float], Dict[syp.Symbol, float]]</p> <code>None</code> <p>Returns:</p> Type Description <code>SymbolicToVectorFieldResult</code> <p>SymbolicToVectorFieldResult wrapper, which itself contains: - vector_field: Callable with appropriate signature - dimension: Phase space dimension n - is_autonomous: True &lt;==&gt;  partial(vector_field, t) = 0</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If system is not first-order </p> Example <p>t = syp.symbols('t') x, y = syp.symbols('x y', cls=syp.Function) x, y = x(t), y(t) eqs = [syp.diff(x, t) - y, syp.diff(y, t) + x] result = SymbolicSystemBuilder.build_vector_field(eqs, [x, y]) result.is_autonomous  # True (no explicit t dependence) True</p> Source code in <code>src/PyDynSys/core/sym_utils.py</code> <pre><code>@staticmethod\ndef build_vector_field(\n    equations: SymbolicODE,\n    variables: List[syp.Function],\n    parameters: SystemParameters = None\n) -&gt; SymbolicToVectorFieldResult:\n    \"\"\"\n    Convert symbolic ODE system to numerical vector field.\n\n    Auto-detects whether system is autonomous by checking if time `t` \n    appears in any derivative after solving for dx/dt.\n\n\n    Args:\n        equations (SymbolicODE): Symbolic system expressed as d(x_i)/dt - F_i(x, t), i=1,...,n\n            -&gt; SymbolicODE = Union[List[syp.Expr], syp.Expr, str, List[str]]\n            -&gt; str use is highly experimental and not recommended. \n        variables (List[syp.Function]): List of dependent variables as SymPy Function objects\n            -&gt; support for strings may be supported later, but not a pressing matter.\n        parameters (SystemParameters): Optional parameter substitution dict \n            -&gt; SystemParameters = Union[Dict[str, float], Dict[syp.Symbol, float]]\n\n\n    Returns:\n        SymbolicToVectorFieldResult wrapper, which itself contains:\n            - vector_field: Callable with appropriate signature\n            - dimension: Phase space dimension n\n            - is_autonomous: True &lt;==&gt;  partial(vector_field, t) = 0\n\n    Raises:\n        ValueError: If system is not first-order \n\n\n    Example:\n        &gt;&gt;&gt; t = syp.symbols('t')\n        &gt;&gt;&gt; x, y = syp.symbols('x y', cls=syp.Function)\n        &gt;&gt;&gt; x, y = x(t), y(t)\n        &gt;&gt;&gt; eqs = [syp.diff(x, t) - y, syp.diff(y, t) + x]\n        &gt;&gt;&gt; result = SymbolicSystemBuilder.build_vector_field(eqs, [x, y])\n        &gt;&gt;&gt; result.is_autonomous  # True (no explicit t dependence)\n        True\n    \"\"\"\n    # Parse symbolic input\n    parsed_equations = SymbolicSystemBuilder._parse_symbolic_input(equations)\n\n    # Validate first-order system\n    if not SymbolicSystemBuilder._is_first_order_system(parsed_equations, variables):\n        raise ValueError(\n            \"Only first-order systems are currently supported. \"\n            \"nth-order systems will be supported in future versions.\"\n        )\n\n    # Get dimension\n    dimension = len(variables)\n\n    # Solve for derivatives: d(x_i)/dt = F_i(x, t)\n    t_sym = syp.symbols('t')\n    derivatives = []\n    for i, equation in enumerate(parsed_equations):\n        derivative = syp.solve(equation, syp.diff(variables[i], t_sym))[0]\n        derivatives.append(derivative)\n\n    # Normalise parameters and substitute\n    normalised_parameters = SymbolicSystemBuilder._normalise_parameters(parameters)\n\n    # Convert Function objects to symbols for substitution\n    state_names = [var.func.__name__ for var in variables]\n    state_symbols = syp.symbols(' '.join(state_names))\n    if dimension == 1:\n        state_symbols = (state_symbols,)  # Ensure tuple\n\n    # Build function \u2192 symbol mapping\n    if dimension == 1:\n        function_to_symbol_map = {variables[0]: state_symbols[0]}\n    else:\n        function_to_symbol_map = {var: state_symbols[i] for i, var in enumerate(variables)}\n\n    # Apply all substitutions\n    all_substitutions = {**function_to_symbol_map, **normalised_parameters}\n    derivatives_substituted = [der.subs(all_substitutions) for der in derivatives]\n\n    # Detect autonomy\n    is_autonomous = SymbolicSystemBuilder._detect_autonomy(derivatives_substituted, t_sym)\n\n    # Build appropriate vector field\n    if is_autonomous:\n        vector_field = SymbolicSystemBuilder._build_autonomous_field(\n            derivatives_substituted, state_symbols, dimension\n        )\n    else:\n        vector_field = SymbolicSystemBuilder._build_nonautonomous_field(\n            derivatives_substituted, state_symbols, t_sym, dimension\n        )\n\n    return SymbolicToVectorFieldResult(\n        vector_field=vector_field,\n        dimension=dimension,\n        is_autonomous=is_autonomous\n    )\n</code></pre>"},{"location":"api/core/#PyDynSys.core.SymbolicToVectorFieldResult","title":"<code>SymbolicToVectorFieldResult</code>  <code>dataclass</code>","text":"<p>Result of converting symbolic ODE to numerical vector field.</p> <p>Encapsulates all information about the conversion process. Frozen to ensure immutability and hashability (if needed for caching).</p> Fields <p>vector_field: Callable vector field with appropriate signature on is_autonomous bool. dimension: dimension of the phase space (not as linear subspace), i.e. #state_components is_autonomous: True &lt;==&gt; partial(vector_field, t) == 0</p> Future Extensions <ul> <li>conversion_method: Details on nth \u2192 1st order reduction (when supported)</li> <li>symbolic_derivatives: Cached symbolic forms for Jacobian</li> <li>parameter_values: Substituted parameters for reference</li> </ul> Source code in <code>src/PyDynSys/core/sym_utils.py</code> <pre><code>@dataclass(frozen=True)\nclass SymbolicToVectorFieldResult:\n    \"\"\"\n    Result of converting symbolic ODE to numerical vector field.\n\n    Encapsulates all information about the conversion process. Frozen\n    to ensure immutability and hashability (if needed for caching).\n\n    Fields:\n        vector_field: Callable vector field with appropriate signature on is_autonomous bool.\n        dimension: dimension of the phase space (not as linear subspace), i.e. #state_components\n        is_autonomous: True &lt;==&gt; partial(vector_field, t) == 0\n\n    Future Extensions:\n        - conversion_method: Details on nth \u2192 1st order reduction (when supported)\n        - symbolic_derivatives: Cached symbolic forms for Jacobian\n        - parameter_values: Substituted parameters for reference\n    \"\"\"\n    vector_field: VectorField\n    dimension: int\n    is_autonomous: bool\n</code></pre>"},{"location":"api/core/#PyDynSys.core.TrajectoryCacheKey","title":"<code>TrajectoryCacheKey</code>  <code>dataclass</code>","text":"<p>Immutable cache key for trajectory solutions.</p>"},{"location":"api/core/#PyDynSys.core.TrajectoryCacheKey--design-rationale-why-this-key-structure","title":"DESIGN RATIONALE - Why This Key Structure:","text":"<p>Caches by initial conditions and evaluation domain, NOT by method. This allows retrieval regardless of solver used. Note: multi-method trajectories (segments solved with different methods) are valid.</p> <p>Why method is NOT in the cache key: - Removed to support multi-method trajectories (e.g., bidirectional integration   where backward uses RK45 and forward uses DOP853) - Same IVP solved with different methods should give similar results (modulo   numerical error), so caching without method is reasonable - Simplifies cache logic and enables trajectory composition</p> <p>Why initial_time IS in the cache key: - For autonomous systems (dx/dt = F(x)): initial_time doesn't affect trajectory   SHAPE in phase space, only the parameterization. However, we store it for   consistency and potential future time-shifted cache lookups. - For non-autonomous systems (dx/dt = F(x,t)): initial_time is CRITICAL!   The same initial state x_0 at different times evolves completely differently   due to time-dependent forcing. Example:     - System: dx/dt = -x + sin(t)     - x(0) = 1.0 at t_0=0: affected by sin(0)=0     - x(0) = 1.0 at t_0=\u03c0/2: affected by sin(\u03c0/2)=1   These produce entirely different trajectories despite same x_0!</p> <p>For autonomous systems: initial_time is conventionally t_span[0] For non-autonomous systems: initial_time matters and varies</p> Fields <p>initial_conditions: x(t_0) as hashable tuple initial_time: t_0 (critical for non-autonomous, stored for autonomous too) t_eval_tuple: Evaluation time points as hashable tuple</p> Future enhancements (smart caching): <ul> <li>Smart cache lookup: merge cached [0,2] + [1,5] to get requested [1,3]   (use EuclideanTrajectory.from_segments to compose cached segments)</li> <li>Cache slicing: slice cached [1,3] to get requested [1,2]   (extract subset of evaluation points from cached trajectory)</li> </ul> Source code in <code>src/PyDynSys/core/types.py</code> <pre><code>@dataclass(frozen=True)\nclass TrajectoryCacheKey:\n    \"\"\"\n    Immutable cache key for trajectory solutions.\n\n    DESIGN RATIONALE - Why This Key Structure:\n    ------------------------------------------\n    Caches by initial conditions and evaluation domain, NOT by method.\n    This allows retrieval regardless of solver used. Note: multi-method\n    trajectories (segments solved with different methods) are valid.\n\n    Why method is NOT in the cache key:\n    - Removed to support multi-method trajectories (e.g., bidirectional integration\n      where backward uses RK45 and forward uses DOP853)\n    - Same IVP solved with different methods should give similar results (modulo\n      numerical error), so caching without method is reasonable\n    - Simplifies cache logic and enables trajectory composition\n\n    Why initial_time IS in the cache key:\n    - For autonomous systems (dx/dt = F(x)): initial_time doesn't affect trajectory\n      SHAPE in phase space, only the parameterization. However, we store it for\n      consistency and potential future time-shifted cache lookups.\n    - For non-autonomous systems (dx/dt = F(x,t)): initial_time is CRITICAL!\n      The same initial state x_0 at different times evolves completely differently\n      due to time-dependent forcing. Example:\n        - System: dx/dt = -x + sin(t)\n        - x(0) = 1.0 at t_0=0: affected by sin(0)=0\n        - x(0) = 1.0 at t_0=\u03c0/2: affected by sin(\u03c0/2)=1\n      These produce entirely different trajectories despite same x_0!\n\n    For autonomous systems: initial_time is conventionally t_span[0]\n    For non-autonomous systems: initial_time matters and varies\n\n    Fields:\n        initial_conditions: x(t_0) as hashable tuple\n        initial_time: t_0 (critical for non-autonomous, stored for autonomous too)\n        t_eval_tuple: Evaluation time points as hashable tuple\n\n    TODO: Future enhancements (smart caching):\n        - Smart cache lookup: merge cached [0,2] + [1,5] to get requested [1,3]\n          (use EuclideanTrajectory.from_segments to compose cached segments)\n        - Cache slicing: slice cached [1,3] to get requested [1,2]\n          (extract subset of evaluation points from cached trajectory)\n    \"\"\"\n    # Frozen dataclass ensures immutability \u2192 hashable \u2192 usable as dict key\n    initial_conditions: Tuple[float, ...]\n    initial_time: float\n    t_eval_tuple: Tuple[float, ...]\n</code></pre>"},{"location":"api/vis/","title":"PyDynSys.vis Module","text":""},{"location":"api/vis/#full-docs","title":"Full Docs","text":""},{"location":"api/vis/#PyDynSys.vis","title":"<code>PyDynSys.vis</code>","text":"<p>Visualization utilities for PyDynSys.</p>"},{"location":"api/vis/#PyDynSys.vis.plot_phase_space","title":"<code>plot_phase_space(phase_space, xlim, ylim, resolution=200, ax=None, **kwargs)</code>","text":"<p>Visualize a PhaseSpace using its constraint function.</p> <p>This is a general entry point for PhaseSpace visualization. Currently only 2D phase spaces are supported via plot_planar_phase_space.</p> <p>Parameters:</p> Name Type Description Default <code>phase_space</code> <code>PhaseSpace</code> <p>The PhaseSpace to visualize</p> required <code>xlim</code> <code>Tuple[float, float]</code> <p>Tuple (x_min, x_max) for plot bounds</p> required <code>ylim</code> <code>Tuple[float, float]</code> <p>Tuple (y_min, y_max) for plot bounds</p> required <code>resolution</code> <code>int</code> <p>Number of grid points per dimension (default: 200)</p> <code>200</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib Axes to plot on. If None, creates a new figure</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to matplotlib's imshow function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>matplotlib.axes.Axes: The matplotlib Axes object containing the plot</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If phase_space.dimension != 2</p> Source code in <code>src/PyDynSys/vis/euclidean/phase_space.py</code> <pre><code>def plot_phase_space(\n    phase_space: PhaseSpace,\n    xlim: Tuple[float, float],\n    ylim: Tuple[float, float],\n    resolution: int = 200,\n    ax: Optional[Axes] = None,\n    **kwargs\n) -&gt; Axes:\n    \"\"\"\n    Visualize a PhaseSpace using its constraint function.\n\n    This is a general entry point for PhaseSpace visualization. Currently only\n    2D phase spaces are supported via plot_planar_phase_space.\n\n    Args:\n        phase_space (core.euclidean.PhaseSpace): The PhaseSpace to visualize\n        xlim (Tuple[float, float]): Tuple (x_min, x_max) for plot bounds\n        ylim (Tuple[float, float]): Tuple (y_min, y_max) for plot bounds\n        resolution (int): Number of grid points per dimension (default: 200)\n        ax (Optional[matplotlib.axes.Axes]): Optional matplotlib Axes to plot on. If None, creates a new figure\n        **kwargs (Any): Additional arguments passed to matplotlib's imshow function\n\n    Returns:\n        matplotlib.axes.Axes: The matplotlib Axes object containing the plot\n\n    Raises:\n        NotImplementedError: If phase_space.dimension != 2\n    \"\"\"\n    if phase_space.dimension == 2:\n        return plot_planar_phase_space(\n            phase_space=phase_space,\n            xlim=xlim,\n            ylim=ylim,\n            resolution=resolution,\n            ax=ax,\n            **kwargs\n        )\n    else:\n        raise NotImplementedError(\n            f\"plot_phase_space only supports 2D PhaseSpaces currently, \"\n            f\"got dimension {phase_space.dimension}. \"\n            f\"Support for dimensions != 2 is planned for future releases.\"\n        )\n</code></pre>"},{"location":"api/core/euclidean/","title":"Core.Euclidean Module","text":""},{"location":"api/core/euclidean/#overview","title":"Overview","text":"<p>The <code>PyDynSys.core.euclidean</code> module provides classes for working with Euclidean dynamical systems, trajectories, phase spaces, and time horizons.</p> <p>Let \\(X \\subseteq \\mathbb{R}^n\\) and \\(T \\subseteq \\mathbb{R}\\) be sets, let \\({\\bf F}: X \\times T \\to \\mathbb{R}^n\\) be a vector field, and suppose on \\(X \\times T\\) the first-order ODE \\(\\dot{{\\bf x}} = {\\bf F}({\\bf x}, t)\\) holds. This is the setting we work within. Formally, we define a Euclidean dynamical system by the tuple \\((X, T, {\\bf F})\\). As the notation suggests, \\({\\bf x}: T \\to \\mathbb{R}^n\\) is a function of time. </p> <p>There is an abstract base class <code>DynamicalSystem</code>, which all types of dynamical system inherit from. There are two top-level inheritors, which we expect almost all consumers to inherit from: <code>AutonomousDS</code> and <code>NonAutonomousDS</code>, corresponding to the cases where our Euclidean dynamical system is (or isn't) autonomous, i.e. whether \\(\\frac{\\partial {\\bf F}}{\\partial t} \\equiv 0\\). In the autonomous case, where this is true, we need not specify \\(T\\), and we opt to consider a vector field \\({\\bf F}: X \\to \\mathbb{R}^n\\). All non-autonomous systems can be trivially made autonomous, though in doing so we lose some topological structure. As such, we elect to support both autonomous systems and their non-autonomous cousins.  </p>"},{"location":"api/core/euclidean/#classes","title":"Classes","text":""},{"location":"api/core/euclidean/#dynamical-systems","title":"Dynamical Systems","text":""},{"location":"api/core/euclidean/#euclideands","title":"EuclideanDS","text":"<p>Abstract base class for Euclidean dynamical systems. Provides shared infrastructure for autonomous and non-autonomous systems, including solution caching, validation, and trajectory solving.</p>"},{"location":"api/core/euclidean/#autonomouseuclideands","title":"AutonomousEuclideanDS","text":"<p>Systems where dx/dt = F(x) with F: R^n -&gt; R^n independent of time. Suitable for time-invariant systems.</p>"},{"location":"api/core/euclidean/#nonautonomouseuclideands","title":"NonAutonomousEuclideanDS","text":"<p>Systems where dx/dt = F(x, t) with F: R^n \u00d7 R -&gt; R^n dependent on time. Suitable for time-varying systems.</p>"},{"location":"api/core/euclidean/#trajectory-types","title":"Trajectory Types","text":""},{"location":"api/core/euclidean/#euclideantrajectorysegment","title":"EuclideanTrajectorySegment","text":"<p>Represents a single continuous trajectory segment from a numerical integration solve.</p>"},{"location":"api/core/euclidean/#euclideantrajectory","title":"EuclideanTrajectory","text":"<p>Composed trajectory that can span multiple segments, supporting bidirectional integration and trajectory composition.</p>"},{"location":"api/core/euclidean/#phase-space-and-time","title":"Phase Space and Time","text":""},{"location":"api/core/euclidean/#phasespace","title":"PhaseSpace","text":"<p>Phase space representation with flexible symbolic and callable constraints. Supports various factory methods for common geometric shapes (boxes, hyperspheres) and custom constraints.</p>"},{"location":"api/core/euclidean/#timehorizon","title":"TimeHorizon","text":"<p>Time domain representation for dynamical systems, supporting real line, intervals, and custom time domains.</p>"},{"location":"api/core/euclidean/#full-docs","title":"Full Docs","text":""},{"location":"api/core/euclidean/#PyDynSys.core.euclidean","title":"<code>PyDynSys.core.euclidean</code>","text":"<p>Euclidean dynamical systems module.</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.AutonomousEuclideanDS","title":"<code>AutonomousEuclideanDS</code>","text":"<p>               Bases: <code>EuclideanDS</code></p> <p>Autonomous Euclidean dynamical system.</p> <p>Systems where dx/dt = F(x) with F: R^n -&gt; R^n independent of time. Equivalently, Partial(df, dt) = 0. </p> Example Source code in <code>src/PyDynSys/core/euclidean/autonomous.py</code> <pre><code>class AutonomousEuclideanDS(EuclideanDS):\n    \"\"\"\n    Autonomous Euclidean dynamical system.\n\n    Systems where dx/dt = F(x) with F: R^n -&gt; R^n independent of time.\n    Equivalently, Partial(df, dt) = 0. \n\n    Example:\n        &gt;&gt;&gt; # Harmonic oscillator: x'' + x = 0 \u2192 (x, y)' = (y, -x)\n        &gt;&gt;&gt; def harmonic_oscillator(x):\n        ...     return np.array([x[1], -x[0]])\n        &gt;&gt;&gt; phase_space = PhaseSpace.euclidean(2)\n        &gt;&gt;&gt; sys = AutonomousEuclideanDS(\n        ...     dimension=2, \n        ...     vector_field=harmonic_oscillator,\n        ...     phase_space=phase_space\n        ... )\n    \"\"\"\n\n\n        ### --- Constructor --- ###\n\n\n    def __init__(\n        self, \n        dimension: int, \n        vector_field: AutonomousVectorField,\n        phase_space: PhaseSpace = None\n    ):\n        \"\"\"\n        Initialize autonomous system.\n\n        Args:\n            dimension (int): Phase space dimension n\n            vector_field: Function F(x) -&gt; dx/dt mapping R^n -&gt; R^n\n            phase_space: Phase space X subset R^n (defaults to X = R^n)\n\n        Raises:\n            ValueError: If dimension &lt;= 0 or phase_space dimension mismatch\n        \"\"\"\n        # Enforce default: X = R^n with symbolic representation\n        if phase_space is None:\n            phase_space = PhaseSpace.euclidean(dimension)\n\n        super().__init__(dimension, phase_space)\n        self._vector_field = vector_field\n        # NOTE: Could validate vector_field signature here via inspect\n\n\n        ### --- EuclideanDS Method Impls --- ###\n\n\n    @property\n    def vector_field(self) -&gt; AutonomousVectorField:\n        \"\"\"\n        Vector field defining the dynamical system.\n        \"\"\"\n        return self._vector_field\n\n\n    def trajectory(\n        self,\n        initial_state: NDArray[np.float64],\n        t_span: Tuple[float, float],\n        t_eval: NDArray[np.float64],\n        method: str = 'RK45',\n        dense_output: bool = True\n    ) -&gt; EuclideanTrajectory:\n        \"\"\"\n        Solve initial value problem: dx/dt = F(x), x(t_0) = x_0 over interval I.\n\n        Supports bidirectional integration: if t_span = (t_0, t_end) where \n        t_0 is interior to the t_eval range, performs:\n        - Backward integration: t_0 \u2192 min(t_eval)\n        - Forward integration: t_0 \u2192 max(t_eval)\n        Then concatenates results.\n\n        Args:\n            initial_state: Initial condition x(t_0) \u2208 R^n\n            t_span: Effective integration bounds (t_start, t_end)\n            t_eval: Evaluation points (may span both sides of an interior t_0)\n            method: ODE solver (default 'RK45' = 5th order Runge-Kutta w/ adaptive step size)\n            dense_output: If True, returns continuous interpolant sol(t)\n                -&gt; NOTE: I am yet to see a use case where not true is useful, and it comes \n                at a minimal computational cost.\n\n        Returns:\n            EuclideanTrajectory: Trajectory object with attributes:\n                - t: Evaluation times (property, concatenated from segments)\n                - y: States at each time (property, concatenated from segments)\n                - segments: List of trajectory segments\n                - interpolate(t): Method for continuous evaluation at time t\n                - domains: List of domain intervals for each segment\n\n        Raises:\n            ValueError: If state dimension incorrect, t_span invalid, \n                       or t_eval points outside valid range\n\n        Implementation Notes:\n            - Solutions cached by (initial_state, t_span, t_eval, method)\n            - Integrator uses \u03bb(t, x): self.vector_field(x) (ignores t)\n            - Bidirectional: if t_0 interior to [min(t_eval), max(t_eval)]\n            - No existence/uniqueness checks performed (TODO: future)\n        \"\"\"\n        # Validation\n        self._validate_state(initial_state)\n        self._validate_time_span(t_span)\n        self._validate_t_eval(t_eval, t_span)\n\n        # ====================================================================\n        # CACHING STRATEGY\n        # ====================================================================\n        # Check cache (removed method field - trajectories can be multi-method)\n        # \n        # Cache key includes: (x_0, t_0, t_eval) but NOT method\n        # This allows cache hits even with different methods, which is reasonable because:\n        #   1. Different methods solve the same IVP (should give similar results)\n        #   2. Multi-method trajectories are valid (bidirectional with different methods)\n        #   3. Simpler cache logic (no need to track method combinations)\n        #\n        # For autonomous systems, t_0 doesn't affect trajectory shape (time-translation\n        # invariant), but we store it for consistency with non-autonomous systems and\n        # potential future optimizations (e.g., recognizing time-shifted duplicates).\n        cache_key = TrajectoryCacheKey(\n            initial_conditions=tuple(initial_state),\n            initial_time=t_span[0],  # Store t_0 (typically 0 for autonomous, but can vary)\n            t_eval_tuple=tuple(t_eval)\n        )\n\n        # Cache hit: Return previously computed trajectory (may have been computed with different method!)\n        if cache_key in self._solutions_cache:\n            return self._solutions_cache[cache_key]\n\n        # ====================================================================\n        # BIDIRECTIONAL INTEGRATION DETECTION\n        # ====================================================================\n        # Determine if bidirectional integration needed\n        # \n        # Standard (unidirectional) integration: t_0 at boundary of t_eval range\n        #   Example: t_0=0, t_eval=[0, 0.1, 0.2, ..., 10]\n        #   Flow computed in ONE direction: forward from t_0 to max(t_eval)\n        #\n        # Bidirectional integration: t_0 INTERIOR to t_eval range\n        #   Example: t_0=0, t_eval=[-5, -4, ..., -0.1, 0, 0.1, ..., 4, 5]\n        #   Flow computed in TWO directions: \n        #     - Backward from t_0 to min(t_eval)\n        #     - Forward from t_0 to max(t_eval)\n        #   This is useful for studying orbits, limit cycles, and phase portraits\n        #   where we want to see the trajectory evolve both forward and backward in time\n        #\n        # NOTE: scipy.solve_ivp does NOT support bidirectional integration natively,\n        # so we manually split into two IVPs and merge the resulting segments.\n\n        t_0 = t_span[0]  # Assume first element is initial time\n        t_min, t_max = np.min(t_eval), np.max(t_eval)\n\n        # Check if we need backward integration (t_0 above minimum)\n        needs_backward = t_0 &gt; t_min\n        # Check if we need forward integration (t_0 below maximum)\n        needs_forward = t_0 &lt; t_max\n\n        if needs_backward and needs_forward:\n            # BIDIRECTIONAL CASE: t_0 is interior to [t_min, t_max]\n            # Bidirectional case: integrate backwards and forwards\n            # Create two segments and let Trajectory handle tangent domain at t_0\n            # \n            # DESIGN DECISION: Why not manually concatenate like before?\n            # ----------------------------------------------------------\n            # Old approach (removed): Manually concatenate t and y arrays, return single\n            #   SciPyIvpSolution with sol=None (no interpolant possible)\n            # \n            # New approach: Create two segments, let EuclideanTrajectory.from_segments()\n            #   handle merging. Benefits:\n            #   1. Preserves BOTH interpolants (one for each segment)\n            #   2. Allows seamless interpolation via trajectory.interpolate(t) dispatch\n            #   3. Consistent with manual trajectory composition workflow\n            #   4. Cleaner separation of concerns (merging logic in one place)\n            sol_backward_raw, sol_forward_raw = self._solve_bidirectional_raw(\n                initial_state, t_0, t_eval, method, dense_output\n            )\n\n            # Wrap raw scipy solutions in segments\n            # Each segment preserves its interpolant if dense_output=True\n            seg_backward = EuclideanTrajectorySegment.from_scipy_solution(\n                SciPyIvpSolution(raw_solution=sol_backward_raw),\n                method=method\n            )\n            seg_forward = EuclideanTrajectorySegment.from_scipy_solution(\n                SciPyIvpSolution(raw_solution=sol_forward_raw),\n                method=method\n            )\n\n            # Merge via trajectory (handles tangent domain automatically)\n            # The segments share t_0 \u2192 average merge policy merges the shared point\n            # Result: Single trajectory with 2 segments, tangent at t_0\n            trajectory = EuclideanTrajectory.from_segments([seg_backward, seg_forward])\n        else:\n            # UNIDIRECTIONAL CASE: Standard forward or backward integration\n            # t_0 is at boundary of t_eval range (not interior)\n            # \n            # Even though this is a single scipy solve_ivp call, we STILL wrap it\n            # in EuclideanTrajectory (with one segment) for API consistency.\n            # \n            # WHY? Uniform return type simplifies user code:\n            #   result = sys.trajectory(...)  # Always get EuclideanTrajectory\n            #   result.interpolate(t)          # Always works the same way\n            #   result.segments                # Always accessible (just 1 segment here)\n            # \n            # User doesn't need to check \"is this bidirectional or unidirectional?\"\n            solution_raw = solve_ivp(\n                fun=lambda t, y: self.vector_field(y),  # Ignore time parameter (autonomous)\n                t_span=t_span,\n                y0=initial_state,\n                t_eval=t_eval,\n                method=method,\n                dense_output=dense_output\n            )\n\n            # Wrap scipy solution in segment, then wrap segment in trajectory\n            # Result: EuclideanTrajectory with 1 segment\n            segment = EuclideanTrajectorySegment.from_scipy_solution(\n                SciPyIvpSolution(raw_solution=solution_raw),\n                method=method\n            )\n            trajectory = EuclideanTrajectory.from_segments([segment])\n\n        # Cache and return\n        self._solutions_cache[cache_key] = trajectory\n        return trajectory\n\n\n        ### --- Public Methods --- ###\n\n\n    def evolve(\n        self,\n        initial_state: NDArray[np.float64],\n        t0: float,\n        dt: float,\n        method: str = 'RK45'\n    ) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Single time-step evolution: estimate x(t_0 + dt) from x(t_0).\n\n        Convenience wrapper for rapid single-step integration without caching.\n        For repeated evaluations or bidirectional integration, use trajectory().\n\n        Args:\n            initial_state: State at time t_0\n            t0: Initial time\n            dt: Time step (must be positive)\n            method: ODE solver\n\n        Returns:\n            NDArray[np.float64]: Estimated state at t_0 + dt\n\n        Raises:\n            ValueError: If state dimension incorrect or dt \u2264 0\n\n        NOTE: For backwards evolution or flow on intervals around t_0,\n        use trajectory() instead which supports bidirectional integration.\n        \"\"\"\n        self._validate_state(initial_state)\n        self._validate_time_step(dt)\n\n        # Single-step integration without caching\n        result = solve_ivp(\n            fun=lambda t, y: self.vector_field(y),\n            t_span=(t0, t0 + dt),\n            y0=initial_state,\n            t_eval=[t0 + dt],\n            method=method,\n            dense_output=False  # No interpolant needed\n        )\n\n        return result.y[:, 0]  # Extract final state vector\n\n        ### --- Private Methods --- ###\n\n\n    def _solve_bidirectional_raw(\n        self,\n        initial_state: NDArray[np.float64],\n        t_0: float,\n        t_eval: NDArray[np.float64],\n        method: str,\n        dense_output: bool\n    ) -&gt; Tuple[Any, Any]:\n        \"\"\"\n        Perform bidirectional integration: backward from t_0, forward from t_0.\n\n        Returns raw scipy OdeResult objects from both integrations, without\n        concatenation. Concatenation is handled by EuclideanTrajectory.from_segments().\n\n        This handles the case where flow is desired on an open interval I around\n        t_0, e.g., I = (-1, 1) with t_0 = 0.\n\n        Args:\n            initial_state: x(t_0)\n            t_0: Initial time (interior to t_eval range)\n            t_eval: Full evaluation array\n            method: Solver method\n            dense_output: Whether to generate interpolant for each segment\n\n        Returns:\n            Tuple[Any, Any]: (sol_backward, sol_forward) raw scipy OdeResult objects\n\n        NOTE: Each segment can have dense_output if requested. The trajectory\n        will handle dispatching interpolation to the correct segment.\n        \"\"\"\n        # ====================================================================\n        # SPLIT EVALUATION ARRAY FOR BIDIRECTIONAL INTEGRATION\n        # ====================================================================\n        # Split t_eval into backward and forward portions around t_0\n        # \n        # Key insight: We need BOTH segments to include t_0 to ensure they are TANGENT\n        # (i.e., they share the boundary point) with no gap in the trajectory domain.\n        #\n        # Without this fix, we had a gap:\n        #   Backward: [..., -0.01, -0.005]  (ends NEAR t_0 but not AT t_0)\n        #   Forward:  [0.005, 0.01, ...]    (starts NEAR t_0 but not AT t_0)\n        #   Gap: (-0.005, 0.005) where interpolation fails!\n        #\n        # With this fix, segments are tangent:\n        #   Backward: [..., -0.01, -0.005, 0.0]  (ends AT t_0)\n        #   Forward:  [0.0, 0.005, 0.01, ...]    (starts AT t_0)\n        #   No gap: domains touch at t_0\n\n        t_eval_backward = t_eval[t_eval &lt; t_0]   # Points strictly before t_0\n        t_eval_forward = t_eval[t_eval &gt;= t_0]   # Points at or after t_0\n\n        # ====================================================================\n        # BACKWARD INTEGRATION: t_0 \u2192 min(t_eval)\n        # ====================================================================\n        # Include t_0 in backward to ensure tangent domain with forward segment\n        # This is CRITICAL for avoiding gaps in the trajectory domain\n        if len(t_eval_backward) &gt; 0:\n            # Append t_0 to backward evaluation points\n            # This ensures backward segment ends exactly at t_0\n            t_eval_backward_with_t0 = np.append(t_eval_backward, t_0)\n            sol_backward = solve_ivp(\n                fun=lambda t, y: self.vector_field(y),\n                t_span=(t_0, t_eval_backward[0]),  # t_0 to minimum\n                y0=initial_state,\n                t_eval=t_eval_backward_with_t0[::-1],  # Reverse for increasing order\n                method=method,\n                dense_output=dense_output  # Allow dense output for segment\n            )\n        else:\n            sol_backward = None\n\n        # ====================================================================\n        # FORWARD INTEGRATION: t_0 \u2192 max(t_eval)\n        # ====================================================================\n        # Ensure t_0 is at the start to guarantee tangent domain\n        # \n        # Edge case: When t_eval = linspace(a, b, n), t_0 may or may not be\n        # exactly in the array due to floating-point spacing.\n        #\n        # Example problematic case:\n        #   t_eval = linspace(-2, 2, 400) might give:\n        #   [..., -0.005, 0.005, ...] where 0.0 is MISSING!\n        #   \n        # Even if we filter t_eval[t_eval &gt;= t_0], we might get:\n        #   t_eval_forward = [0.005, 0.01, ...] missing the exact t_0=0.0\n        #\n        # Solution: Explicitly prepend t_0 if not already present (within tolerance)\n        if len(t_eval_forward) &gt; 0:\n            # Check if t_0 is already the first point (within floating-point tolerance)\n            # Using 1e-10 tolerance to handle numerical precision issues\n            if abs(t_eval_forward[0] - t_0) &gt; 1e-10:\n                # t_0 is NOT in t_eval_forward, prepend it explicitly\n                # This ensures forward segment starts exactly at t_0\n                t_eval_forward_with_t0 = np.concatenate([[t_0], t_eval_forward])\n            else:\n                # t_0 is already present, no modification needed\n                t_eval_forward_with_t0 = t_eval_forward\n\n            sol_forward = solve_ivp(\n                fun=lambda t, y: self.vector_field(y),\n                t_span=(t_0, t_eval_forward[-1]),  # t_0 to maximum\n                y0=initial_state,\n                t_eval=t_eval_forward_with_t0,\n                method=method,\n                dense_output=dense_output  # Allow dense output for segment\n            )\n        else:\n            sol_forward = None\n\n        # Return raw solutions (let Trajectory handle merging)\n        return sol_backward, sol_forward\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.AutonomousEuclideanDS--harmonic-oscillator-x-x-0-x-y-y-x","title":"Harmonic oscillator: x'' + x = 0 \u2192 (x, y)' = (y, -x)","text":"<p>def harmonic_oscillator(x): ...     return np.array([x[1], -x[0]]) phase_space = PhaseSpace.euclidean(2) sys = AutonomousEuclideanDS( ...     dimension=2,  ...     vector_field=harmonic_oscillator, ...     phase_space=phase_space ... )</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.AutonomousEuclideanDS.vector_field","title":"<code>vector_field</code>  <code>property</code>","text":"<p>Vector field defining the dynamical system.</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.AutonomousEuclideanDS.__init__","title":"<code>__init__(dimension, vector_field, phase_space=None)</code>","text":"<p>Initialize autonomous system.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>Phase space dimension n</p> required <code>vector_field</code> <code>AutonomousVectorField</code> <p>Function F(x) -&gt; dx/dt mapping R^n -&gt; R^n</p> required <code>phase_space</code> <code>PhaseSpace</code> <p>Phase space X subset R^n (defaults to X = R^n)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimension &lt;= 0 or phase_space dimension mismatch</p> Source code in <code>src/PyDynSys/core/euclidean/autonomous.py</code> <pre><code>def __init__(\n    self, \n    dimension: int, \n    vector_field: AutonomousVectorField,\n    phase_space: PhaseSpace = None\n):\n    \"\"\"\n    Initialize autonomous system.\n\n    Args:\n        dimension (int): Phase space dimension n\n        vector_field: Function F(x) -&gt; dx/dt mapping R^n -&gt; R^n\n        phase_space: Phase space X subset R^n (defaults to X = R^n)\n\n    Raises:\n        ValueError: If dimension &lt;= 0 or phase_space dimension mismatch\n    \"\"\"\n    # Enforce default: X = R^n with symbolic representation\n    if phase_space is None:\n        phase_space = PhaseSpace.euclidean(dimension)\n\n    super().__init__(dimension, phase_space)\n    self._vector_field = vector_field\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.AutonomousEuclideanDS.evolve","title":"<code>evolve(initial_state, t0, dt, method='RK45')</code>","text":"<p>Single time-step evolution: estimate x(t_0 + dt) from x(t_0).</p> <p>Convenience wrapper for rapid single-step integration without caching. For repeated evaluations or bidirectional integration, use trajectory().</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>NDArray[float64]</code> <p>State at time t_0</p> required <code>t0</code> <code>float</code> <p>Initial time</p> required <code>dt</code> <code>float</code> <p>Time step (must be positive)</p> required <code>method</code> <code>str</code> <p>ODE solver</p> <code>'RK45'</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Estimated state at t_0 + dt</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If state dimension incorrect or dt \u2264 0</p> <p>NOTE: For backwards evolution or flow on intervals around t_0, use trajectory() instead which supports bidirectional integration.</p> Source code in <code>src/PyDynSys/core/euclidean/autonomous.py</code> <pre><code>def evolve(\n    self,\n    initial_state: NDArray[np.float64],\n    t0: float,\n    dt: float,\n    method: str = 'RK45'\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Single time-step evolution: estimate x(t_0 + dt) from x(t_0).\n\n    Convenience wrapper for rapid single-step integration without caching.\n    For repeated evaluations or bidirectional integration, use trajectory().\n\n    Args:\n        initial_state: State at time t_0\n        t0: Initial time\n        dt: Time step (must be positive)\n        method: ODE solver\n\n    Returns:\n        NDArray[np.float64]: Estimated state at t_0 + dt\n\n    Raises:\n        ValueError: If state dimension incorrect or dt \u2264 0\n\n    NOTE: For backwards evolution or flow on intervals around t_0,\n    use trajectory() instead which supports bidirectional integration.\n    \"\"\"\n    self._validate_state(initial_state)\n    self._validate_time_step(dt)\n\n    # Single-step integration without caching\n    result = solve_ivp(\n        fun=lambda t, y: self.vector_field(y),\n        t_span=(t0, t0 + dt),\n        y0=initial_state,\n        t_eval=[t0 + dt],\n        method=method,\n        dense_output=False  # No interpolant needed\n    )\n\n    return result.y[:, 0]  # Extract final state vector\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.AutonomousEuclideanDS.trajectory","title":"<code>trajectory(initial_state, t_span, t_eval, method='RK45', dense_output=True)</code>","text":"<p>Solve initial value problem: dx/dt = F(x), x(t_0) = x_0 over interval I.</p> <p>Supports bidirectional integration: if t_span = (t_0, t_end) where  t_0 is interior to the t_eval range, performs: - Backward integration: t_0 \u2192 min(t_eval) - Forward integration: t_0 \u2192 max(t_eval) Then concatenates results.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>NDArray[float64]</code> <p>Initial condition x(t_0) \u2208 R^n</p> required <code>t_span</code> <code>Tuple[float, float]</code> <p>Effective integration bounds (t_start, t_end)</p> required <code>t_eval</code> <code>NDArray[float64]</code> <p>Evaluation points (may span both sides of an interior t_0)</p> required <code>method</code> <code>str</code> <p>ODE solver (default 'RK45' = 5th order Runge-Kutta w/ adaptive step size)</p> <code>'RK45'</code> <code>dense_output</code> <code>bool</code> <p>If True, returns continuous interpolant sol(t) -&gt; NOTE: I am yet to see a use case where not true is useful, and it comes  at a minimal computational cost.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>EuclideanTrajectory</code> <code>EuclideanTrajectory</code> <p>Trajectory object with attributes: - t: Evaluation times (property, concatenated from segments) - y: States at each time (property, concatenated from segments) - segments: List of trajectory segments - interpolate(t): Method for continuous evaluation at time t - domains: List of domain intervals for each segment</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If state dimension incorrect, t_span invalid,         or t_eval points outside valid range</p> Implementation Notes <ul> <li>Solutions cached by (initial_state, t_span, t_eval, method)</li> <li>Integrator uses \u03bb(t, x): self.vector_field(x) (ignores t)</li> <li>Bidirectional: if t_0 interior to [min(t_eval), max(t_eval)]</li> <li>No existence/uniqueness checks performed (TODO: future)</li> </ul> Source code in <code>src/PyDynSys/core/euclidean/autonomous.py</code> <pre><code>def trajectory(\n    self,\n    initial_state: NDArray[np.float64],\n    t_span: Tuple[float, float],\n    t_eval: NDArray[np.float64],\n    method: str = 'RK45',\n    dense_output: bool = True\n) -&gt; EuclideanTrajectory:\n    \"\"\"\n    Solve initial value problem: dx/dt = F(x), x(t_0) = x_0 over interval I.\n\n    Supports bidirectional integration: if t_span = (t_0, t_end) where \n    t_0 is interior to the t_eval range, performs:\n    - Backward integration: t_0 \u2192 min(t_eval)\n    - Forward integration: t_0 \u2192 max(t_eval)\n    Then concatenates results.\n\n    Args:\n        initial_state: Initial condition x(t_0) \u2208 R^n\n        t_span: Effective integration bounds (t_start, t_end)\n        t_eval: Evaluation points (may span both sides of an interior t_0)\n        method: ODE solver (default 'RK45' = 5th order Runge-Kutta w/ adaptive step size)\n        dense_output: If True, returns continuous interpolant sol(t)\n            -&gt; NOTE: I am yet to see a use case where not true is useful, and it comes \n            at a minimal computational cost.\n\n    Returns:\n        EuclideanTrajectory: Trajectory object with attributes:\n            - t: Evaluation times (property, concatenated from segments)\n            - y: States at each time (property, concatenated from segments)\n            - segments: List of trajectory segments\n            - interpolate(t): Method for continuous evaluation at time t\n            - domains: List of domain intervals for each segment\n\n    Raises:\n        ValueError: If state dimension incorrect, t_span invalid, \n                   or t_eval points outside valid range\n\n    Implementation Notes:\n        - Solutions cached by (initial_state, t_span, t_eval, method)\n        - Integrator uses \u03bb(t, x): self.vector_field(x) (ignores t)\n        - Bidirectional: if t_0 interior to [min(t_eval), max(t_eval)]\n        - No existence/uniqueness checks performed (TODO: future)\n    \"\"\"\n    # Validation\n    self._validate_state(initial_state)\n    self._validate_time_span(t_span)\n    self._validate_t_eval(t_eval, t_span)\n\n    # ====================================================================\n    # CACHING STRATEGY\n    # ====================================================================\n    # Check cache (removed method field - trajectories can be multi-method)\n    # \n    # Cache key includes: (x_0, t_0, t_eval) but NOT method\n    # This allows cache hits even with different methods, which is reasonable because:\n    #   1. Different methods solve the same IVP (should give similar results)\n    #   2. Multi-method trajectories are valid (bidirectional with different methods)\n    #   3. Simpler cache logic (no need to track method combinations)\n    #\n    # For autonomous systems, t_0 doesn't affect trajectory shape (time-translation\n    # invariant), but we store it for consistency with non-autonomous systems and\n    # potential future optimizations (e.g., recognizing time-shifted duplicates).\n    cache_key = TrajectoryCacheKey(\n        initial_conditions=tuple(initial_state),\n        initial_time=t_span[0],  # Store t_0 (typically 0 for autonomous, but can vary)\n        t_eval_tuple=tuple(t_eval)\n    )\n\n    # Cache hit: Return previously computed trajectory (may have been computed with different method!)\n    if cache_key in self._solutions_cache:\n        return self._solutions_cache[cache_key]\n\n    # ====================================================================\n    # BIDIRECTIONAL INTEGRATION DETECTION\n    # ====================================================================\n    # Determine if bidirectional integration needed\n    # \n    # Standard (unidirectional) integration: t_0 at boundary of t_eval range\n    #   Example: t_0=0, t_eval=[0, 0.1, 0.2, ..., 10]\n    #   Flow computed in ONE direction: forward from t_0 to max(t_eval)\n    #\n    # Bidirectional integration: t_0 INTERIOR to t_eval range\n    #   Example: t_0=0, t_eval=[-5, -4, ..., -0.1, 0, 0.1, ..., 4, 5]\n    #   Flow computed in TWO directions: \n    #     - Backward from t_0 to min(t_eval)\n    #     - Forward from t_0 to max(t_eval)\n    #   This is useful for studying orbits, limit cycles, and phase portraits\n    #   where we want to see the trajectory evolve both forward and backward in time\n    #\n    # NOTE: scipy.solve_ivp does NOT support bidirectional integration natively,\n    # so we manually split into two IVPs and merge the resulting segments.\n\n    t_0 = t_span[0]  # Assume first element is initial time\n    t_min, t_max = np.min(t_eval), np.max(t_eval)\n\n    # Check if we need backward integration (t_0 above minimum)\n    needs_backward = t_0 &gt; t_min\n    # Check if we need forward integration (t_0 below maximum)\n    needs_forward = t_0 &lt; t_max\n\n    if needs_backward and needs_forward:\n        # BIDIRECTIONAL CASE: t_0 is interior to [t_min, t_max]\n        # Bidirectional case: integrate backwards and forwards\n        # Create two segments and let Trajectory handle tangent domain at t_0\n        # \n        # DESIGN DECISION: Why not manually concatenate like before?\n        # ----------------------------------------------------------\n        # Old approach (removed): Manually concatenate t and y arrays, return single\n        #   SciPyIvpSolution with sol=None (no interpolant possible)\n        # \n        # New approach: Create two segments, let EuclideanTrajectory.from_segments()\n        #   handle merging. Benefits:\n        #   1. Preserves BOTH interpolants (one for each segment)\n        #   2. Allows seamless interpolation via trajectory.interpolate(t) dispatch\n        #   3. Consistent with manual trajectory composition workflow\n        #   4. Cleaner separation of concerns (merging logic in one place)\n        sol_backward_raw, sol_forward_raw = self._solve_bidirectional_raw(\n            initial_state, t_0, t_eval, method, dense_output\n        )\n\n        # Wrap raw scipy solutions in segments\n        # Each segment preserves its interpolant if dense_output=True\n        seg_backward = EuclideanTrajectorySegment.from_scipy_solution(\n            SciPyIvpSolution(raw_solution=sol_backward_raw),\n            method=method\n        )\n        seg_forward = EuclideanTrajectorySegment.from_scipy_solution(\n            SciPyIvpSolution(raw_solution=sol_forward_raw),\n            method=method\n        )\n\n        # Merge via trajectory (handles tangent domain automatically)\n        # The segments share t_0 \u2192 average merge policy merges the shared point\n        # Result: Single trajectory with 2 segments, tangent at t_0\n        trajectory = EuclideanTrajectory.from_segments([seg_backward, seg_forward])\n    else:\n        # UNIDIRECTIONAL CASE: Standard forward or backward integration\n        # t_0 is at boundary of t_eval range (not interior)\n        # \n        # Even though this is a single scipy solve_ivp call, we STILL wrap it\n        # in EuclideanTrajectory (with one segment) for API consistency.\n        # \n        # WHY? Uniform return type simplifies user code:\n        #   result = sys.trajectory(...)  # Always get EuclideanTrajectory\n        #   result.interpolate(t)          # Always works the same way\n        #   result.segments                # Always accessible (just 1 segment here)\n        # \n        # User doesn't need to check \"is this bidirectional or unidirectional?\"\n        solution_raw = solve_ivp(\n            fun=lambda t, y: self.vector_field(y),  # Ignore time parameter (autonomous)\n            t_span=t_span,\n            y0=initial_state,\n            t_eval=t_eval,\n            method=method,\n            dense_output=dense_output\n        )\n\n        # Wrap scipy solution in segment, then wrap segment in trajectory\n        # Result: EuclideanTrajectory with 1 segment\n        segment = EuclideanTrajectorySegment.from_scipy_solution(\n            SciPyIvpSolution(raw_solution=solution_raw),\n            method=method\n        )\n        trajectory = EuclideanTrajectory.from_segments([segment])\n\n    # Cache and return\n    self._solutions_cache[cache_key] = trajectory\n    return trajectory\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.EuclideanDS","title":"<code>EuclideanDS</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for Euclidean dynamical systems.</p> <p>Represents systems of first-order ODEs in R^n of form:     dx/dt = F(x)       (autonomous)     dx/dt = F(x, t)    (non-autonomous)</p> <p>Provides: - Shared infrastructure (dimension, solution caching, validation) - Abstract interface (subclasses must implement vector_field) - Factory method (from_symbolic auto-detects system type) - Common utilities (distance, volume, trajectory solving)</p> <p>NOTE: This class is abstract. Instantiate AutonomousEuclideanDS or NonAutonomousEuclideanDS directly, or use from_symbolic factory.</p> Source code in <code>src/PyDynSys/core/euclidean/base.py</code> <pre><code>class EuclideanDS(ABC):\n    \"\"\"\n    Abstract base class for Euclidean dynamical systems.\n\n    Represents systems of first-order ODEs in R^n of form:\n        dx/dt = F(x)       (autonomous)\n        dx/dt = F(x, t)    (non-autonomous)\n\n    Provides:\n    - Shared infrastructure (dimension, solution caching, validation)\n    - Abstract interface (subclasses must implement vector_field)\n    - Factory method (from_symbolic auto-detects system type)\n    - Common utilities (distance, volume, trajectory solving)\n\n    NOTE: This class is abstract. Instantiate AutonomousEuclideanDS or\n    NonAutonomousEuclideanDS directly, or use from_symbolic factory.\n    \"\"\"\n\n    def __init__(self, dimension: int, phase_space: PhaseSpace):\n        \"\"\"\n        Initialize Euclidean dynamical system.\n\n        Args:\n            dimension (int): Phase space dimension n (must be positive integer)\n                -&gt; Not a dimension in the linear subspace sense of the term, just #state_components                \n            phase_space (PhaseSpace): Phase space X subset of R^n\n\n        Raises:\n            ValueError: If dimension \u2264 0 or phase_space dimension mismatch\n\n        NOTE: This constructor is NEVER called directly by users (abstract class).\n        It's invoked via super().__init__() from subclasses.\n        \"\"\"\n        # Validation\n        if dimension &lt;= 0:\n            raise ValueError(f\"Phase space dimension must be positive, got {dimension}\")\n        if phase_space.dimension != dimension:\n            raise ValueError(\n                f\"Phase space dimension ({phase_space.dimension}) must match \"\n                f\"system dimension ({dimension})\"\n            )\n\n        self.dimension = dimension\n        self.phase_space = phase_space\n        # Cache now stores EuclideanTrajectory objects, will be updated in subclasses\n        self._solutions_cache: Dict[TrajectoryCacheKey, Any] = {}\n\n\n    # ========================================================================\n    # Factory Method - Auto-detects Autonomous vs Non-Autonomous\n    # ========================================================================\n\n    @classmethod\n    def from_symbolic(\n        cls,\n        equations: SymbolicODE,\n        variables: List[syp.Function],\n        parameters: SystemParameters = None,\n        phase_space: PhaseSpace = None,\n        time_horizon: TimeHorizon = None\n    ) -&gt; 'EuclideanDS':\n        \"\"\"\n        Factory method: construct system instance from symbolic equations.\n\n        Auto-detects whether system is autonomous and returns appropriate\n        subclass instance (AutonomousEuclideanDS or NonAutonomousEuclideanDS).\n\n        Args:\n            equations: Symbolic ODE in form [d(x_i)/dt - F_i(x, t), ...]\n            variables: Dependent variables as SymPy Function objects\n            parameters: Optional parameter substitution dict\n            phase_space: Phase space X subset R^n (defaults to X = R^n)\n            time_horizon: Time horizon T subset R (only used for non-autonomous, defaults to T = R)\n\n        Returns:\n            AutonomousEuclideanDS if partial(F, t) = 0, else NonAutonomousEuclideanDS\n\n        Raises:\n            ValueError: If system is not first-order\n\n        Example:\n            &gt;&gt;&gt; t = syp.symbols('t')\n            &gt;&gt;&gt; x, y = syp.symbols('x y', cls=syp.Function)\n            &gt;&gt;&gt; x, y = x(t), y(t)\n            &gt;&gt;&gt; # Autonomous system\n            &gt;&gt;&gt; eqs = [syp.diff(x, t) - y, syp.diff(y, t) + x]\n            &gt;&gt;&gt; sys = EuclideanDS.from_symbolic(eqs, [x, y])\n            &gt;&gt;&gt; type(sys).__name__\n            'AutonomousEuclideanDS'\n        \"\"\"\n        from ..sym_utils import SymbolicSystemBuilder\n\n        # Build vector field and detect system type\n        result = SymbolicSystemBuilder.build_vector_field(\n            equations, variables, parameters\n        )\n\n        # Create default phase space if not provided\n        if phase_space is None:\n            phase_space = PhaseSpace.euclidean(result.dimension)\n\n        # Dispatch to appropriate subclass\n        if result.is_autonomous:\n            from .autonomous import AutonomousEuclideanDS\n            return AutonomousEuclideanDS(\n                dimension=result.dimension,\n                vector_field=result.vector_field,\n                phase_space=phase_space\n            )\n        else:\n            from .non_autonomous import NonAutonomousEuclideanDS\n            # Create default time horizon if not provided\n            if time_horizon is None:\n                time_horizon = TimeHorizon.real_line()\n            return NonAutonomousEuclideanDS(\n                dimension=result.dimension,\n                vector_field=result.vector_field,\n                phase_space=phase_space,\n                time_horizon=time_horizon\n            )\n\n\n    # ========================================================================\n    # Abstract Interface - Subclasses Must Implement\n    # ========================================================================\n\n    @abstractmethod\n    def trajectory(\n        self,\n        initial_state: NDArray[np.float64],\n        t_span: Tuple[float, float],\n        t_eval: NDArray[np.float64],\n        t0: Optional[float] = None,  \n        method: str = 'RK45',\n        dense_output: bool = True\n    ) -&gt; EuclideanTrajectory:\n        pass\n\n    @property\n    @abstractmethod\n    def vector_field(self) -&gt; Union[AutonomousVectorField, NonAutonomousVectorField]:\n        \"\"\"\n        Vector field defining the dynamical system.\n\n        Returns:\n            Vector field function (signature depends on subclass)\n        \"\"\"\n        pass\n\n\n    # ========================================================================\n    # Validation\n    # ========================================================================\n\n    def _validate_state(self, state: NDArray[np.float64]) -&gt; None:\n        \"\"\"\n        Validate state vector dimension and phase space membership.\n\n        Args:\n            state: State vector to validate\n\n        Raises:\n            ValueError: If state.shape != (dimension,) or state \u2209 X\n        \"\"\"\n        if state.shape != (self.dimension,):\n            raise ValueError(\n                f\"State vector has incorrect dimension: \"\n                f\"expected ({self.dimension},), got {state.shape}\"\n            )\n\n        # Check phase space membership\n        if not self.phase_space.contains(state):\n            raise ValueError(\n                f\"State {state} is not in phase space X. \"\n                f\"Phase space constraints violated.\"\n            )\n\n    def _validate_time_span(self, t_span: Tuple[float, float]) -&gt; None:\n        \"\"\"\n        Validate time span for integration.\n\n        Allows:\n        - Forward integration: t_start &lt; t_end\n        - Backward integration: t_start &gt; t_end\n        - Bidirectional: t_start interior to t_eval range (checked separately)\n\n        Forbids:\n        - Zero-length intervals: t_start == t_end\n\n        Args:\n            t_span: (t_start, t_end) interval\n\n        Raises:\n            ValueError: If t_start == t_end\n        \"\"\"\n        t_start, t_end = t_span\n        if t_start == t_end:\n            raise ValueError(\n                f\"Time span must have nonzero length, got t_span = {t_span}\"\n            )\n\n    def _validate_t_eval(\n        self, \n        t_eval: NDArray[np.float64], \n        t_span: Tuple[float, float]\n    ) -&gt; None:\n        \"\"\"\n        Validate evaluation time points.\n\n        For unidirectional integration: t_eval must be within [min(t_span), max(t_span)]\n        For bidirectional: t_span[0] is t_0, t_eval can span around it\n\n        Args:\n            t_eval: Time points for solution evaluation\n            t_span: Integration interval\n\n        Raises:\n            ValueError: If t_eval points outside valid range for unidirectional integration\n        \"\"\"\n        t_start, t_end = t_span\n        t_min, t_max = min(t_start, t_end), max(t_start, t_end)\n\n        # Check if bidirectional pattern: t_start is interior to t_eval\n        t_eval_min, t_eval_max = np.min(t_eval), np.max(t_eval)\n        is_bidirectional = (t_eval_min &lt; t_start &lt; t_eval_max)\n\n        if not is_bidirectional:\n            # Standard unidirectional: t_eval must be within t_span bounds\n            if np.any(t_eval &lt; t_min) or np.any(t_eval &gt; t_max):\n                raise ValueError(\n                    f\"All t_eval points must be in [{t_min}, {t_max}], \"\n                    f\"got range [{t_eval_min}, {t_eval_max}]\"\n                )\n\n    def _validate_time_step(self, dt: float) -&gt; None:\n        \"\"\"\n        Validate time step for single evolution.\n\n        Args:\n            dt: Time step\n\n        Raises:\n            ValueError: If dt &lt;= 0\n        \"\"\"\n        if dt &lt;= 0:\n            raise ValueError(f\"Time step must be positive, got dt = {dt}\")\n\n\n    # ========================================================================\n    # Phase Space Geometry\n    # ========================================================================\n\n    def phase_space_distance(\n        self, \n        x1: NDArray[np.float64], \n        x2: NDArray[np.float64]\n    ) -&gt; float:\n        \"\"\"\n        Euclidean distance between two phase space points.\n\n        Computes L2 norm: ||x1 - x2||_2 = sqrt(\u03a3(x1_i - x2_i)\u00b2)\n\n        Args:\n            x1, x2: Points in phase space R^n\n\n        Returns:\n            float: Euclidean distance\n\n        Raises:\n            ValueError: If x1 or x2 have incorrect dimension\n        \"\"\"\n        self._validate_state(x1)\n        self._validate_state(x2)\n        return float(np.linalg.norm(x1 - x2))\n\n    def phase_space_volume(self, points: NDArray[np.float64]) -&gt; np.float64:\n        \"\"\"\n        Estimate volume of point cloud in phase space.\n\n        Uses ConvexHull if available, falls back to bounding box volume.\n        Returns np.inf if phase space is unbounded and points span infinite extent.\n\n        Args:\n            points: Array of shape (n_points, dimension)\n\n        Returns:\n            np.float64: Estimated volume. Returns np.float64(np.inf) if phase \n                        space is unbounded and points span infinite extent.\n                        Returns 0.0 if insufficient points for hull.\n\n        Raises:\n            ValueError: If points.shape[1] != dimension\n        \"\"\"\n        if points.shape[1] != self.dimension:\n            raise ValueError(\n                f\"Points must have dimension {self.dimension}, \"\n                f\"got shape {points.shape}\"\n            )\n\n        if points.shape[0] &lt; self.dimension + 1:\n            return np.float64(0.0)  # Insufficient points for non-degenerate hull\n\n        # Check for infinite extent\n        extents = np.max(points, axis=0) - np.min(points, axis=0)\n        if np.any(np.isinf(extents)):\n            return np.float64(np.inf)\n\n        try:\n            from scipy.spatial import ConvexHull\n            hull = ConvexHull(points)\n            return np.float64(hull.volume)\n        except ImportError:\n            # Fallback: bounding box volume\n            return np.float64(np.prod(extents))\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.EuclideanDS.vector_field","title":"<code>vector_field</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Vector field defining the dynamical system.</p> <p>Returns:</p> Type Description <code>Union[AutonomousVectorField, NonAutonomousVectorField]</code> <p>Vector field function (signature depends on subclass)</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.EuclideanDS.__init__","title":"<code>__init__(dimension, phase_space)</code>","text":"<p>Initialize Euclidean dynamical system.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>Phase space dimension n (must be positive integer) -&gt; Not a dimension in the linear subspace sense of the term, just #state_components                </p> required <code>phase_space</code> <code>PhaseSpace</code> <p>Phase space X subset of R^n</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimension \u2264 0 or phase_space dimension mismatch</p> <p>NOTE: This constructor is NEVER called directly by users (abstract class). It's invoked via super().init() from subclasses.</p> Source code in <code>src/PyDynSys/core/euclidean/base.py</code> <pre><code>def __init__(self, dimension: int, phase_space: PhaseSpace):\n    \"\"\"\n    Initialize Euclidean dynamical system.\n\n    Args:\n        dimension (int): Phase space dimension n (must be positive integer)\n            -&gt; Not a dimension in the linear subspace sense of the term, just #state_components                \n        phase_space (PhaseSpace): Phase space X subset of R^n\n\n    Raises:\n        ValueError: If dimension \u2264 0 or phase_space dimension mismatch\n\n    NOTE: This constructor is NEVER called directly by users (abstract class).\n    It's invoked via super().__init__() from subclasses.\n    \"\"\"\n    # Validation\n    if dimension &lt;= 0:\n        raise ValueError(f\"Phase space dimension must be positive, got {dimension}\")\n    if phase_space.dimension != dimension:\n        raise ValueError(\n            f\"Phase space dimension ({phase_space.dimension}) must match \"\n            f\"system dimension ({dimension})\"\n        )\n\n    self.dimension = dimension\n    self.phase_space = phase_space\n    # Cache now stores EuclideanTrajectory objects, will be updated in subclasses\n    self._solutions_cache: Dict[TrajectoryCacheKey, Any] = {}\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.EuclideanDS.from_symbolic","title":"<code>from_symbolic(equations, variables, parameters=None, phase_space=None, time_horizon=None)</code>  <code>classmethod</code>","text":"<p>Factory method: construct system instance from symbolic equations.</p> <p>Auto-detects whether system is autonomous and returns appropriate subclass instance (AutonomousEuclideanDS or NonAutonomousEuclideanDS).</p> <p>Parameters:</p> Name Type Description Default <code>equations</code> <code>SymbolicODE</code> <p>Symbolic ODE in form [d(x_i)/dt - F_i(x, t), ...]</p> required <code>variables</code> <code>List[Function]</code> <p>Dependent variables as SymPy Function objects</p> required <code>parameters</code> <code>SystemParameters</code> <p>Optional parameter substitution dict</p> <code>None</code> <code>phase_space</code> <code>PhaseSpace</code> <p>Phase space X subset R^n (defaults to X = R^n)</p> <code>None</code> <code>time_horizon</code> <code>TimeHorizon</code> <p>Time horizon T subset R (only used for non-autonomous, defaults to T = R)</p> <code>None</code> <p>Returns:</p> Type Description <code>EuclideanDS</code> <p>AutonomousEuclideanDS if partial(F, t) = 0, else NonAutonomousEuclideanDS</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If system is not first-order</p> Example <p>t = syp.symbols('t') x, y = syp.symbols('x y', cls=syp.Function) x, y = x(t), y(t)</p> Source code in <code>src/PyDynSys/core/euclidean/base.py</code> <pre><code>@classmethod\ndef from_symbolic(\n    cls,\n    equations: SymbolicODE,\n    variables: List[syp.Function],\n    parameters: SystemParameters = None,\n    phase_space: PhaseSpace = None,\n    time_horizon: TimeHorizon = None\n) -&gt; 'EuclideanDS':\n    \"\"\"\n    Factory method: construct system instance from symbolic equations.\n\n    Auto-detects whether system is autonomous and returns appropriate\n    subclass instance (AutonomousEuclideanDS or NonAutonomousEuclideanDS).\n\n    Args:\n        equations: Symbolic ODE in form [d(x_i)/dt - F_i(x, t), ...]\n        variables: Dependent variables as SymPy Function objects\n        parameters: Optional parameter substitution dict\n        phase_space: Phase space X subset R^n (defaults to X = R^n)\n        time_horizon: Time horizon T subset R (only used for non-autonomous, defaults to T = R)\n\n    Returns:\n        AutonomousEuclideanDS if partial(F, t) = 0, else NonAutonomousEuclideanDS\n\n    Raises:\n        ValueError: If system is not first-order\n\n    Example:\n        &gt;&gt;&gt; t = syp.symbols('t')\n        &gt;&gt;&gt; x, y = syp.symbols('x y', cls=syp.Function)\n        &gt;&gt;&gt; x, y = x(t), y(t)\n        &gt;&gt;&gt; # Autonomous system\n        &gt;&gt;&gt; eqs = [syp.diff(x, t) - y, syp.diff(y, t) + x]\n        &gt;&gt;&gt; sys = EuclideanDS.from_symbolic(eqs, [x, y])\n        &gt;&gt;&gt; type(sys).__name__\n        'AutonomousEuclideanDS'\n    \"\"\"\n    from ..sym_utils import SymbolicSystemBuilder\n\n    # Build vector field and detect system type\n    result = SymbolicSystemBuilder.build_vector_field(\n        equations, variables, parameters\n    )\n\n    # Create default phase space if not provided\n    if phase_space is None:\n        phase_space = PhaseSpace.euclidean(result.dimension)\n\n    # Dispatch to appropriate subclass\n    if result.is_autonomous:\n        from .autonomous import AutonomousEuclideanDS\n        return AutonomousEuclideanDS(\n            dimension=result.dimension,\n            vector_field=result.vector_field,\n            phase_space=phase_space\n        )\n    else:\n        from .non_autonomous import NonAutonomousEuclideanDS\n        # Create default time horizon if not provided\n        if time_horizon is None:\n            time_horizon = TimeHorizon.real_line()\n        return NonAutonomousEuclideanDS(\n            dimension=result.dimension,\n            vector_field=result.vector_field,\n            phase_space=phase_space,\n            time_horizon=time_horizon\n        )\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.EuclideanDS.from_symbolic--autonomous-system","title":"Autonomous system","text":"<p>eqs = [syp.diff(x, t) - y, syp.diff(y, t) + x] sys = EuclideanDS.from_symbolic(eqs, [x, y]) type(sys).name 'AutonomousEuclideanDS'</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.EuclideanDS.phase_space_distance","title":"<code>phase_space_distance(x1, x2)</code>","text":"<p>Euclidean distance between two phase space points.</p> <p>Computes L2 norm: ||x1 - x2||_2 = sqrt(\u03a3(x1_i - x2_i)\u00b2)</p> <p>Parameters:</p> Name Type Description Default <code>x1, x2</code> <p>Points in phase space R^n</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Euclidean distance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x1 or x2 have incorrect dimension</p> Source code in <code>src/PyDynSys/core/euclidean/base.py</code> <pre><code>def phase_space_distance(\n    self, \n    x1: NDArray[np.float64], \n    x2: NDArray[np.float64]\n) -&gt; float:\n    \"\"\"\n    Euclidean distance between two phase space points.\n\n    Computes L2 norm: ||x1 - x2||_2 = sqrt(\u03a3(x1_i - x2_i)\u00b2)\n\n    Args:\n        x1, x2: Points in phase space R^n\n\n    Returns:\n        float: Euclidean distance\n\n    Raises:\n        ValueError: If x1 or x2 have incorrect dimension\n    \"\"\"\n    self._validate_state(x1)\n    self._validate_state(x2)\n    return float(np.linalg.norm(x1 - x2))\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.EuclideanDS.phase_space_volume","title":"<code>phase_space_volume(points)</code>","text":"<p>Estimate volume of point cloud in phase space.</p> <p>Uses ConvexHull if available, falls back to bounding box volume. Returns np.inf if phase space is unbounded and points span infinite extent.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[float64]</code> <p>Array of shape (n_points, dimension)</p> required <p>Returns:</p> Type Description <code>float64</code> <p>np.float64: Estimated volume. Returns np.float64(np.inf) if phase          space is unbounded and points span infinite extent.         Returns 0.0 if insufficient points for hull.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If points.shape[1] != dimension</p> Source code in <code>src/PyDynSys/core/euclidean/base.py</code> <pre><code>def phase_space_volume(self, points: NDArray[np.float64]) -&gt; np.float64:\n    \"\"\"\n    Estimate volume of point cloud in phase space.\n\n    Uses ConvexHull if available, falls back to bounding box volume.\n    Returns np.inf if phase space is unbounded and points span infinite extent.\n\n    Args:\n        points: Array of shape (n_points, dimension)\n\n    Returns:\n        np.float64: Estimated volume. Returns np.float64(np.inf) if phase \n                    space is unbounded and points span infinite extent.\n                    Returns 0.0 if insufficient points for hull.\n\n    Raises:\n        ValueError: If points.shape[1] != dimension\n    \"\"\"\n    if points.shape[1] != self.dimension:\n        raise ValueError(\n            f\"Points must have dimension {self.dimension}, \"\n            f\"got shape {points.shape}\"\n        )\n\n    if points.shape[0] &lt; self.dimension + 1:\n        return np.float64(0.0)  # Insufficient points for non-degenerate hull\n\n    # Check for infinite extent\n    extents = np.max(points, axis=0) - np.min(points, axis=0)\n    if np.any(np.isinf(extents)):\n        return np.float64(np.inf)\n\n    try:\n        from scipy.spatial import ConvexHull\n        hull = ConvexHull(points)\n        return np.float64(hull.volume)\n    except ImportError:\n        # Fallback: bounding box volume\n        return np.float64(np.prod(extents))\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS","title":"<code>NonAutonomousEuclideanDS</code>","text":"<p>               Bases: <code>EuclideanDS</code></p> <p>Non-autonomous Euclidean dynamical system.</p> <p>Systems where dx/dt = F(x, t) with F: R^n x R \u2192 R^n explicitly time-dependent. Equivalently, PartialDerivative(F, t) nonzero at some (x, t).</p> <p>Mathematical Properties: - Flow phi_t(x, t_0) depends on initial time t_0 - Can be autonomized by augmenting state: y = (x, t), dy/dt = (F(x,t), 1) - Useful for periodically forced systems, time-varying parameters</p> <p>NOTE: All non autonomous systems can be autonomized by augmenting state: y = (x, t),  dy/dt = (F(x,t), 1). However, this can alter topological properties and is not always  desirable, hence our support for non-autonomous systems.</p> Example Source code in <code>src/PyDynSys/core/euclidean/non_autonomous.py</code> <pre><code>class NonAutonomousEuclideanDS(EuclideanDS):\n    \"\"\"\n    Non-autonomous Euclidean dynamical system.\n\n    Systems where dx/dt = F(x, t) with F: R^n x R \u2192 R^n explicitly\n    time-dependent. Equivalently, PartialDerivative(F, t) nonzero at some (x, t).\n\n    Mathematical Properties:\n    - Flow phi_t(x, t_0) depends on initial time t_0\n    - Can be autonomized by augmenting state: y = (x, t), dy/dt = (F(x,t), 1)\n    - Useful for periodically forced systems, time-varying parameters\n\n    NOTE: All non autonomous systems can be autonomized by augmenting state: y = (x, t), \n    dy/dt = (F(x,t), 1). However, this can alter topological properties and is not always \n    desirable, hence our support for non-autonomous systems.\n\n    Example:\n        &gt;&gt;&gt; # Driven harmonic oscillator: x'' + x = sin(t)\n        &gt;&gt;&gt; def driven_oscillator(x, t):\n        ...     return np.array([x[1], -x[0] + np.sin(t)])\n        &gt;&gt;&gt; phase_space = PhaseSpace.euclidean(2)\n        &gt;&gt;&gt; time_horizon = TimeHorizon.real_line()\n        &gt;&gt;&gt; sys = NonAutonomousEuclideanDS(\n        ...     dimension=2, \n        ...     vector_field=driven_oscillator,\n        ...     phase_space=phase_space,\n        ...     time_horizon=time_horizon\n        ... )\n    \"\"\"\n\n    def __init__(\n        self, \n        dimension: int, \n        vector_field: NonAutonomousVectorField,\n        phase_space: PhaseSpace = None,\n        time_horizon: TimeHorizon = None\n    ):\n        \"\"\"\n        Initialize non-autonomous system.\n\n        Args:\n            dimension (int): Phase space dimension n\n            vector_field: Function F(x, t): R^n x R \u2192 R^n, where F(x, t) = dx/dt\n            phase_space (PhaseSpace): Phase space X subset of R^n (defaults to X = R^n)\n            time_horizon (RealTimeHorizon): Time domain T subset of R (defaults to T = R)\n\n        Raises:\n            ValueError: If dimension \u2264 0 or phase_space dimension mismatch\n        \"\"\"\n        # Enforce defaults\n        if phase_space is None:\n            phase_space = PhaseSpace.euclidean(dimension)\n        if time_horizon is None:\n            time_horizon = TimeHorizon.real_line()\n\n        super().__init__(dimension, phase_space)\n        self._vector_field = vector_field\n        self.time_horizon = time_horizon\n\n\n       ### --- Abstract Methods --- ###\n\n\n    @abstractmethod\n    def find_instantaneous_equilibria(self, t: float) -&gt; List[NDArray]:\n        \"\"\"\n        Find instantaneous equilibria at time t: x* s.t. F(x*, t) = 0.\n        \"\"\"\n\n        # TODO: Implement &amp; decide on signature\n        pass\n\n    @abstractmethod\n    def find_global_equilibria(self) -&gt; List[NDArray]:\n        \"\"\"\n        Find global equilibria: x* s.t. F(x*, t) = 0 for all t.\n        \"\"\"\n        pass\n\n\n        ### --- EuclideanDS Method Impls --- ###\n\n\n    @property\n    def vector_field(self) -&gt; NonAutonomousVectorField:\n        \"\"\"\n        Vector field defining the dynamical system.\n        \"\"\"\n        return self._vector_field\n\n    def trajectory(\n        self,\n        initial_state: NDArray[np.float64],\n        t0: float,\n        t_span: Tuple[float, float],\n        t_eval: NDArray[np.float64],\n        method: str = 'RK45',\n        dense_output: bool = True\n    ) -&gt; EuclideanTrajectory:\n        \"\"\"\n        Solve initial value problem: dx/dt = F(x, t), x(t_0) = x_0.\n\n        For non-autonomous systems, initial time t_0 matters and is required.\n        If t_eval spans around t_0 (min(t_eval) &lt; t_0 &lt; max(t_eval)), performs\n        bidirectional integration by integrating backward to min(t_eval) and\n        forward to max(t_eval), then concatenating results (sol=None in this mode).\n\n        Args:\n            initial_state (NDArray[np.float64]): Initial condition x(t_0) in Phase space X\n            t_span (Tuple[float, float]): Integration interval (t_start, t_end)\n            t_eval (NDArray[np.float64]): Time points for explicit evaluation\n            method (str): ODE solver (default 'RK45')\n            dense_output (bool): If True, returns continuous interpolant (sol(t))\n                -&gt; I am yet to see a use case where not true is needed.\n\n        Returns:\n            EuclideanTrajectory: Trajectory object with attributes:\n                - t: Evaluation times (property, concatenated from segments)\n                - y: States at each time (property, concatenated from segments)\n                - segments: List of trajectory segments\n                - interpolate(t): Method for continuous evaluation at time t\n                - domains: List of domain intervals for each segment \n\n        Raises:\n            ValueError: If state dimension incorrect, t_span invalid, \n                       or t_eval points outside valid range\n\n        Implementation Notes:\n            - Solutions cached by (initial_state, t_span, t_eval, method)\n            - Integrator uses lambda (t, x): self.vector_field(x, t) (uses both parameters)\n            - Supports forward and backward integration via scipy\n            - No existence/uniqueness checks performed (TODO: future)\n        \"\"\"\n        # Validation\n        self._validate_state(initial_state)\n        t_min_eval = float(np.min(t_eval))\n        t_max_eval = float(np.max(t_eval))\n        spans_around_t0 = (t_min_eval &lt; t0) and (t0 &lt; t_max_eval)\n\n        if spans_around_t0:\n            # Bidirectional mode: ensure t0 and eval bounds are within time horizon\n            if not self.time_horizon.contains(t0):\n                raise ValueError(\n                    f\"Initial time t0 = {t0} is not in time horizon T. \"\n                    f\"Time horizon bounds: {self.time_horizon.bounds}\"\n                )\n            if not self.time_horizon.contains(t_min_eval) or not self.time_horizon.contains(t_max_eval):\n                raise ValueError(\n                    f\"Evaluation interval [{t_min_eval}, {t_max_eval}] not fully contained in time horizon T. \"\n                    f\"Time horizon bounds: {self.time_horizon.bounds}\"\n                )\n        else:\n            # Unidirectional mode: enforce standard rules and require t0 to coincide with t_span[0]\n            if t0 != t_span[0]:\n                raise ValueError(\n                    f\"For unidirectional integration, t0 must equal t_span[0]. Got t0={t0}, t_span[0]={t_span[0]}\"\n                )\n            self._validate_time_span(t_span)\n            self._validate_t_eval(t_eval, t_span)\n\n        # ====================================================================\n        # CACHING STRATEGY \n        # ====================================================================\n        # CRITICAL: for non-autonomous systems: initial_time t0 is part of the cache key!\n        # \n        # Unlike autonomous systems where time-translation doesn't matter,\n        # non-autonomous systems have F(x,t) depending explicitly on time.\n        # \n        # Example demonstrating why t0 is critical:\n        #   System: dx/dt = -x + sin(t)\n        #   Same x_0 = 1.0 but different t0:\n        #     - Solve from t0=0:   affected by sin(0)=0    \u2192 one trajectory\n        #     - Solve from t0=\u03c0/2: affected by sin(pi/2)=1 \u2192 DIFFERENT trajectory!\n        # \n        # Cache key includes: (x_0, t_0, t_eval) but NOT method\n        cache_key = TrajectoryCacheKey(\n            initial_conditions=tuple(initial_state),\n            initial_time=t0,  # Use actual t0 parameter \n            t_eval_tuple=tuple(t_eval)\n        )\n\n        # Cache hit: Return previously computed trajectory\n        if cache_key in self._solutions_cache:\n            return self._solutions_cache[cache_key]\n\n        # Solve IVP\n        if spans_around_t0:\n            # BIDIRECTIONAL CASE: t0 is interior to [min(t_eval), max(t_eval)]\n            # \n            # For non-autonomous systems, this is particularly important because\n            # the vector field F(x,t) changes with time. We need accurate solutions\n            # both before AND after t0 to capture time-dependent behavior.\n            #\n            # Example: Periodically forced oscillator with F(x,t) = -x + sin(\u03c9t)\n            #   At t&lt;0: forcing is negative (sin negative)\n            #   At t&gt;0: forcing is positive (sin positive)\n            # Bidirectional integration captures this transition.\n\n            # Bidirectional case: create two segments and let Trajectory handle tangent domain\n            sol_backward_raw, sol_forward_raw = self._solve_bidirectional_raw(\n                initial_state=initial_state,\n                t0=t0,\n                t_eval=t_eval,\n                method=method,\n                dense_output=dense_output,\n            )\n\n            # Wrap raw scipy solutions in segments\n            # Each segment preserves its interpolant if dense_output=True\n            seg_backward = EuclideanTrajectorySegment.from_scipy_solution(\n                SciPyIvpSolution(raw_solution=sol_backward_raw),\n                method=method\n            )\n            seg_forward = EuclideanTrajectorySegment.from_scipy_solution(\n                SciPyIvpSolution(raw_solution=sol_forward_raw),\n                method=method\n            )\n\n            # Merge via trajectory (handles tangent domain at t0 automatically)\n            trajectory = EuclideanTrajectory.from_segments([seg_backward, seg_forward])\n        else:\n            # Unidirectional case: standard scipy call\n            solution_raw = solve_ivp(\n                fun=lambda t, y: self.vector_field(y, t), \n                t_span=t_span,\n                y0=initial_state,\n                t_eval=t_eval,\n                method=method,\n                dense_output=dense_output\n            )\n\n            # Wrap in segment, then trajectory\n            segment = EuclideanTrajectorySegment.from_scipy_solution(\n                SciPyIvpSolution(raw_solution=solution_raw),\n                method=method\n            )\n            trajectory = EuclideanTrajectory.from_segments([segment])\n\n        # Cache and return\n        self._solutions_cache[cache_key] = trajectory\n        return trajectory\n\n\n        ### --- Public Methods --- ###\n\n\n    def evolve(\n        self,\n        initial_state: NDArray[np.float64],\n        t0: float,\n        dt: float,\n        method: str = 'RK45'\n    ) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Single time-step evolution: estimate x(t_0 + dt) from x(t_0).\n\n        For non-autonomous systems, the initial time t_0 is CRUCIAL! \n        The same initial state at different times will evolve differently.\n\n        Args:\n            initial_state: State at time t_0\n            t0: Initial time (ESSENTIAL for non-autonomous systems)\n            dt: Time step (must be positive)\n            method: ODE solver\n\n        Returns:\n            NDArray[np.float64]: Estimated state at t_0 + dt\n\n        Raises:\n            ValueError: If state dimension incorrect or dt \u2264 0\n\n        Example:\n            &gt;&gt;&gt; # Driven oscillator evolves differently at different times\n            &gt;&gt;&gt; x0 = np.array([1.0, 0.0])\n            &gt;&gt;&gt; sys.evolve(x0, t0=0.0, dt=0.1)   # Different from\n            &gt;&gt;&gt; sys.evolve(x0, t0=10.0, dt=0.1)  # this!\n        \"\"\"\n        self._validate_state(initial_state)\n        self._validate_time_step(dt)\n\n        # Single-step integration without caching\n        result = solve_ivp(\n            fun=lambda t, y: self.vector_field(y, t),  # Use both time and state\n            t_span=(t0, t0 + dt),\n            y0=initial_state,\n            t_eval=[t0 + dt],\n            method=method,\n            dense_output=False\n        )\n\n        return result.y[:, 0]  # Extract final state\n\n\n        ### --- Private Methods --- ###\n\n\n    def _validate_time_span(self, t_span: Tuple[float, float]) -&gt; None:\n        \"\"\"\n        Override base validation to also check time horizon membership.\n\n        For non-autonomous systems, we must verify that both endpoints of the\n        integration interval lie within the time horizon T subset of R.\n\n        Args:\n            t_span (Tuple[float, float]): (t_start, t_end) interval\n\n        Raises:\n            ValueError: If t_start == t_end or if either endpoint not in T\n        \"\"\"\n        # First, perform base validation (non-zero length)\n        super()._validate_time_span(t_span)\n\n        # Then check time horizon membership\n        t_start, t_end = t_span\n\n        if not self.time_horizon.contains(t_start):\n            raise ValueError(\n                f\"Initial time t_start = {t_start} is not in time horizon T. \"\n                f\"Time horizon bounds: {self.time_horizon.bounds}\"\n            )\n\n        if not self.time_horizon.contains(t_end):\n            raise ValueError(\n                f\"Final time t_end = {t_end} is not in time horizon T. \"\n                f\"Time horizon bounds: {self.time_horizon.bounds}\"\n            )\n\n    def _solve_bidirectional_raw(\n        self,\n        initial_state: NDArray[np.float64],\n        t0: float,\n        t_eval: NDArray[np.float64],\n        method: str,\n        dense_output: bool,\n    ) -&gt; Tuple[Any, Any]:\n        \"\"\"\n        Perform bidirectional integration: backward from t_0, forward from t_0.\n\n        Returns raw scipy OdeResult objects from both integrations, without\n        concatenation. Concatenation is handled by EuclideanTrajectory.from_segments().\n\n        Args:\n            initial_state: x(t_0)\n            t0: Initial time (interior to t_eval range)\n            t_eval: Full evaluation array\n            method: Solver method\n            dense_output: Whether to generate interpolant for each segment\n\n        Returns:\n            Tuple[Any, Any]: (sol_backward, sol_forward) raw scipy OdeResult objects\n\n        NOTE: Each segment can have dense_output if requested. The trajectory\n        will handle dispatching interpolation to the correct segment.\n        \"\"\"\n        # ====================================================================\n        # SPLIT EVALUATION ARRAY FOR BIDIRECTIONAL INTEGRATION\n        # ====================================================================\n        # Split t_eval into backward and forward portions around t0\n        #\n        # CRITICAL for non-autonomous systems: We must ensure BOTH segments include t0\n        # to create tangent domains (no gap). This is even more important for non-autonomous\n        # systems because interpolation across a gap would be undefined - we can't just\n        # \"fill in\" missing values since the vector field F(x,t) depends on time.\n        #\n        # See autonomous.py::_solve_bidirectional_raw for detailed explanation of the\n        # tangent domain issue and why we need to include t0 in both segments.\n\n        t_eval_backward = t_eval[t_eval &lt; t0]   # Points strictly before t0\n        t_eval_forward = t_eval[t_eval &gt;= t0]   # Points at or after t0\n\n        # ====================================================================\n        # BACKWARD INTEGRATION: t0 \u2192 min(t_eval)\n        # ====================================================================\n        # Include t0 in backward to ensure tangent domain with forward segment\n        if len(t_eval_backward) &gt; 0:\n            # Append t0 to backward evaluation points to ensure segment ends at t0\n            t_eval_backward_with_t0 = np.append(t_eval_backward, t0)\n            sol_backward = solve_ivp(\n                fun=lambda t, y: self.vector_field(y, t),\n                t_span=(t0, float(t_eval_backward[0])),\n                y0=initial_state,\n                t_eval=t_eval_backward_with_t0[::-1],\n                method=method,\n                dense_output=dense_output,  # Allow dense output for segment\n            )\n        else:\n            sol_backward = None\n\n        # ====================================================================\n        # FORWARD INTEGRATION: t0 \u2192 max(t_eval)\n        # ====================================================================\n        # Ensure t0 is at the start to guarantee tangent domain\n        # (Same logic as autonomous case - see autonomous.py for detailed explanation)\n        if len(t_eval_forward) &gt; 0:\n            # Check if t0 is already the first point (within floating-point tolerance)\n            if abs(t_eval_forward[0] - t0) &gt; 1e-10:\n                # t0 is NOT in t_eval_forward, prepend it to ensure tangent domain\n                t_eval_forward_with_t0 = np.concatenate([[t0], t_eval_forward])\n            else:\n                # t0 is already present, no modification needed\n                t_eval_forward_with_t0 = t_eval_forward\n\n            sol_forward = solve_ivp(\n                fun=lambda t, y: self.vector_field(y, t),\n                t_span=(t0, float(t_eval_forward[-1])),\n                y0=initial_state,\n                t_eval=t_eval_forward_with_t0,\n                method=method,\n                dense_output=dense_output,  # Allow dense output for segment\n            )\n        else:\n            sol_forward = None\n\n        # Return raw solutions (let Trajectory handle merging)\n        return sol_backward, sol_forward\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS--driven-harmonic-oscillator-x-x-sint","title":"Driven harmonic oscillator: x'' + x = sin(t)","text":"<p>def driven_oscillator(x, t): ...     return np.array([x[1], -x[0] + np.sin(t)]) phase_space = PhaseSpace.euclidean(2) time_horizon = TimeHorizon.real_line() sys = NonAutonomousEuclideanDS( ...     dimension=2,  ...     vector_field=driven_oscillator, ...     phase_space=phase_space, ...     time_horizon=time_horizon ... )</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS.vector_field","title":"<code>vector_field</code>  <code>property</code>","text":"<p>Vector field defining the dynamical system.</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS.__init__","title":"<code>__init__(dimension, vector_field, phase_space=None, time_horizon=None)</code>","text":"<p>Initialize non-autonomous system.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>Phase space dimension n</p> required <code>vector_field</code> <code>NonAutonomousVectorField</code> <p>Function F(x, t): R^n x R \u2192 R^n, where F(x, t) = dx/dt</p> required <code>phase_space</code> <code>PhaseSpace</code> <p>Phase space X subset of R^n (defaults to X = R^n)</p> <code>None</code> <code>time_horizon</code> <code>RealTimeHorizon</code> <p>Time domain T subset of R (defaults to T = R)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimension \u2264 0 or phase_space dimension mismatch</p> Source code in <code>src/PyDynSys/core/euclidean/non_autonomous.py</code> <pre><code>def __init__(\n    self, \n    dimension: int, \n    vector_field: NonAutonomousVectorField,\n    phase_space: PhaseSpace = None,\n    time_horizon: TimeHorizon = None\n):\n    \"\"\"\n    Initialize non-autonomous system.\n\n    Args:\n        dimension (int): Phase space dimension n\n        vector_field: Function F(x, t): R^n x R \u2192 R^n, where F(x, t) = dx/dt\n        phase_space (PhaseSpace): Phase space X subset of R^n (defaults to X = R^n)\n        time_horizon (RealTimeHorizon): Time domain T subset of R (defaults to T = R)\n\n    Raises:\n        ValueError: If dimension \u2264 0 or phase_space dimension mismatch\n    \"\"\"\n    # Enforce defaults\n    if phase_space is None:\n        phase_space = PhaseSpace.euclidean(dimension)\n    if time_horizon is None:\n        time_horizon = TimeHorizon.real_line()\n\n    super().__init__(dimension, phase_space)\n    self._vector_field = vector_field\n    self.time_horizon = time_horizon\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS.evolve","title":"<code>evolve(initial_state, t0, dt, method='RK45')</code>","text":"<p>Single time-step evolution: estimate x(t_0 + dt) from x(t_0).</p> <p>For non-autonomous systems, the initial time t_0 is CRUCIAL!  The same initial state at different times will evolve differently.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>NDArray[float64]</code> <p>State at time t_0</p> required <code>t0</code> <code>float</code> <p>Initial time (ESSENTIAL for non-autonomous systems)</p> required <code>dt</code> <code>float</code> <p>Time step (must be positive)</p> required <code>method</code> <code>str</code> <p>ODE solver</p> <code>'RK45'</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Estimated state at t_0 + dt</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If state dimension incorrect or dt \u2264 0</p> Example Source code in <code>src/PyDynSys/core/euclidean/non_autonomous.py</code> <pre><code>def evolve(\n    self,\n    initial_state: NDArray[np.float64],\n    t0: float,\n    dt: float,\n    method: str = 'RK45'\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Single time-step evolution: estimate x(t_0 + dt) from x(t_0).\n\n    For non-autonomous systems, the initial time t_0 is CRUCIAL! \n    The same initial state at different times will evolve differently.\n\n    Args:\n        initial_state: State at time t_0\n        t0: Initial time (ESSENTIAL for non-autonomous systems)\n        dt: Time step (must be positive)\n        method: ODE solver\n\n    Returns:\n        NDArray[np.float64]: Estimated state at t_0 + dt\n\n    Raises:\n        ValueError: If state dimension incorrect or dt \u2264 0\n\n    Example:\n        &gt;&gt;&gt; # Driven oscillator evolves differently at different times\n        &gt;&gt;&gt; x0 = np.array([1.0, 0.0])\n        &gt;&gt;&gt; sys.evolve(x0, t0=0.0, dt=0.1)   # Different from\n        &gt;&gt;&gt; sys.evolve(x0, t0=10.0, dt=0.1)  # this!\n    \"\"\"\n    self._validate_state(initial_state)\n    self._validate_time_step(dt)\n\n    # Single-step integration without caching\n    result = solve_ivp(\n        fun=lambda t, y: self.vector_field(y, t),  # Use both time and state\n        t_span=(t0, t0 + dt),\n        y0=initial_state,\n        t_eval=[t0 + dt],\n        method=method,\n        dense_output=False\n    )\n\n    return result.y[:, 0]  # Extract final state\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS.evolve--driven-oscillator-evolves-differently-at-different-times","title":"Driven oscillator evolves differently at different times","text":"<p>x0 = np.array([1.0, 0.0]) sys.evolve(x0, t0=0.0, dt=0.1)   # Different from sys.evolve(x0, t0=10.0, dt=0.1)  # this!</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS.find_global_equilibria","title":"<code>find_global_equilibria()</code>  <code>abstractmethod</code>","text":"<p>Find global equilibria: x s.t. F(x, t) = 0 for all t.</p> Source code in <code>src/PyDynSys/core/euclidean/non_autonomous.py</code> <pre><code>@abstractmethod\ndef find_global_equilibria(self) -&gt; List[NDArray]:\n    \"\"\"\n    Find global equilibria: x* s.t. F(x*, t) = 0 for all t.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS.find_instantaneous_equilibria","title":"<code>find_instantaneous_equilibria(t)</code>  <code>abstractmethod</code>","text":"<p>Find instantaneous equilibria at time t: x s.t. F(x, t) = 0.</p> Source code in <code>src/PyDynSys/core/euclidean/non_autonomous.py</code> <pre><code>@abstractmethod\ndef find_instantaneous_equilibria(self, t: float) -&gt; List[NDArray]:\n    \"\"\"\n    Find instantaneous equilibria at time t: x* s.t. F(x*, t) = 0.\n    \"\"\"\n\n    # TODO: Implement &amp; decide on signature\n    pass\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.NonAutonomousEuclideanDS.trajectory","title":"<code>trajectory(initial_state, t0, t_span, t_eval, method='RK45', dense_output=True)</code>","text":"<p>Solve initial value problem: dx/dt = F(x, t), x(t_0) = x_0.</p> <p>For non-autonomous systems, initial time t_0 matters and is required. If t_eval spans around t_0 (min(t_eval) &lt; t_0 &lt; max(t_eval)), performs bidirectional integration by integrating backward to min(t_eval) and forward to max(t_eval), then concatenating results (sol=None in this mode).</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>NDArray[float64]</code> <p>Initial condition x(t_0) in Phase space X</p> required <code>t_span</code> <code>Tuple[float, float]</code> <p>Integration interval (t_start, t_end)</p> required <code>t_eval</code> <code>NDArray[float64]</code> <p>Time points for explicit evaluation</p> required <code>method</code> <code>str</code> <p>ODE solver (default 'RK45')</p> <code>'RK45'</code> <code>dense_output</code> <code>bool</code> <p>If True, returns continuous interpolant (sol(t)) -&gt; I am yet to see a use case where not true is needed.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>EuclideanTrajectory</code> <code>EuclideanTrajectory</code> <p>Trajectory object with attributes: - t: Evaluation times (property, concatenated from segments) - y: States at each time (property, concatenated from segments) - segments: List of trajectory segments - interpolate(t): Method for continuous evaluation at time t - domains: List of domain intervals for each segment </p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If state dimension incorrect, t_span invalid,         or t_eval points outside valid range</p> Implementation Notes <ul> <li>Solutions cached by (initial_state, t_span, t_eval, method)</li> <li>Integrator uses lambda (t, x): self.vector_field(x, t) (uses both parameters)</li> <li>Supports forward and backward integration via scipy</li> <li>No existence/uniqueness checks performed (TODO: future)</li> </ul> Source code in <code>src/PyDynSys/core/euclidean/non_autonomous.py</code> <pre><code>def trajectory(\n    self,\n    initial_state: NDArray[np.float64],\n    t0: float,\n    t_span: Tuple[float, float],\n    t_eval: NDArray[np.float64],\n    method: str = 'RK45',\n    dense_output: bool = True\n) -&gt; EuclideanTrajectory:\n    \"\"\"\n    Solve initial value problem: dx/dt = F(x, t), x(t_0) = x_0.\n\n    For non-autonomous systems, initial time t_0 matters and is required.\n    If t_eval spans around t_0 (min(t_eval) &lt; t_0 &lt; max(t_eval)), performs\n    bidirectional integration by integrating backward to min(t_eval) and\n    forward to max(t_eval), then concatenating results (sol=None in this mode).\n\n    Args:\n        initial_state (NDArray[np.float64]): Initial condition x(t_0) in Phase space X\n        t_span (Tuple[float, float]): Integration interval (t_start, t_end)\n        t_eval (NDArray[np.float64]): Time points for explicit evaluation\n        method (str): ODE solver (default 'RK45')\n        dense_output (bool): If True, returns continuous interpolant (sol(t))\n            -&gt; I am yet to see a use case where not true is needed.\n\n    Returns:\n        EuclideanTrajectory: Trajectory object with attributes:\n            - t: Evaluation times (property, concatenated from segments)\n            - y: States at each time (property, concatenated from segments)\n            - segments: List of trajectory segments\n            - interpolate(t): Method for continuous evaluation at time t\n            - domains: List of domain intervals for each segment \n\n    Raises:\n        ValueError: If state dimension incorrect, t_span invalid, \n                   or t_eval points outside valid range\n\n    Implementation Notes:\n        - Solutions cached by (initial_state, t_span, t_eval, method)\n        - Integrator uses lambda (t, x): self.vector_field(x, t) (uses both parameters)\n        - Supports forward and backward integration via scipy\n        - No existence/uniqueness checks performed (TODO: future)\n    \"\"\"\n    # Validation\n    self._validate_state(initial_state)\n    t_min_eval = float(np.min(t_eval))\n    t_max_eval = float(np.max(t_eval))\n    spans_around_t0 = (t_min_eval &lt; t0) and (t0 &lt; t_max_eval)\n\n    if spans_around_t0:\n        # Bidirectional mode: ensure t0 and eval bounds are within time horizon\n        if not self.time_horizon.contains(t0):\n            raise ValueError(\n                f\"Initial time t0 = {t0} is not in time horizon T. \"\n                f\"Time horizon bounds: {self.time_horizon.bounds}\"\n            )\n        if not self.time_horizon.contains(t_min_eval) or not self.time_horizon.contains(t_max_eval):\n            raise ValueError(\n                f\"Evaluation interval [{t_min_eval}, {t_max_eval}] not fully contained in time horizon T. \"\n                f\"Time horizon bounds: {self.time_horizon.bounds}\"\n            )\n    else:\n        # Unidirectional mode: enforce standard rules and require t0 to coincide with t_span[0]\n        if t0 != t_span[0]:\n            raise ValueError(\n                f\"For unidirectional integration, t0 must equal t_span[0]. Got t0={t0}, t_span[0]={t_span[0]}\"\n            )\n        self._validate_time_span(t_span)\n        self._validate_t_eval(t_eval, t_span)\n\n    # ====================================================================\n    # CACHING STRATEGY \n    # ====================================================================\n    # CRITICAL: for non-autonomous systems: initial_time t0 is part of the cache key!\n    # \n    # Unlike autonomous systems where time-translation doesn't matter,\n    # non-autonomous systems have F(x,t) depending explicitly on time.\n    # \n    # Example demonstrating why t0 is critical:\n    #   System: dx/dt = -x + sin(t)\n    #   Same x_0 = 1.0 but different t0:\n    #     - Solve from t0=0:   affected by sin(0)=0    \u2192 one trajectory\n    #     - Solve from t0=\u03c0/2: affected by sin(pi/2)=1 \u2192 DIFFERENT trajectory!\n    # \n    # Cache key includes: (x_0, t_0, t_eval) but NOT method\n    cache_key = TrajectoryCacheKey(\n        initial_conditions=tuple(initial_state),\n        initial_time=t0,  # Use actual t0 parameter \n        t_eval_tuple=tuple(t_eval)\n    )\n\n    # Cache hit: Return previously computed trajectory\n    if cache_key in self._solutions_cache:\n        return self._solutions_cache[cache_key]\n\n    # Solve IVP\n    if spans_around_t0:\n        # BIDIRECTIONAL CASE: t0 is interior to [min(t_eval), max(t_eval)]\n        # \n        # For non-autonomous systems, this is particularly important because\n        # the vector field F(x,t) changes with time. We need accurate solutions\n        # both before AND after t0 to capture time-dependent behavior.\n        #\n        # Example: Periodically forced oscillator with F(x,t) = -x + sin(\u03c9t)\n        #   At t&lt;0: forcing is negative (sin negative)\n        #   At t&gt;0: forcing is positive (sin positive)\n        # Bidirectional integration captures this transition.\n\n        # Bidirectional case: create two segments and let Trajectory handle tangent domain\n        sol_backward_raw, sol_forward_raw = self._solve_bidirectional_raw(\n            initial_state=initial_state,\n            t0=t0,\n            t_eval=t_eval,\n            method=method,\n            dense_output=dense_output,\n        )\n\n        # Wrap raw scipy solutions in segments\n        # Each segment preserves its interpolant if dense_output=True\n        seg_backward = EuclideanTrajectorySegment.from_scipy_solution(\n            SciPyIvpSolution(raw_solution=sol_backward_raw),\n            method=method\n        )\n        seg_forward = EuclideanTrajectorySegment.from_scipy_solution(\n            SciPyIvpSolution(raw_solution=sol_forward_raw),\n            method=method\n        )\n\n        # Merge via trajectory (handles tangent domain at t0 automatically)\n        trajectory = EuclideanTrajectory.from_segments([seg_backward, seg_forward])\n    else:\n        # Unidirectional case: standard scipy call\n        solution_raw = solve_ivp(\n            fun=lambda t, y: self.vector_field(y, t), \n            t_span=t_span,\n            y0=initial_state,\n            t_eval=t_eval,\n            method=method,\n            dense_output=dense_output\n        )\n\n        # Wrap in segment, then trajectory\n        segment = EuclideanTrajectorySegment.from_scipy_solution(\n            SciPyIvpSolution(raw_solution=solution_raw),\n            method=method\n        )\n        trajectory = EuclideanTrajectory.from_segments([segment])\n\n    # Cache and return\n    self._solutions_cache[cache_key] = trajectory\n    return trajectory\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace","title":"<code>PhaseSpace</code>  <code>dataclass</code>","text":"<p>Phase space X subset of R^n with flexible symbolic/callable representation. </p> Supports three usage patterns <ol> <li>Symbolic only: Provides symbolic set, constraint auto-compiled (general) </li> <li>Callable only: Provides constraint directly (fast, no symbolic ops) </li> <li>Both (recommended): Provides both for optimal performance (fast + symbolic ops)</li> </ol> Symbolic representation enables <ul> <li>Rigorous mathematical operations (intersections, closures, etc.) </li> <li>Pretty printing for dynamical system descriptors </li> </ul> <p>Callable representation provides O(1) membership testing for numerical work.</p> Fields <ul> <li>dimension (int): Phase space dimension n </li> <li>symbolic_set (syp.Set | None): Optional SymPy set representation </li> <li>constraint (Callable | None): Optional callable for fast membership testing</li> </ul> <p>Note: At least one of symbolic_set or constraint must be provided, or a ValueError will be raised.</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@dataclass\nclass PhaseSpace:\n    \"\"\"\n    Phase space X subset of R^n with flexible symbolic/callable representation. \n\n    Supports three usage patterns: \n        1. Symbolic only: Provides symbolic set, constraint auto-compiled (general) \n        2. Callable only: Provides constraint directly (fast, no symbolic ops) \n        3. Both (recommended): Provides both for optimal performance (fast + symbolic ops)\n\n    Symbolic representation enables: \n        - Rigorous mathematical operations (intersections, closures, etc.) \n        - Pretty printing for dynamical system descriptors \n\n    Callable representation provides O(1) membership testing for numerical work.\n\n    Fields: \n        - dimension (int): Phase space dimension n \n        - symbolic_set (syp.Set | None): Optional SymPy set representation \n        - constraint (Callable | None): Optional callable for fast membership testing\n\n    Note: At least one of symbolic_set or constraint must be provided, or a ValueError will be raised.\n    \"\"\"\n    dimension: int\n    symbolic_set: Optional[syp.Set] = None\n    constraint: Optional[Callable[[NDArray[np.float64]], bool]] = None\n\n\n        ### --- Construction --- ###\n\n\n    ## __init__ autogenerated by @dataclass decorator\n\n    def __post_init__(\n        self\n    ):\n        \"\"\"\n        Post-construction Validation:   \n\n        Raises: \n            ValueError: If both symbolic_set and constraint are None\n        \"\"\"\n        if self.symbolic_set is None and self.constraint is None:\n            raise ValueError(\n                \"PhaseSpace requires at least one representation: \"\n                \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n            )\n\n        if self.constraint is None and self.symbolic_set is not None:\n            # Compile constraint from symbolic set: yields slow containment checks\n            ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n            self.constraint = self._compile_constraint() \n\n\n        ### --- Factory Methods --- ###\n\n\n    @classmethod\n    def full(cls, dimension: int) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = R^n (full Euclidean space).\n\n        - The phase space of choice for unconstrained systems. \n        - Provides both symbolic representation and optimized constraint, optimal performance (o(1) membership testing)\n\n        Args:\n            dimension (int): Phase space dimension n\n\n        Returns:\n            PhaseSpace instance representing R^n, optimal performance case\n\n        Raises:\n            ValueError: If dimension is not positive\n        \"\"\"\n        if dimension &lt;= 0:\n            raise ValueError(f\"Dimension must be positive, got dimension: {dimension}\")\n        symbolic = syp.Reals ** dimension\n        constraint = lambda x: True # Provide constraint directly to avoid compilation overhead\n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n\n\n    @classmethod\n    def box(cls, bounds: NDArray[np.float64]) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = [a_1, b_1] x ... x [a_n, b_n] (box-space constructor).\n\n        - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n            - Symbolic representation is a sympy.sets.ProductSet of sympy.Interval instances. \n        - Dimension is inferred from the bounds array.\n\n        Args:\n            bounds: Array of shape (n, 2) with [[a_1, b_1], ..., [a_n, b_n]]\n\n        Returns:\n            PhaseSpace with box constraints and optimal performance\n\n        Raises:\n            ValueError: If bounds is not a numpy array of shape (n, 2) for n &gt;= 1\n            ValueError: If any i is s.t. b_i &lt;= a_i\n            TypeError: If bounds is not a numpy array of type float64\n        \"\"\"\n        if bounds.ndim != 2 or bounds.shape[1] != 2 or bounds.shape[0] &lt; 1:\n            raise ValueError(f\"Bounds must be a numpy array of shape (n, 2) for n &gt;= 1, got {bounds.shape}\")\n        if np.any(bounds[:, 0] &gt;= bounds[:, 1]):\n            raise ValueError(f\"For all i, b_i must be greater than a_i, got bounds: {bounds}\")\n        if bounds.dtype != np.float64:\n            raise TypeError(\n                f\"Center must be a numpy array of type float64, got center: {bounds.dtype}\\n\"\n                \"Use numpy.array(bounds, dtype=np.float64) to convert to float64\"\n            )\n\n        dimension = bounds.shape[0]\n        intervals = [syp.Interval(bounds[i, 0], bounds[i, 1]) for i in range(dimension)]\n        symbolic = ProductSet(*intervals)\n\n        # Provide pre-compiled constraint for performance: 2*dimension comparisons (O(dimension))\n        box_constraint = lambda x: bool(np.all((x &gt;= bounds[:, 0]) &amp; (x &lt;= bounds[:, 1])))\n\n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=box_constraint)\n\n\n    @classmethod\n    def closed_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = {x in R^n : ||x - center|| &lt;= radius} (sphere constructor).\n\n        - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n            - Symbolic representation is a sympy.sets.Ball instance.\n        - Dimension is inferred from the center array.\n\n        Args:\n            center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n            radius (float): Radius of the sphere\n\n        Returns:\n            PhaseSpace with closed hypersphere constraints and optimal performance\n\n        Raises:\n            ValueError: If radius &lt;= 0\n            ValueError: If center is not a numpy array of shape (n,) for some n\n            TypeError: If center is not a numpy array of type float64\n        \"\"\"\n        if radius &lt;= 0:\n            raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n        if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n            raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n        if center.dtype != np.float64:\n            raise TypeError(\n                f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n                \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n            )\n\n        dimension = center.shape[0]\n        R_n = syp.Reals ** dimension\n        x = syp.symbols(f'x0:{dimension}', real=True)\n        squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n        symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt;= radius**2, R_n)\n\n        # Constraint is O(dimension) \n            ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n        closed_hypersphere_constraint = lambda x: bool(np.linalg.norm(x - center) &lt;= radius) \n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=closed_hypersphere_constraint)\n\n\n    @classmethod\n    def open_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = {x in R^n : ||x - center|| &lt; radius} (open hypersphere constructor).\n\n        - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n            - Symbolic representation is a sympy.sets.Ball instance.\n        - Dimension is inferred from the center array.\n        - Sympy ConditionSet is used to represent the open hypersphere, allowing for set-theoretic operation support.\n\n        Args:\n            center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n            radius (float): Radius of the sphere\n\n        Returns:\n            PhaseSpace with open hypersphere constraints and optimal performance\n\n        Raises:\n            ValueError: If radius &lt;= 0\n            ValueError: If center is not a numpy array of shape (n,) for some n\n            TypeError: If center is not a numpy array of type float64\n        \"\"\"\n        if radius &lt;= 0:\n            raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n        if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n            raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n        if center.dtype != np.float64:\n            raise TypeError(\n                f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n                \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n            )\n\n        dimension = center.shape[0]\n        R_n = syp.Reals ** dimension\n        x = syp.symbols(f'x0:{dimension}', real=True)\n        squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n        symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt; radius**2, R_n)\n\n        # Constraint is O(dimension) \n            ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n        constraint = lambda x: bool(np.linalg.norm(x - center) &lt; radius)\n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n\n\n    ### --- Public Methods --- ### \n\n\n    def contains_point(self, x: NDArray[np.float64]) -&gt; bool:\n        \"\"\"\n        Check if x in X using given callable constraint, if provided, if not deferring to compiled constraint (slow).\n\n        Args:\n            x (NDArray[np.float64]): Point in R^n to test\n\n        Returns:\n            bool: True if x in X, False otherwise\n\n        Raises:\n            AssertionError: If constraint is not set in __post_init__\n            ValueError: x is not a numpy array of shape (n,)     \n\n        \"\"\"\n        assert self.constraint is not None, \"Constraint should be set in __post_init__\"\n        if x.shape != (self.dimension,):\n            raise ValueError(\n                f\"x has incorrect dimension: expected ({self.dimension},), got {x.shape}\"\n            )\n        return self.constraint(x)\n\n\n    def contains_points(self, X: NDArray[np.float64]) -&gt; bool:\n        \"\"\"\n        Check if all points in X are in X using compiled constraint.\n\n        Args:\n            X (NDArray[np.float64]): Points in R^n to test, shape (n_points, n)\n\n        Returns:\n            bool: True if all points in X are in X, False otherwise\n\n        Raises:\n            ValueError: X is not a numpy array of shape (n_points, n)\n        \"\"\"\n        n_points = X.shape[0]\n        if X.shape != (n_points, self.dimension):\n            raise ValueError(\n                f\"X has incorrect shape: expected ({n_points}, {self.dimension}), got {X.shape}\"\n            )\n        return np.all([self.contains_point(x) for x in X])\n\n\n    ### --- Properties --- ### \n\n\n    @property\n    def volume(self) -&gt; float:\n        \"\"\"\n        CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS\n\n        Returns:\n            float: Volume of X\n        \"\"\"\n        raise NotImplementedError(\"Volume is not implemented for PhaseSpace\")\n\n\n    ### --- Dunder Methods --- ### \n\n\n    def __str__(self) -&gt; str: \n        if self.symbolic_set is not None:\n            return str(self.symbolic_set)\n        else: \n            return f\"PhaseSpace(dimension={self.dimension}): No symbolic representation\"\n\n\n    def __repr__(self) -&gt; str: \n        symbolic_repr = repr(self.symbolic_set) if self.symbolic_set is not None else \"None\"\n        constraint_name = None\n        if self.constraint is not None:\n            constraint_name = getattr(self.constraint, \"__name__\", self.constraint.__class__.__name__)\n        return (\n            f\"PhaseSpace(dimension={self.dimension}, \"\n            f\"symbolic_set={symbolic_repr}, \"\n            f\"constraint={constraint_name})\"\n        )\n\n\n    def __eq__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        # Equality iff mutual subset\n        left = self._subseteq(other)\n        if left is False:\n            return False\n        right = other._subseteq(self)\n        return bool(left and right)\n\n\n    def __ne__(self, other: 'PhaseSpace') -&gt; bool:\n        eq = self.__eq__(other)\n        if eq is NotImplemented:  # type: ignore[comparison-overlap]\n            return NotImplemented  # type: ignore[return-value]\n        return not eq\n\n\n    def __lt__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        le = self._subseteq(other)\n        if le is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __le__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        return self._subseteq(other)\n\n\n    def __gt__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        ge = other._subseteq(self)\n        if ge is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __ge__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        return other._subseteq(self)\n\n\n    ### --- Private Methods --- ### \n\n\n    def _compile_constraint(self) -&gt; Callable[[NDArray[np.float64]], bool]:\n        \"\"\"\n        Compile symbolic set to callable for fast numerical membership testing.\n\n        Only called when symbolic_set is provided but constraint is not.\n\n        Strategy:\n        - For R^n (unbounded): return lambda x: True (no constraint)\n        - For ProductSets of Intervals: extract bounds, compile to numpy checks\n        - For general sets: use sympy's contains (slow, but general)\n\n        Raises:\n            AssertionError: If symbolic_set is None (should never happen)\n        \"\"\"\n        assert self.symbolic_set is not None, \"Cannot compile constraint without symbolic_set\"\n\n        # Special case: R^n (ProductSet of Reals or Reals**n)\n        if self._is_full_euclidean_space():\n            return lambda x: True\n\n        # Special case: ProductSet of Intervals \u2192 box constraints\n        if isinstance(self.symbolic_set, ProductSet):\n            bounds = self._extract_box_bounds()\n            if bounds is not None:\n                def box_constraint(x: NDArray[np.float64]) -&gt; bool:\n                    return bool(np.all((x &gt;= bounds[:, 0]) &amp; (x &lt;= bounds[:, 1])))\n                return box_constraint\n\n        # General case: use sympy (slow)\n        # Prefer set.contains(Tuple(...)) over geometric Point for generic sets\n        def symbolic_constraint(x: NDArray[np.float64]) -&gt; bool:\n            try:\n                values = [syp.Float(float(v)) for v in x]\n                elem = syp.Tuple(*values)\n                contains_expr = self.symbolic_set.contains(elem)\n                # SymPy returns a Boolean or a symbolic expression; coerce if possible\n                return bool(contains_expr)\n            except Exception:\n                return False\n\n        return symbolic_constraint\n\n\n    def _is_full_euclidean_space(self) -&gt; bool:\n        \"\"\"\n        Check if symbolic set represents R^n.\n\n        Returns False if symbolic_set is None.\n        \"\"\"\n        if self.symbolic_set is None:\n            return False\n\n        if isinstance(self.symbolic_set, ProductSet):\n            return all(s == syp.Reals for s in self.symbolic_set.args)\n        # Also check for Reals**n notation\n        if hasattr(self.symbolic_set, 'base') and hasattr(self.symbolic_set, 'exp'):\n            return self.symbolic_set.base == syp.Reals and self.symbolic_set.exp == self.dimension\n        return False\n\n\n    def _extract_box_bounds(self) -&gt; Optional[NDArray[np.float64]]:\n        \"\"\"\n        Extract box bounds from ProductSet of Intervals.\n\n        Returns:\n            Array of shape (n, 2) with [[a1, b1], ..., [an, bn]], or None\n            if not a product of intervals or if symbolic_set is None.\n        \"\"\"\n        if self.symbolic_set is None or not isinstance(self.symbolic_set, ProductSet):\n            return None\n\n        bounds = []\n        for component_set in self.symbolic_set.args:\n            if isinstance(component_set, syp.Interval):\n                a = float(component_set.start) if component_set.start.is_finite else -np.inf\n                b = float(component_set.end) if component_set.end.is_finite else np.inf\n                bounds.append([a, b])\n            elif component_set == syp.Reals:\n                bounds.append([-np.inf, np.inf])\n            else:\n                return None  # Not a simple interval\n\n        return np.array(bounds, dtype=np.float64)\n\n\n    def _subseteq(self, other: \"PhaseSpace\"):\n        \"\"\"\n        Check if self is a subset of other using symbolic set containment.\n\n        Args:\n            other (PhaseSpace): The other PhaseSpace to compare against\n\n        Returns:\n            bool: True if self is a subset of other, False otherwise\n\n        Raises:\n            ValueError: If self or other has no symbolic representation\n            Warning: If subset relation is undecidable symbolically, falling back to false result\n        \"\"\"\n        A, B = self.symbolic_set, other.symbolic_set\n        if A is None or B is None:\n            raise ValueError(f\"Cannot compare PhaseSpaces with no symbolic representation: A={A}, B={B}\")\n        res = A.is_subset(B)\n        if res is not None:\n            return res\n        warnings.warn(\n        f\"Subset relation is undecidable symbolically; falling back to false result: Tried A &lt;= B\"\n        \"where A: {A}, B: {B}\"\n        )\n        return False\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.volume","title":"<code>volume</code>  <code>property</code>","text":"<p>CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Volume of X</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-construction Validation:   </p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both symbolic_set and constraint are None</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>def __post_init__(\n    self\n):\n    \"\"\"\n    Post-construction Validation:   \n\n    Raises: \n        ValueError: If both symbolic_set and constraint are None\n    \"\"\"\n    if self.symbolic_set is None and self.constraint is None:\n        raise ValueError(\n            \"PhaseSpace requires at least one representation: \"\n            \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n        )\n\n    if self.constraint is None and self.symbolic_set is not None:\n        # Compile constraint from symbolic set: yields slow containment checks\n        ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n        self.constraint = self._compile_constraint() \n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.box","title":"<code>box(bounds)</code>  <code>classmethod</code>","text":"<p>Factory: X = [a_1, b_1] x ... x [a_n, b_n] (box-space constructor).</p> <ul> <li>Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.<ul> <li>Symbolic representation is a sympy.sets.ProductSet of sympy.Interval instances. </li> </ul> </li> <li>Dimension is inferred from the bounds array.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>NDArray[float64]</code> <p>Array of shape (n, 2) with [[a_1, b_1], ..., [a_n, b_n]]</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace with box constraints and optimal performance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If bounds is not a numpy array of shape (n, 2) for n &gt;= 1</p> <code>ValueError</code> <p>If any i is s.t. b_i &lt;= a_i</p> <code>TypeError</code> <p>If bounds is not a numpy array of type float64</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef box(cls, bounds: NDArray[np.float64]) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = [a_1, b_1] x ... x [a_n, b_n] (box-space constructor).\n\n    - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n        - Symbolic representation is a sympy.sets.ProductSet of sympy.Interval instances. \n    - Dimension is inferred from the bounds array.\n\n    Args:\n        bounds: Array of shape (n, 2) with [[a_1, b_1], ..., [a_n, b_n]]\n\n    Returns:\n        PhaseSpace with box constraints and optimal performance\n\n    Raises:\n        ValueError: If bounds is not a numpy array of shape (n, 2) for n &gt;= 1\n        ValueError: If any i is s.t. b_i &lt;= a_i\n        TypeError: If bounds is not a numpy array of type float64\n    \"\"\"\n    if bounds.ndim != 2 or bounds.shape[1] != 2 or bounds.shape[0] &lt; 1:\n        raise ValueError(f\"Bounds must be a numpy array of shape (n, 2) for n &gt;= 1, got {bounds.shape}\")\n    if np.any(bounds[:, 0] &gt;= bounds[:, 1]):\n        raise ValueError(f\"For all i, b_i must be greater than a_i, got bounds: {bounds}\")\n    if bounds.dtype != np.float64:\n        raise TypeError(\n            f\"Center must be a numpy array of type float64, got center: {bounds.dtype}\\n\"\n            \"Use numpy.array(bounds, dtype=np.float64) to convert to float64\"\n        )\n\n    dimension = bounds.shape[0]\n    intervals = [syp.Interval(bounds[i, 0], bounds[i, 1]) for i in range(dimension)]\n    symbolic = ProductSet(*intervals)\n\n    # Provide pre-compiled constraint for performance: 2*dimension comparisons (O(dimension))\n    box_constraint = lambda x: bool(np.all((x &gt;= bounds[:, 0]) &amp; (x &lt;= bounds[:, 1])))\n\n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=box_constraint)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.closed_hypersphere","title":"<code>closed_hypersphere(center, radius)</code>  <code>classmethod</code>","text":"<p>Factory: X = {x in R^n : ||x - center|| &lt;= radius} (sphere constructor).</p> <ul> <li>Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.<ul> <li>Symbolic representation is a sympy.sets.Ball instance.</li> </ul> </li> <li>Dimension is inferred from the center array.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>NDArray[float64]</code> <p>Array of shape (n,) with the center of the sphere</p> required <code>radius</code> <code>float</code> <p>Radius of the sphere</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace with closed hypersphere constraints and optimal performance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If radius &lt;= 0</p> <code>ValueError</code> <p>If center is not a numpy array of shape (n,) for some n</p> <code>TypeError</code> <p>If center is not a numpy array of type float64</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef closed_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = {x in R^n : ||x - center|| &lt;= radius} (sphere constructor).\n\n    - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n        - Symbolic representation is a sympy.sets.Ball instance.\n    - Dimension is inferred from the center array.\n\n    Args:\n        center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n        radius (float): Radius of the sphere\n\n    Returns:\n        PhaseSpace with closed hypersphere constraints and optimal performance\n\n    Raises:\n        ValueError: If radius &lt;= 0\n        ValueError: If center is not a numpy array of shape (n,) for some n\n        TypeError: If center is not a numpy array of type float64\n    \"\"\"\n    if radius &lt;= 0:\n        raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n    if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n        raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n    if center.dtype != np.float64:\n        raise TypeError(\n            f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n            \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n        )\n\n    dimension = center.shape[0]\n    R_n = syp.Reals ** dimension\n    x = syp.symbols(f'x0:{dimension}', real=True)\n    squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n    symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt;= radius**2, R_n)\n\n    # Constraint is O(dimension) \n        ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n    closed_hypersphere_constraint = lambda x: bool(np.linalg.norm(x - center) &lt;= radius) \n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=closed_hypersphere_constraint)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.contains_point","title":"<code>contains_point(x)</code>","text":"<p>Check if x in X using given callable constraint, if provided, if not deferring to compiled constraint (slow).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float64]</code> <p>Point in R^n to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if x in X, False otherwise</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If constraint is not set in post_init</p> <code>ValueError</code> <p>x is not a numpy array of shape (n,)</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>def contains_point(self, x: NDArray[np.float64]) -&gt; bool:\n    \"\"\"\n    Check if x in X using given callable constraint, if provided, if not deferring to compiled constraint (slow).\n\n    Args:\n        x (NDArray[np.float64]): Point in R^n to test\n\n    Returns:\n        bool: True if x in X, False otherwise\n\n    Raises:\n        AssertionError: If constraint is not set in __post_init__\n        ValueError: x is not a numpy array of shape (n,)     \n\n    \"\"\"\n    assert self.constraint is not None, \"Constraint should be set in __post_init__\"\n    if x.shape != (self.dimension,):\n        raise ValueError(\n            f\"x has incorrect dimension: expected ({self.dimension},), got {x.shape}\"\n        )\n    return self.constraint(x)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.contains_points","title":"<code>contains_points(X)</code>","text":"<p>Check if all points in X are in X using compiled constraint.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>NDArray[float64]</code> <p>Points in R^n to test, shape (n_points, n)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all points in X are in X, False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>X is not a numpy array of shape (n_points, n)</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>def contains_points(self, X: NDArray[np.float64]) -&gt; bool:\n    \"\"\"\n    Check if all points in X are in X using compiled constraint.\n\n    Args:\n        X (NDArray[np.float64]): Points in R^n to test, shape (n_points, n)\n\n    Returns:\n        bool: True if all points in X are in X, False otherwise\n\n    Raises:\n        ValueError: X is not a numpy array of shape (n_points, n)\n    \"\"\"\n    n_points = X.shape[0]\n    if X.shape != (n_points, self.dimension):\n        raise ValueError(\n            f\"X has incorrect shape: expected ({n_points}, {self.dimension}), got {X.shape}\"\n        )\n    return np.all([self.contains_point(x) for x in X])\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.full","title":"<code>full(dimension)</code>  <code>classmethod</code>","text":"<p>Factory: X = R^n (full Euclidean space).</p> <ul> <li>The phase space of choice for unconstrained systems. </li> <li>Provides both symbolic representation and optimized constraint, optimal performance (o(1) membership testing)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>Phase space dimension n</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace instance representing R^n, optimal performance case</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimension is not positive</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef full(cls, dimension: int) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = R^n (full Euclidean space).\n\n    - The phase space of choice for unconstrained systems. \n    - Provides both symbolic representation and optimized constraint, optimal performance (o(1) membership testing)\n\n    Args:\n        dimension (int): Phase space dimension n\n\n    Returns:\n        PhaseSpace instance representing R^n, optimal performance case\n\n    Raises:\n        ValueError: If dimension is not positive\n    \"\"\"\n    if dimension &lt;= 0:\n        raise ValueError(f\"Dimension must be positive, got dimension: {dimension}\")\n    symbolic = syp.Reals ** dimension\n    constraint = lambda x: True # Provide constraint directly to avoid compilation overhead\n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.PhaseSpace.open_hypersphere","title":"<code>open_hypersphere(center, radius)</code>  <code>classmethod</code>","text":"<p>Factory: X = {x in R^n : ||x - center|| &lt; radius} (open hypersphere constructor).</p> <ul> <li>Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.<ul> <li>Symbolic representation is a sympy.sets.Ball instance.</li> </ul> </li> <li>Dimension is inferred from the center array.</li> <li>Sympy ConditionSet is used to represent the open hypersphere, allowing for set-theoretic operation support.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>NDArray[float64]</code> <p>Array of shape (n,) with the center of the sphere</p> required <code>radius</code> <code>float</code> <p>Radius of the sphere</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace with open hypersphere constraints and optimal performance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If radius &lt;= 0</p> <code>ValueError</code> <p>If center is not a numpy array of shape (n,) for some n</p> <code>TypeError</code> <p>If center is not a numpy array of type float64</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef open_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = {x in R^n : ||x - center|| &lt; radius} (open hypersphere constructor).\n\n    - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n        - Symbolic representation is a sympy.sets.Ball instance.\n    - Dimension is inferred from the center array.\n    - Sympy ConditionSet is used to represent the open hypersphere, allowing for set-theoretic operation support.\n\n    Args:\n        center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n        radius (float): Radius of the sphere\n\n    Returns:\n        PhaseSpace with open hypersphere constraints and optimal performance\n\n    Raises:\n        ValueError: If radius &lt;= 0\n        ValueError: If center is not a numpy array of shape (n,) for some n\n        TypeError: If center is not a numpy array of type float64\n    \"\"\"\n    if radius &lt;= 0:\n        raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n    if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n        raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n    if center.dtype != np.float64:\n        raise TypeError(\n            f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n            \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n        )\n\n    dimension = center.shape[0]\n    R_n = syp.Reals ** dimension\n    x = syp.symbols(f'x0:{dimension}', real=True)\n    squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n    symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt; radius**2, R_n)\n\n    # Constraint is O(dimension) \n        ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n    constraint = lambda x: bool(np.linalg.norm(x - center) &lt; radius)\n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon","title":"<code>TimeHorizon</code>  <code>dataclass</code>","text":"<p>Time horizon T subset of R for non-autonomous systems.</p> <p>Factories: - Unbounded: T = R (default) - Closed Interval: T = [a, b] - Open Interval: T = (a, b) </p> <p>Supports: - Predicate: T = {t : constraint(t) = True}</p> Fields <p>symbolic_set (syp.Set | None): Optional SymPy set representation constraint (Callable[[float], bool] | None): Optional callable for fast membership testing</p> <ul> <li>At least one of symbolic_set or constraint must be provided, or a ValueError will be raised upon construction.</li> </ul> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@dataclass\nclass TimeHorizon:\n    \"\"\"\n    Time horizon T subset of R for non-autonomous systems.\n\n    Factories:\n    - Unbounded: T = R (default)\n    - Closed Interval: T = [a, b]\n    - Open Interval: T = (a, b) \n\n    Supports:\n    - Predicate: T = {t : constraint(t) = True}\n\n    Fields:\n        symbolic_set (syp.Set | None): Optional SymPy set representation\n        constraint (Callable[[float], bool] | None): Optional callable for fast membership testing\n\n    - At least one of symbolic_set or constraint must be provided, or a ValueError will be raised upon construction.\n    \"\"\"\n    symbolic_set: Optional[syp.Set] = None\n    constraint: Optional[Callable[[float], bool]] = None\n\n\n        ### --- Construction --- ###\n\n\n    ## __init__ autogenerated by @dataclass decorator\n\n    def __post_init__(\n        self\n    ):\n        \"\"\"\n        Post-construction Validation:   \n\n        Raises: \n            ValueError: If both symbolic_set and constraint are None\n        \"\"\"\n        if self.symbolic_set is None and self.constraint is None:\n            raise ValueError(\n                \"PhaseSpace requires at least one representation: \"\n                \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n            )\n\n        if self.constraint is None and self.symbolic_set is not None:\n            # Compile constraint from symbolic set: yields slow containment checks\n            ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n            self.constraint = self._compile_constraint() \n\n\n            ### --- Public Methods --- ### \n\n\n    def contains_time(self, t: float) -&gt; bool:\n        \"\"\"\n        Check if t is in T.\n\n        Args:\n            t: Time point to test\n\n        Returns:\n            bool: True if t in T, False otherwise\n        \"\"\"\n        return self.constraint(t)\n\n    def contains_times(self, t: NDArray[np.float64]) -&gt; bool:\n        \"\"\"\n        Check if all times in t are in T.\n\n        Args:\n            t: Times to test\n\n        Returns:\n            bool: True if all times in t are in T, False otherwise\n        \"\"\"\n        return np.all([self.contains_time(t) for t in t])\n\n\n        ### --- Factory Methods --- ### \n\n\n    @classmethod\n    def real_line(cls) -&gt; 'TimeHorizon':\n        \"\"\"\n        Factory: T = R (entire real line).\n\n        This is the DEFAULT time horizon for non-autonomous systems.\n\n        Returns:\n            TimeHorizon representing R\n        \"\"\"\n        return cls(symbolic_set=syp.Reals, constraint=lambda t: True)\n\n    @classmethod\n    def closed_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n        \"\"\"\n        Factory: T = [t_min, t_max] (bounded interval).\n\n        Args:\n            t_min: Lower bound\n            t_max: Upper bound\n\n        Returns:\n            TimeHorizon with interval constraints\n\n        Raises:\n            ValueError: If t_min &gt;= t_max\n        \"\"\"\n        if t_min &gt;= t_max:\n            raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n        return cls(symbolic_set=syp.Interval(t_min, t_max), constraint=lambda t: t_min &lt;= t &lt;= t_max)\n\n    @classmethod\n    def open_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n        \"\"\"\n        Factory: T = (t_min, t_max) (open interval).\n\n        Args:\n            t_min: Lower bound\n            t_max: Upper bound\n        \"\"\"\n        if t_min &gt;= t_max:\n            raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n        return cls(symbolic_set=syp.Interval(t_min, t_max, True, True), constraint=lambda t: t_min &lt; t &lt; t_max)\n\n\n        ### --- Properties --- ### \n\n\n    @property\n    def length(self) -&gt; float:\n        \"\"\"\n        CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS\n\n        Returns:\n            float: Volume of T\n        \"\"\"\n        raise NotImplementedError(\"Length is not implemented for TimeHorizon\")\n\n\n        ### --- Dunder Methods --- ### \n\n\n    def __str__(self) -&gt; str: \n        if self.symbolic_set is not None:\n            return str(self.symbolic_set)\n        else: \n            return f\"TimeHorizon(constraint={self.constraint.__name__}): No symbolic representation\"\n\n\n    def __repr__(self) -&gt; str: \n        return (\n            f\"TimeHorizon(\"\n                f\"symbolic_set={str(self.symbolic_set) if self.symbolic_set is not None else 'None'}, \"\n                f\"constraint={self.constraint.__name__ if self.constraint is not None else 'None'})\"\n        )\n\n\n    def __eq__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        # Equality iff mutual subset\n        left = self._subseteq(other)\n        if left is False:\n            return False\n        right = other._subseteq(self)\n        return bool(left and right)\n\n\n    def __ne__(self, other: 'TimeHorizon') -&gt; bool:\n        eq = self.__eq__(other)\n        if eq is NotImplemented:  # type: ignore[comparison-overlap]\n            return NotImplemented  # type: ignore[return-value]\n        return not eq\n\n\n    def __lt__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        le = self._subseteq(other)\n        if le is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __le__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        return self._subseteq(other)\n\n\n    def __gt__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        ge = other._subseteq(self)\n        if ge is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __ge__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        return other._subseteq(self)  \n\n\n        ### --- Private Methods --- ### \n\n    def _compile_constraint(self) -&gt; Callable[[NDArray[np.float64]], bool]:\n        \"\"\"\n        Compile symbolic set to callable for fast numerical membership testing.\n\n        Only called when symbolic_set is provided but constraint is not.\n\n        Strategy:\n        - For R (unbounded): return lambda x: True (no constraint)\n        - For Intervals: extract bounds, compile to numpy checks\n        - For general sets: use sympy's contains (slow, but general)\n\n        Raises:\n            AssertionError: If symbolic_set is None (should never happen)\n        \"\"\"\n        assert self.symbolic_set is not None, \"Cannot compile constraint without symbolic_set\"\n\n        # Special case: R \n        if self.symbolic_set == syp.Reals:\n            return lambda x: True\n\n        # Special case: Interval\n            ## NOTE: Open/Closed logic not yet implemented. Consumers should be using the factories, \n            ## this is just an emergency fallback.\n        if isinstance(self.symbolic_set, syp.Interval):\n            a = float(self.symbolic_set.start) if self.symbolic_set.start.is_finite else -np.inf\n            b = float(self.symbolic_set.end) if self.symbolic_set.end.is_finite else np.inf\n            return lambda t: a &lt;= t &lt;= b\n\n        # General case: use sympy (slow, potentially problematic)\n        def symbolic_constraint(t: float) -&gt; bool:\n            try:\n                elem = syp.Float(t)\n                contains_expr = self.symbolic_set.contains(elem)\n                # SymPy returns a Boolean or a symbolic expression; coerce if possible\n                return bool(contains_expr)\n            except Exception:\n                return False\n\n        return symbolic_constraint\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon.length","title":"<code>length</code>  <code>property</code>","text":"<p>CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Volume of T</p>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-construction Validation:   </p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both symbolic_set and constraint are None</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>def __post_init__(\n    self\n):\n    \"\"\"\n    Post-construction Validation:   \n\n    Raises: \n        ValueError: If both symbolic_set and constraint are None\n    \"\"\"\n    if self.symbolic_set is None and self.constraint is None:\n        raise ValueError(\n            \"PhaseSpace requires at least one representation: \"\n            \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n        )\n\n    if self.constraint is None and self.symbolic_set is not None:\n        # Compile constraint from symbolic set: yields slow containment checks\n        ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n        self.constraint = self._compile_constraint() \n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon.closed_interval","title":"<code>closed_interval(t_min, t_max)</code>  <code>classmethod</code>","text":"<p>Factory: T = [t_min, t_max] (bounded interval).</p> <p>Parameters:</p> Name Type Description Default <code>t_min</code> <code>float</code> <p>Lower bound</p> required <code>t_max</code> <code>float</code> <p>Upper bound</p> required <p>Returns:</p> Type Description <code>TimeHorizon</code> <p>TimeHorizon with interval constraints</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If t_min &gt;= t_max</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@classmethod\ndef closed_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n    \"\"\"\n    Factory: T = [t_min, t_max] (bounded interval).\n\n    Args:\n        t_min: Lower bound\n        t_max: Upper bound\n\n    Returns:\n        TimeHorizon with interval constraints\n\n    Raises:\n        ValueError: If t_min &gt;= t_max\n    \"\"\"\n    if t_min &gt;= t_max:\n        raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n    return cls(symbolic_set=syp.Interval(t_min, t_max), constraint=lambda t: t_min &lt;= t &lt;= t_max)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon.contains_time","title":"<code>contains_time(t)</code>","text":"<p>Check if t is in T.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time point to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if t in T, False otherwise</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>def contains_time(self, t: float) -&gt; bool:\n    \"\"\"\n    Check if t is in T.\n\n    Args:\n        t: Time point to test\n\n    Returns:\n        bool: True if t in T, False otherwise\n    \"\"\"\n    return self.constraint(t)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon.contains_times","title":"<code>contains_times(t)</code>","text":"<p>Check if all times in t are in T.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NDArray[float64]</code> <p>Times to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all times in t are in T, False otherwise</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>def contains_times(self, t: NDArray[np.float64]) -&gt; bool:\n    \"\"\"\n    Check if all times in t are in T.\n\n    Args:\n        t: Times to test\n\n    Returns:\n        bool: True if all times in t are in T, False otherwise\n    \"\"\"\n    return np.all([self.contains_time(t) for t in t])\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon.open_interval","title":"<code>open_interval(t_min, t_max)</code>  <code>classmethod</code>","text":"<p>Factory: T = (t_min, t_max) (open interval).</p> <p>Parameters:</p> Name Type Description Default <code>t_min</code> <code>float</code> <p>Lower bound</p> required <code>t_max</code> <code>float</code> <p>Upper bound</p> required Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@classmethod\ndef open_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n    \"\"\"\n    Factory: T = (t_min, t_max) (open interval).\n\n    Args:\n        t_min: Lower bound\n        t_max: Upper bound\n    \"\"\"\n    if t_min &gt;= t_max:\n        raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n    return cls(symbolic_set=syp.Interval(t_min, t_max, True, True), constraint=lambda t: t_min &lt; t &lt; t_max)\n</code></pre>"},{"location":"api/core/euclidean/#PyDynSys.core.euclidean.TimeHorizon.real_line","title":"<code>real_line()</code>  <code>classmethod</code>","text":"<p>Factory: T = R (entire real line).</p> <p>This is the DEFAULT time horizon for non-autonomous systems.</p> <p>Returns:</p> Type Description <code>TimeHorizon</code> <p>TimeHorizon representing R</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@classmethod\ndef real_line(cls) -&gt; 'TimeHorizon':\n    \"\"\"\n    Factory: T = R (entire real line).\n\n    This is the DEFAULT time horizon for non-autonomous systems.\n\n    Returns:\n        TimeHorizon representing R\n    \"\"\"\n    return cls(symbolic_set=syp.Reals, constraint=lambda t: True)\n</code></pre>"},{"location":"api/core/euclidean/phase_space/","title":"PhaseSpace","text":"<p>The <code>PhaseSpace</code> class provides a flexible representation of phase spaces (subsets of \\(\\mathbb{R}^n\\)) with both symbolic and callable constraint representations.</p>"},{"location":"api/core/euclidean/phase_space/#example-usage","title":"Example Usage","text":"<p>See the Phase Spaces &amp; Time Horizons example notebook for practical usage examples.</p>"},{"location":"api/core/euclidean/phase_space/#factory-methods","title":"Factory Methods","text":""},{"location":"api/core/euclidean/phase_space/#fulldimension","title":"<code>full(dimension)</code>","text":"<p>Creates a phase space representing R^n (full Euclidean space).</p>"},{"location":"api/core/euclidean/phase_space/#boxbounds","title":"<code>box(bounds)</code>","text":"<p>Creates a box-constrained phase space \\([a_1, b_1] \\times \\cdots \\times [a_n, b_n]\\).</p>"},{"location":"api/core/euclidean/phase_space/#closed_hyperspherecenter-radius","title":"<code>closed_hypersphere(center, radius)</code>","text":"<p>Creates a closed hypersphere \\(\\{{\\bf x} \\in \\mathbb{R}^n \\; : \\; \\lVert {\\bf x} - {\\bf c} \\rVert \\leq r\\}\\).</p>"},{"location":"api/core/euclidean/phase_space/#open_hyperspherecenter-radius","title":"<code>open_hypersphere(center, radius)</code>","text":"<p>Creates an open hypersphere \\(\\{{\\bf x} \\in \\mathbb{R}^n \\; : \\; \\lVert {\\bf x} - {\\bf c} \\rVert &lt; r\\}\\).</p>"},{"location":"api/core/euclidean/phase_space/#exposed-methods","title":"Exposed Methods","text":""},{"location":"api/core/euclidean/phase_space/#contains_pointx","title":"contains_point(x)","text":"<p>Verifies whether the point \\(x \\in \\mathbb{R}^n\\) is in the phase space.</p>"},{"location":"api/core/euclidean/phase_space/#contains_pointsa","title":"contains_points(A)","text":"<p>Verifies whether each point \\(x \\in A \\subset \\mathbb{R}^n\\) is in the phase space.</p>"},{"location":"api/core/euclidean/phase_space/#properties","title":"Properties","text":""},{"location":"api/core/euclidean/phase_space/#volume","title":"volume","text":"<p>Returns either an analytic volume (via the Lebesgue measure) of the phase space, if available, or a numerically estimated volume by considering the volume of a convex hull. Utilises caching to avoid consistent recomputation.</p> <p>NOTE: Currently not implemented - deferred to future versions.</p>"},{"location":"api/core/euclidean/phase_space/#dunder-methods","title":"Dunder Methods","text":"<p>We've implemented, thus far, </p> <ul> <li><code>__str__</code></li> <li><code>__repr__</code></li> <li>The dunders below are experimental. They invoke <code>sympy</code> subset logic, which is frail at best, and automatically fall back to false if <code>sympy</code> cannot determine the relevant relationships. As such, a false result should not be seen as a certainty, whereas a true result can be. </li> <li><code>__eq__</code></li> <li><code>__ne__</code></li> <li><code>__le__</code></li> <li><code>__lt__</code></li> <li><code>__ge__</code></li> <li><code>__gt__</code></li> </ul>"},{"location":"api/core/euclidean/phase_space/#full-docs","title":"Full Docs","text":""},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace","title":"<code>PyDynSys.core.euclidean.phase_space.PhaseSpace</code>  <code>dataclass</code>","text":"<p>Phase space X subset of R^n with flexible symbolic/callable representation. </p> Supports three usage patterns <ol> <li>Symbolic only: Provides symbolic set, constraint auto-compiled (general) </li> <li>Callable only: Provides constraint directly (fast, no symbolic ops) </li> <li>Both (recommended): Provides both for optimal performance (fast + symbolic ops)</li> </ol> Symbolic representation enables <ul> <li>Rigorous mathematical operations (intersections, closures, etc.) </li> <li>Pretty printing for dynamical system descriptors </li> </ul> <p>Callable representation provides O(1) membership testing for numerical work.</p> Fields <ul> <li>dimension (int): Phase space dimension n </li> <li>symbolic_set (syp.Set | None): Optional SymPy set representation </li> <li>constraint (Callable | None): Optional callable for fast membership testing</li> </ul> <p>Note: At least one of symbolic_set or constraint must be provided, or a ValueError will be raised.</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@dataclass\nclass PhaseSpace:\n    \"\"\"\n    Phase space X subset of R^n with flexible symbolic/callable representation. \n\n    Supports three usage patterns: \n        1. Symbolic only: Provides symbolic set, constraint auto-compiled (general) \n        2. Callable only: Provides constraint directly (fast, no symbolic ops) \n        3. Both (recommended): Provides both for optimal performance (fast + symbolic ops)\n\n    Symbolic representation enables: \n        - Rigorous mathematical operations (intersections, closures, etc.) \n        - Pretty printing for dynamical system descriptors \n\n    Callable representation provides O(1) membership testing for numerical work.\n\n    Fields: \n        - dimension (int): Phase space dimension n \n        - symbolic_set (syp.Set | None): Optional SymPy set representation \n        - constraint (Callable | None): Optional callable for fast membership testing\n\n    Note: At least one of symbolic_set or constraint must be provided, or a ValueError will be raised.\n    \"\"\"\n    dimension: int\n    symbolic_set: Optional[syp.Set] = None\n    constraint: Optional[Callable[[NDArray[np.float64]], bool]] = None\n\n\n        ### --- Construction --- ###\n\n\n    ## __init__ autogenerated by @dataclass decorator\n\n    def __post_init__(\n        self\n    ):\n        \"\"\"\n        Post-construction Validation:   \n\n        Raises: \n            ValueError: If both symbolic_set and constraint are None\n        \"\"\"\n        if self.symbolic_set is None and self.constraint is None:\n            raise ValueError(\n                \"PhaseSpace requires at least one representation: \"\n                \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n            )\n\n        if self.constraint is None and self.symbolic_set is not None:\n            # Compile constraint from symbolic set: yields slow containment checks\n            ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n            self.constraint = self._compile_constraint() \n\n\n        ### --- Factory Methods --- ###\n\n\n    @classmethod\n    def full(cls, dimension: int) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = R^n (full Euclidean space).\n\n        - The phase space of choice for unconstrained systems. \n        - Provides both symbolic representation and optimized constraint, optimal performance (o(1) membership testing)\n\n        Args:\n            dimension (int): Phase space dimension n\n\n        Returns:\n            PhaseSpace instance representing R^n, optimal performance case\n\n        Raises:\n            ValueError: If dimension is not positive\n        \"\"\"\n        if dimension &lt;= 0:\n            raise ValueError(f\"Dimension must be positive, got dimension: {dimension}\")\n        symbolic = syp.Reals ** dimension\n        constraint = lambda x: True # Provide constraint directly to avoid compilation overhead\n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n\n\n    @classmethod\n    def box(cls, bounds: NDArray[np.float64]) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = [a_1, b_1] x ... x [a_n, b_n] (box-space constructor).\n\n        - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n            - Symbolic representation is a sympy.sets.ProductSet of sympy.Interval instances. \n        - Dimension is inferred from the bounds array.\n\n        Args:\n            bounds: Array of shape (n, 2) with [[a_1, b_1], ..., [a_n, b_n]]\n\n        Returns:\n            PhaseSpace with box constraints and optimal performance\n\n        Raises:\n            ValueError: If bounds is not a numpy array of shape (n, 2) for n &gt;= 1\n            ValueError: If any i is s.t. b_i &lt;= a_i\n            TypeError: If bounds is not a numpy array of type float64\n        \"\"\"\n        if bounds.ndim != 2 or bounds.shape[1] != 2 or bounds.shape[0] &lt; 1:\n            raise ValueError(f\"Bounds must be a numpy array of shape (n, 2) for n &gt;= 1, got {bounds.shape}\")\n        if np.any(bounds[:, 0] &gt;= bounds[:, 1]):\n            raise ValueError(f\"For all i, b_i must be greater than a_i, got bounds: {bounds}\")\n        if bounds.dtype != np.float64:\n            raise TypeError(\n                f\"Center must be a numpy array of type float64, got center: {bounds.dtype}\\n\"\n                \"Use numpy.array(bounds, dtype=np.float64) to convert to float64\"\n            )\n\n        dimension = bounds.shape[0]\n        intervals = [syp.Interval(bounds[i, 0], bounds[i, 1]) for i in range(dimension)]\n        symbolic = ProductSet(*intervals)\n\n        # Provide pre-compiled constraint for performance: 2*dimension comparisons (O(dimension))\n        box_constraint = lambda x: bool(np.all((x &gt;= bounds[:, 0]) &amp; (x &lt;= bounds[:, 1])))\n\n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=box_constraint)\n\n\n    @classmethod\n    def closed_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = {x in R^n : ||x - center|| &lt;= radius} (sphere constructor).\n\n        - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n            - Symbolic representation is a sympy.sets.Ball instance.\n        - Dimension is inferred from the center array.\n\n        Args:\n            center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n            radius (float): Radius of the sphere\n\n        Returns:\n            PhaseSpace with closed hypersphere constraints and optimal performance\n\n        Raises:\n            ValueError: If radius &lt;= 0\n            ValueError: If center is not a numpy array of shape (n,) for some n\n            TypeError: If center is not a numpy array of type float64\n        \"\"\"\n        if radius &lt;= 0:\n            raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n        if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n            raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n        if center.dtype != np.float64:\n            raise TypeError(\n                f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n                \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n            )\n\n        dimension = center.shape[0]\n        R_n = syp.Reals ** dimension\n        x = syp.symbols(f'x0:{dimension}', real=True)\n        squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n        symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt;= radius**2, R_n)\n\n        # Constraint is O(dimension) \n            ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n        closed_hypersphere_constraint = lambda x: bool(np.linalg.norm(x - center) &lt;= radius) \n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=closed_hypersphere_constraint)\n\n\n    @classmethod\n    def open_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n        \"\"\"\n        Factory: X = {x in R^n : ||x - center|| &lt; radius} (open hypersphere constructor).\n\n        - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n            - Symbolic representation is a sympy.sets.Ball instance.\n        - Dimension is inferred from the center array.\n        - Sympy ConditionSet is used to represent the open hypersphere, allowing for set-theoretic operation support.\n\n        Args:\n            center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n            radius (float): Radius of the sphere\n\n        Returns:\n            PhaseSpace with open hypersphere constraints and optimal performance\n\n        Raises:\n            ValueError: If radius &lt;= 0\n            ValueError: If center is not a numpy array of shape (n,) for some n\n            TypeError: If center is not a numpy array of type float64\n        \"\"\"\n        if radius &lt;= 0:\n            raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n        if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n            raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n        if center.dtype != np.float64:\n            raise TypeError(\n                f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n                \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n            )\n\n        dimension = center.shape[0]\n        R_n = syp.Reals ** dimension\n        x = syp.symbols(f'x0:{dimension}', real=True)\n        squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n        symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt; radius**2, R_n)\n\n        # Constraint is O(dimension) \n            ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n        constraint = lambda x: bool(np.linalg.norm(x - center) &lt; radius)\n        return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n\n\n    ### --- Public Methods --- ### \n\n\n    def contains_point(self, x: NDArray[np.float64]) -&gt; bool:\n        \"\"\"\n        Check if x in X using given callable constraint, if provided, if not deferring to compiled constraint (slow).\n\n        Args:\n            x (NDArray[np.float64]): Point in R^n to test\n\n        Returns:\n            bool: True if x in X, False otherwise\n\n        Raises:\n            AssertionError: If constraint is not set in __post_init__\n            ValueError: x is not a numpy array of shape (n,)     \n\n        \"\"\"\n        assert self.constraint is not None, \"Constraint should be set in __post_init__\"\n        if x.shape != (self.dimension,):\n            raise ValueError(\n                f\"x has incorrect dimension: expected ({self.dimension},), got {x.shape}\"\n            )\n        return self.constraint(x)\n\n\n    def contains_points(self, X: NDArray[np.float64]) -&gt; bool:\n        \"\"\"\n        Check if all points in X are in X using compiled constraint.\n\n        Args:\n            X (NDArray[np.float64]): Points in R^n to test, shape (n_points, n)\n\n        Returns:\n            bool: True if all points in X are in X, False otherwise\n\n        Raises:\n            ValueError: X is not a numpy array of shape (n_points, n)\n        \"\"\"\n        n_points = X.shape[0]\n        if X.shape != (n_points, self.dimension):\n            raise ValueError(\n                f\"X has incorrect shape: expected ({n_points}, {self.dimension}), got {X.shape}\"\n            )\n        return np.all([self.contains_point(x) for x in X])\n\n\n    ### --- Properties --- ### \n\n\n    @property\n    def volume(self) -&gt; float:\n        \"\"\"\n        CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS\n\n        Returns:\n            float: Volume of X\n        \"\"\"\n        raise NotImplementedError(\"Volume is not implemented for PhaseSpace\")\n\n\n    ### --- Dunder Methods --- ### \n\n\n    def __str__(self) -&gt; str: \n        if self.symbolic_set is not None:\n            return str(self.symbolic_set)\n        else: \n            return f\"PhaseSpace(dimension={self.dimension}): No symbolic representation\"\n\n\n    def __repr__(self) -&gt; str: \n        symbolic_repr = repr(self.symbolic_set) if self.symbolic_set is not None else \"None\"\n        constraint_name = None\n        if self.constraint is not None:\n            constraint_name = getattr(self.constraint, \"__name__\", self.constraint.__class__.__name__)\n        return (\n            f\"PhaseSpace(dimension={self.dimension}, \"\n            f\"symbolic_set={symbolic_repr}, \"\n            f\"constraint={constraint_name})\"\n        )\n\n\n    def __eq__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        # Equality iff mutual subset\n        left = self._subseteq(other)\n        if left is False:\n            return False\n        right = other._subseteq(self)\n        return bool(left and right)\n\n\n    def __ne__(self, other: 'PhaseSpace') -&gt; bool:\n        eq = self.__eq__(other)\n        if eq is NotImplemented:  # type: ignore[comparison-overlap]\n            return NotImplemented  # type: ignore[return-value]\n        return not eq\n\n\n    def __lt__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        le = self._subseteq(other)\n        if le is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __le__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        return self._subseteq(other)\n\n\n    def __gt__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        ge = other._subseteq(self)\n        if ge is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __ge__(self, other: 'PhaseSpace') -&gt; bool:\n        if not isinstance(other, PhaseSpace):\n            return NotImplemented  # type: ignore[return-value]\n        return other._subseteq(self)\n\n\n    ### --- Private Methods --- ### \n\n\n    def _compile_constraint(self) -&gt; Callable[[NDArray[np.float64]], bool]:\n        \"\"\"\n        Compile symbolic set to callable for fast numerical membership testing.\n\n        Only called when symbolic_set is provided but constraint is not.\n\n        Strategy:\n        - For R^n (unbounded): return lambda x: True (no constraint)\n        - For ProductSets of Intervals: extract bounds, compile to numpy checks\n        - For general sets: use sympy's contains (slow, but general)\n\n        Raises:\n            AssertionError: If symbolic_set is None (should never happen)\n        \"\"\"\n        assert self.symbolic_set is not None, \"Cannot compile constraint without symbolic_set\"\n\n        # Special case: R^n (ProductSet of Reals or Reals**n)\n        if self._is_full_euclidean_space():\n            return lambda x: True\n\n        # Special case: ProductSet of Intervals \u2192 box constraints\n        if isinstance(self.symbolic_set, ProductSet):\n            bounds = self._extract_box_bounds()\n            if bounds is not None:\n                def box_constraint(x: NDArray[np.float64]) -&gt; bool:\n                    return bool(np.all((x &gt;= bounds[:, 0]) &amp; (x &lt;= bounds[:, 1])))\n                return box_constraint\n\n        # General case: use sympy (slow)\n        # Prefer set.contains(Tuple(...)) over geometric Point for generic sets\n        def symbolic_constraint(x: NDArray[np.float64]) -&gt; bool:\n            try:\n                values = [syp.Float(float(v)) for v in x]\n                elem = syp.Tuple(*values)\n                contains_expr = self.symbolic_set.contains(elem)\n                # SymPy returns a Boolean or a symbolic expression; coerce if possible\n                return bool(contains_expr)\n            except Exception:\n                return False\n\n        return symbolic_constraint\n\n\n    def _is_full_euclidean_space(self) -&gt; bool:\n        \"\"\"\n        Check if symbolic set represents R^n.\n\n        Returns False if symbolic_set is None.\n        \"\"\"\n        if self.symbolic_set is None:\n            return False\n\n        if isinstance(self.symbolic_set, ProductSet):\n            return all(s == syp.Reals for s in self.symbolic_set.args)\n        # Also check for Reals**n notation\n        if hasattr(self.symbolic_set, 'base') and hasattr(self.symbolic_set, 'exp'):\n            return self.symbolic_set.base == syp.Reals and self.symbolic_set.exp == self.dimension\n        return False\n\n\n    def _extract_box_bounds(self) -&gt; Optional[NDArray[np.float64]]:\n        \"\"\"\n        Extract box bounds from ProductSet of Intervals.\n\n        Returns:\n            Array of shape (n, 2) with [[a1, b1], ..., [an, bn]], or None\n            if not a product of intervals or if symbolic_set is None.\n        \"\"\"\n        if self.symbolic_set is None or not isinstance(self.symbolic_set, ProductSet):\n            return None\n\n        bounds = []\n        for component_set in self.symbolic_set.args:\n            if isinstance(component_set, syp.Interval):\n                a = float(component_set.start) if component_set.start.is_finite else -np.inf\n                b = float(component_set.end) if component_set.end.is_finite else np.inf\n                bounds.append([a, b])\n            elif component_set == syp.Reals:\n                bounds.append([-np.inf, np.inf])\n            else:\n                return None  # Not a simple interval\n\n        return np.array(bounds, dtype=np.float64)\n\n\n    def _subseteq(self, other: \"PhaseSpace\"):\n        \"\"\"\n        Check if self is a subset of other using symbolic set containment.\n\n        Args:\n            other (PhaseSpace): The other PhaseSpace to compare against\n\n        Returns:\n            bool: True if self is a subset of other, False otherwise\n\n        Raises:\n            ValueError: If self or other has no symbolic representation\n            Warning: If subset relation is undecidable symbolically, falling back to false result\n        \"\"\"\n        A, B = self.symbolic_set, other.symbolic_set\n        if A is None or B is None:\n            raise ValueError(f\"Cannot compare PhaseSpaces with no symbolic representation: A={A}, B={B}\")\n        res = A.is_subset(B)\n        if res is not None:\n            return res\n        warnings.warn(\n        f\"Subset relation is undecidable symbolically; falling back to false result: Tried A &lt;= B\"\n        \"where A: {A}, B: {B}\"\n        )\n        return False\n</code></pre>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.volume","title":"<code>volume: float</code>  <code>property</code>","text":"<p>CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Volume of X</p>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-construction Validation:   </p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both symbolic_set and constraint are None</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>def __post_init__(\n    self\n):\n    \"\"\"\n    Post-construction Validation:   \n\n    Raises: \n        ValueError: If both symbolic_set and constraint are None\n    \"\"\"\n    if self.symbolic_set is None and self.constraint is None:\n        raise ValueError(\n            \"PhaseSpace requires at least one representation: \"\n            \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n        )\n\n    if self.constraint is None and self.symbolic_set is not None:\n        # Compile constraint from symbolic set: yields slow containment checks\n        ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n        self.constraint = self._compile_constraint() \n</code></pre>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.box","title":"<code>box(bounds: NDArray[np.float64]) -&gt; PhaseSpace</code>  <code>classmethod</code>","text":"<p>Factory: X = [a_1, b_1] x ... x [a_n, b_n] (box-space constructor).</p> <ul> <li>Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.<ul> <li>Symbolic representation is a sympy.sets.ProductSet of sympy.Interval instances. </li> </ul> </li> <li>Dimension is inferred from the bounds array.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>NDArray[float64]</code> <p>Array of shape (n, 2) with [[a_1, b_1], ..., [a_n, b_n]]</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace with box constraints and optimal performance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If bounds is not a numpy array of shape (n, 2) for n &gt;= 1</p> <code>ValueError</code> <p>If any i is s.t. b_i &lt;= a_i</p> <code>TypeError</code> <p>If bounds is not a numpy array of type float64</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef box(cls, bounds: NDArray[np.float64]) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = [a_1, b_1] x ... x [a_n, b_n] (box-space constructor).\n\n    - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n        - Symbolic representation is a sympy.sets.ProductSet of sympy.Interval instances. \n    - Dimension is inferred from the bounds array.\n\n    Args:\n        bounds: Array of shape (n, 2) with [[a_1, b_1], ..., [a_n, b_n]]\n\n    Returns:\n        PhaseSpace with box constraints and optimal performance\n\n    Raises:\n        ValueError: If bounds is not a numpy array of shape (n, 2) for n &gt;= 1\n        ValueError: If any i is s.t. b_i &lt;= a_i\n        TypeError: If bounds is not a numpy array of type float64\n    \"\"\"\n    if bounds.ndim != 2 or bounds.shape[1] != 2 or bounds.shape[0] &lt; 1:\n        raise ValueError(f\"Bounds must be a numpy array of shape (n, 2) for n &gt;= 1, got {bounds.shape}\")\n    if np.any(bounds[:, 0] &gt;= bounds[:, 1]):\n        raise ValueError(f\"For all i, b_i must be greater than a_i, got bounds: {bounds}\")\n    if bounds.dtype != np.float64:\n        raise TypeError(\n            f\"Center must be a numpy array of type float64, got center: {bounds.dtype}\\n\"\n            \"Use numpy.array(bounds, dtype=np.float64) to convert to float64\"\n        )\n\n    dimension = bounds.shape[0]\n    intervals = [syp.Interval(bounds[i, 0], bounds[i, 1]) for i in range(dimension)]\n    symbolic = ProductSet(*intervals)\n\n    # Provide pre-compiled constraint for performance: 2*dimension comparisons (O(dimension))\n    box_constraint = lambda x: bool(np.all((x &gt;= bounds[:, 0]) &amp; (x &lt;= bounds[:, 1])))\n\n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=box_constraint)\n</code></pre>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.closed_hypersphere","title":"<code>closed_hypersphere(center: NDArray[np.float64], radius: float) -&gt; PhaseSpace</code>  <code>classmethod</code>","text":"<p>Factory: X = {x in R^n : ||x - center|| &lt;= radius} (sphere constructor).</p> <ul> <li>Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.<ul> <li>Symbolic representation is a sympy.sets.Ball instance.</li> </ul> </li> <li>Dimension is inferred from the center array.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>NDArray[float64]</code> <p>Array of shape (n,) with the center of the sphere</p> required <code>radius</code> <code>float</code> <p>Radius of the sphere</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace with closed hypersphere constraints and optimal performance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If radius &lt;= 0</p> <code>ValueError</code> <p>If center is not a numpy array of shape (n,) for some n</p> <code>TypeError</code> <p>If center is not a numpy array of type float64</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef closed_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = {x in R^n : ||x - center|| &lt;= radius} (sphere constructor).\n\n    - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n        - Symbolic representation is a sympy.sets.Ball instance.\n    - Dimension is inferred from the center array.\n\n    Args:\n        center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n        radius (float): Radius of the sphere\n\n    Returns:\n        PhaseSpace with closed hypersphere constraints and optimal performance\n\n    Raises:\n        ValueError: If radius &lt;= 0\n        ValueError: If center is not a numpy array of shape (n,) for some n\n        TypeError: If center is not a numpy array of type float64\n    \"\"\"\n    if radius &lt;= 0:\n        raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n    if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n        raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n    if center.dtype != np.float64:\n        raise TypeError(\n            f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n            \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n        )\n\n    dimension = center.shape[0]\n    R_n = syp.Reals ** dimension\n    x = syp.symbols(f'x0:{dimension}', real=True)\n    squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n    symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt;= radius**2, R_n)\n\n    # Constraint is O(dimension) \n        ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n    closed_hypersphere_constraint = lambda x: bool(np.linalg.norm(x - center) &lt;= radius) \n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=closed_hypersphere_constraint)\n</code></pre>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.contains_point","title":"<code>contains_point(x: NDArray[np.float64]) -&gt; bool</code>","text":"<p>Check if x in X using given callable constraint, if provided, if not deferring to compiled constraint (slow).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float64]</code> <p>Point in R^n to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if x in X, False otherwise</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If constraint is not set in post_init</p> <code>ValueError</code> <p>x is not a numpy array of shape (n,)</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>def contains_point(self, x: NDArray[np.float64]) -&gt; bool:\n    \"\"\"\n    Check if x in X using given callable constraint, if provided, if not deferring to compiled constraint (slow).\n\n    Args:\n        x (NDArray[np.float64]): Point in R^n to test\n\n    Returns:\n        bool: True if x in X, False otherwise\n\n    Raises:\n        AssertionError: If constraint is not set in __post_init__\n        ValueError: x is not a numpy array of shape (n,)     \n\n    \"\"\"\n    assert self.constraint is not None, \"Constraint should be set in __post_init__\"\n    if x.shape != (self.dimension,):\n        raise ValueError(\n            f\"x has incorrect dimension: expected ({self.dimension},), got {x.shape}\"\n        )\n    return self.constraint(x)\n</code></pre>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.contains_points","title":"<code>contains_points(X: NDArray[np.float64]) -&gt; bool</code>","text":"<p>Check if all points in X are in X using compiled constraint.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>NDArray[float64]</code> <p>Points in R^n to test, shape (n_points, n)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all points in X are in X, False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>X is not a numpy array of shape (n_points, n)</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>def contains_points(self, X: NDArray[np.float64]) -&gt; bool:\n    \"\"\"\n    Check if all points in X are in X using compiled constraint.\n\n    Args:\n        X (NDArray[np.float64]): Points in R^n to test, shape (n_points, n)\n\n    Returns:\n        bool: True if all points in X are in X, False otherwise\n\n    Raises:\n        ValueError: X is not a numpy array of shape (n_points, n)\n    \"\"\"\n    n_points = X.shape[0]\n    if X.shape != (n_points, self.dimension):\n        raise ValueError(\n            f\"X has incorrect shape: expected ({n_points}, {self.dimension}), got {X.shape}\"\n        )\n    return np.all([self.contains_point(x) for x in X])\n</code></pre>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.full","title":"<code>full(dimension: int) -&gt; PhaseSpace</code>  <code>classmethod</code>","text":"<p>Factory: X = R^n (full Euclidean space).</p> <ul> <li>The phase space of choice for unconstrained systems. </li> <li>Provides both symbolic representation and optimized constraint, optimal performance (o(1) membership testing)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>Phase space dimension n</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace instance representing R^n, optimal performance case</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimension is not positive</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef full(cls, dimension: int) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = R^n (full Euclidean space).\n\n    - The phase space of choice for unconstrained systems. \n    - Provides both symbolic representation and optimized constraint, optimal performance (o(1) membership testing)\n\n    Args:\n        dimension (int): Phase space dimension n\n\n    Returns:\n        PhaseSpace instance representing R^n, optimal performance case\n\n    Raises:\n        ValueError: If dimension is not positive\n    \"\"\"\n    if dimension &lt;= 0:\n        raise ValueError(f\"Dimension must be positive, got dimension: {dimension}\")\n    symbolic = syp.Reals ** dimension\n    constraint = lambda x: True # Provide constraint directly to avoid compilation overhead\n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n</code></pre>"},{"location":"api/core/euclidean/phase_space/#PyDynSys.core.euclidean.phase_space.PhaseSpace.open_hypersphere","title":"<code>open_hypersphere(center: NDArray[np.float64], radius: float) -&gt; PhaseSpace</code>  <code>classmethod</code>","text":"<p>Factory: X = {x in R^n : ||x - center|| &lt; radius} (open hypersphere constructor).</p> <ul> <li>Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.<ul> <li>Symbolic representation is a sympy.sets.Ball instance.</li> </ul> </li> <li>Dimension is inferred from the center array.</li> <li>Sympy ConditionSet is used to represent the open hypersphere, allowing for set-theoretic operation support.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>NDArray[float64]</code> <p>Array of shape (n,) with the center of the sphere</p> required <code>radius</code> <code>float</code> <p>Radius of the sphere</p> required <p>Returns:</p> Type Description <code>PhaseSpace</code> <p>PhaseSpace with open hypersphere constraints and optimal performance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If radius &lt;= 0</p> <code>ValueError</code> <p>If center is not a numpy array of shape (n,) for some n</p> <code>TypeError</code> <p>If center is not a numpy array of type float64</p> Source code in <code>src/PyDynSys/core/euclidean/phase_space.py</code> <pre><code>@classmethod\ndef open_hypersphere(cls, center: NDArray[np.float64], radius: float) -&gt; 'PhaseSpace':\n    \"\"\"\n    Factory: X = {x in R^n : ||x - center|| &lt; radius} (open hypersphere constructor).\n\n    - Invokes PhaseSpace constructor with both symbolic representation and in-built callable constraint.\n        - Symbolic representation is a sympy.sets.Ball instance.\n    - Dimension is inferred from the center array.\n    - Sympy ConditionSet is used to represent the open hypersphere, allowing for set-theoretic operation support.\n\n    Args:\n        center (NDArray[np.float64]): Array of shape (n,) with the center of the sphere\n        radius (float): Radius of the sphere\n\n    Returns:\n        PhaseSpace with open hypersphere constraints and optimal performance\n\n    Raises:\n        ValueError: If radius &lt;= 0\n        ValueError: If center is not a numpy array of shape (n,) for some n\n        TypeError: If center is not a numpy array of type float64\n    \"\"\"\n    if radius &lt;= 0:\n        raise ValueError(f\"Radius must be positive, got radius: {radius}\")\n    if center.shape[0] &lt;= 0 or len(center.shape) != 1:\n        raise ValueError(f\"Center must be a numpy array of shape (n,) for some n, got center: {center.shape}\")\n    if center.dtype != np.float64:\n        raise TypeError(\n            f\"Center must be a numpy array of type float64, got center: {center.dtype}\\n\"\n            \"Use numpy.array(center, dtype=np.float64) to convert to float64\"\n        )\n\n    dimension = center.shape[0]\n    R_n = syp.Reals ** dimension\n    x = syp.symbols(f'x0:{dimension}', real=True)\n    squared_dist = sum((x[i] - center[i])**2 for i in range(dimension))\n    symbolic = syp.ConditionSet(syp.Tuple(*x), squared_dist &lt; radius**2, R_n)\n\n    # Constraint is O(dimension) \n        ## TODO: How does np.linalg.norm work? If they sqrt could be slow, squard sum &gt;&gt;\n    constraint = lambda x: bool(np.linalg.norm(x - center) &lt; radius)\n    return cls(dimension=dimension, symbolic_set=symbolic, constraint=constraint)\n</code></pre>"},{"location":"api/core/euclidean/time_horizon/","title":"TimeHorizon","text":"<p>The <code>TimeHorizon</code> class provides a flexible representation of time horizons (subsets of \\(\\mathbb{R}\\)) with both symbolic and callable constraint representations.</p>"},{"location":"api/core/euclidean/time_horizon/#example-usage","title":"Example Usage","text":"<p>See the Phase Spaces &amp; Time Horizons example notebook for practical usage examples.</p>"},{"location":"api/core/euclidean/time_horizon/#factory-methods","title":"Factory Methods","text":""},{"location":"api/core/euclidean/time_horizon/#real_line","title":"<code>real_line()</code>","text":"<p>Creates a time horizon representing \\(\\mathbb{R}\\) (entire real line). This is the default time horizon for non-autonomous systems.</p>"},{"location":"api/core/euclidean/time_horizon/#closed_intervalt_min-t_max","title":"<code>closed_interval(t_min, t_max)</code>","text":"<p>Creates a closed interval time horizon \\([t_{\\min}, t_{\\max}]\\).</p>"},{"location":"api/core/euclidean/time_horizon/#open_intervalt_min-t_max","title":"<code>open_interval(t_min, t_max)</code>","text":"<p>Creates an open interval time horizon \\((t_{\\min}, t_{\\max})\\).</p>"},{"location":"api/core/euclidean/time_horizon/#exposed-methods","title":"Exposed Methods","text":""},{"location":"api/core/euclidean/time_horizon/#contains_timet","title":"contains_time(t)","text":"<p>Verifies whether the time point \\(t \\in \\mathbb{R}\\) is in the time horizon.</p>"},{"location":"api/core/euclidean/time_horizon/#contains_timest","title":"contains_times(t)","text":"<p>Verifies whether each time \\(t \\in T \\subset \\mathbb{R}\\) is in the time horizon.</p>"},{"location":"api/core/euclidean/time_horizon/#properties","title":"Properties","text":""},{"location":"api/core/euclidean/time_horizon/#length","title":"length","text":"<p>Returns either an analytic length (via the Lebesgue measure) of the time horizon, if available, or a numerically estimated length. Utilises caching to avoid consistent recomputation.</p> <p>Note: Currently not implemented - deferred to future versions.</p>"},{"location":"api/core/euclidean/time_horizon/#dunder-methods","title":"Dunder Methods","text":"<p>We've implemented, thus far, </p> <ul> <li><code>__str__</code></li> <li><code>__repr__</code></li> <li>The dunders below are experimental. They invoke <code>sympy</code> subset logic, which is frail at best, and automatically fall back to false if <code>sympy</code> cannot determine the relevant relationships. As such, a false result should not be seen as a certainty, whereas a true result can be. </li> <li><code>__eq__</code></li> <li><code>__ne__</code></li> <li><code>__le__</code></li> <li><code>__lt__</code></li> <li><code>__ge__</code></li> <li><code>__gt__</code></li> </ul>"},{"location":"api/core/euclidean/time_horizon/#full-docs","title":"Full Docs","text":""},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon","title":"<code>PyDynSys.core.euclidean.time_horizon.TimeHorizon</code>  <code>dataclass</code>","text":"<p>Time horizon T subset of R for non-autonomous systems.</p> <p>Factories: - Unbounded: T = R (default) - Closed Interval: T = [a, b] - Open Interval: T = (a, b) </p> <p>Supports: - Predicate: T = {t : constraint(t) = True}</p> Fields <p>symbolic_set (syp.Set | None): Optional SymPy set representation constraint (Callable[[float], bool] | None): Optional callable for fast membership testing</p> <ul> <li>At least one of symbolic_set or constraint must be provided, or a ValueError will be raised upon construction.</li> </ul> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@dataclass\nclass TimeHorizon:\n    \"\"\"\n    Time horizon T subset of R for non-autonomous systems.\n\n    Factories:\n    - Unbounded: T = R (default)\n    - Closed Interval: T = [a, b]\n    - Open Interval: T = (a, b) \n\n    Supports:\n    - Predicate: T = {t : constraint(t) = True}\n\n    Fields:\n        symbolic_set (syp.Set | None): Optional SymPy set representation\n        constraint (Callable[[float], bool] | None): Optional callable for fast membership testing\n\n    - At least one of symbolic_set or constraint must be provided, or a ValueError will be raised upon construction.\n    \"\"\"\n    symbolic_set: Optional[syp.Set] = None\n    constraint: Optional[Callable[[float], bool]] = None\n\n\n        ### --- Construction --- ###\n\n\n    ## __init__ autogenerated by @dataclass decorator\n\n    def __post_init__(\n        self\n    ):\n        \"\"\"\n        Post-construction Validation:   \n\n        Raises: \n            ValueError: If both symbolic_set and constraint are None\n        \"\"\"\n        if self.symbolic_set is None and self.constraint is None:\n            raise ValueError(\n                \"PhaseSpace requires at least one representation: \"\n                \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n            )\n\n        if self.constraint is None and self.symbolic_set is not None:\n            # Compile constraint from symbolic set: yields slow containment checks\n            ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n            self.constraint = self._compile_constraint() \n\n\n            ### --- Public Methods --- ### \n\n\n    def contains_time(self, t: float) -&gt; bool:\n        \"\"\"\n        Check if t is in T.\n\n        Args:\n            t: Time point to test\n\n        Returns:\n            bool: True if t in T, False otherwise\n        \"\"\"\n        return self.constraint(t)\n\n    def contains_times(self, t: NDArray[np.float64]) -&gt; bool:\n        \"\"\"\n        Check if all times in t are in T.\n\n        Args:\n            t: Times to test\n\n        Returns:\n            bool: True if all times in t are in T, False otherwise\n        \"\"\"\n        return np.all([self.contains_time(t) for t in t])\n\n\n        ### --- Factory Methods --- ### \n\n\n    @classmethod\n    def real_line(cls) -&gt; 'TimeHorizon':\n        \"\"\"\n        Factory: T = R (entire real line).\n\n        This is the DEFAULT time horizon for non-autonomous systems.\n\n        Returns:\n            TimeHorizon representing R\n        \"\"\"\n        return cls(symbolic_set=syp.Reals, constraint=lambda t: True)\n\n    @classmethod\n    def closed_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n        \"\"\"\n        Factory: T = [t_min, t_max] (bounded interval).\n\n        Args:\n            t_min: Lower bound\n            t_max: Upper bound\n\n        Returns:\n            TimeHorizon with interval constraints\n\n        Raises:\n            ValueError: If t_min &gt;= t_max\n        \"\"\"\n        if t_min &gt;= t_max:\n            raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n        return cls(symbolic_set=syp.Interval(t_min, t_max), constraint=lambda t: t_min &lt;= t &lt;= t_max)\n\n    @classmethod\n    def open_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n        \"\"\"\n        Factory: T = (t_min, t_max) (open interval).\n\n        Args:\n            t_min: Lower bound\n            t_max: Upper bound\n        \"\"\"\n        if t_min &gt;= t_max:\n            raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n        return cls(symbolic_set=syp.Interval(t_min, t_max, True, True), constraint=lambda t: t_min &lt; t &lt; t_max)\n\n\n        ### --- Properties --- ### \n\n\n    @property\n    def length(self) -&gt; float:\n        \"\"\"\n        CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS\n\n        Returns:\n            float: Volume of T\n        \"\"\"\n        raise NotImplementedError(\"Length is not implemented for TimeHorizon\")\n\n\n        ### --- Dunder Methods --- ### \n\n\n    def __str__(self) -&gt; str: \n        if self.symbolic_set is not None:\n            return str(self.symbolic_set)\n        else: \n            return f\"TimeHorizon(constraint={self.constraint.__name__}): No symbolic representation\"\n\n\n    def __repr__(self) -&gt; str: \n        return (\n            f\"TimeHorizon(\"\n                f\"symbolic_set={str(self.symbolic_set) if self.symbolic_set is not None else 'None'}, \"\n                f\"constraint={self.constraint.__name__ if self.constraint is not None else 'None'})\"\n        )\n\n\n    def __eq__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        # Equality iff mutual subset\n        left = self._subseteq(other)\n        if left is False:\n            return False\n        right = other._subseteq(self)\n        return bool(left and right)\n\n\n    def __ne__(self, other: 'TimeHorizon') -&gt; bool:\n        eq = self.__eq__(other)\n        if eq is NotImplemented:  # type: ignore[comparison-overlap]\n            return NotImplemented  # type: ignore[return-value]\n        return not eq\n\n\n    def __lt__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        le = self._subseteq(other)\n        if le is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __le__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        return self._subseteq(other)\n\n\n    def __gt__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        ge = other._subseteq(self)\n        if ge is False:\n            return False\n        return not self.__eq__(other)\n\n\n    def __ge__(self, other: 'TimeHorizon') -&gt; bool:\n        if not isinstance(other, TimeHorizon):\n            return NotImplemented  # type: ignore[return-value]\n        return other._subseteq(self)  \n\n\n        ### --- Private Methods --- ### \n\n    def _compile_constraint(self) -&gt; Callable[[NDArray[np.float64]], bool]:\n        \"\"\"\n        Compile symbolic set to callable for fast numerical membership testing.\n\n        Only called when symbolic_set is provided but constraint is not.\n\n        Strategy:\n        - For R (unbounded): return lambda x: True (no constraint)\n        - For Intervals: extract bounds, compile to numpy checks\n        - For general sets: use sympy's contains (slow, but general)\n\n        Raises:\n            AssertionError: If symbolic_set is None (should never happen)\n        \"\"\"\n        assert self.symbolic_set is not None, \"Cannot compile constraint without symbolic_set\"\n\n        # Special case: R \n        if self.symbolic_set == syp.Reals:\n            return lambda x: True\n\n        # Special case: Interval\n            ## NOTE: Open/Closed logic not yet implemented. Consumers should be using the factories, \n            ## this is just an emergency fallback.\n        if isinstance(self.symbolic_set, syp.Interval):\n            a = float(self.symbolic_set.start) if self.symbolic_set.start.is_finite else -np.inf\n            b = float(self.symbolic_set.end) if self.symbolic_set.end.is_finite else np.inf\n            return lambda t: a &lt;= t &lt;= b\n\n        # General case: use sympy (slow, potentially problematic)\n        def symbolic_constraint(t: float) -&gt; bool:\n            try:\n                elem = syp.Float(t)\n                contains_expr = self.symbolic_set.contains(elem)\n                # SymPy returns a Boolean or a symbolic expression; coerce if possible\n                return bool(contains_expr)\n            except Exception:\n                return False\n\n        return symbolic_constraint\n</code></pre>"},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon.length","title":"<code>length: float</code>  <code>property</code>","text":"<p>CURRENTLY NOT IMPLEMENTED - DEFERRED TO FUTURE VERSIONS</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Volume of T</p>"},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-construction Validation:   </p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both symbolic_set and constraint are None</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>def __post_init__(\n    self\n):\n    \"\"\"\n    Post-construction Validation:   \n\n    Raises: \n        ValueError: If both symbolic_set and constraint are None\n    \"\"\"\n    if self.symbolic_set is None and self.constraint is None:\n        raise ValueError(\n            \"PhaseSpace requires at least one representation: \"\n            \"symbolic_set (sympy.Set) or constraint (Callable[[NDArray[np.float64]], bool]) must be provided\"\n        )\n\n    if self.constraint is None and self.symbolic_set is not None:\n        # Compile constraint from symbolic set: yields slow containment checks\n        ## NOTE: I'm not actually sure of the time complexity, need to check sympy docs\n        self.constraint = self._compile_constraint() \n</code></pre>"},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon.closed_interval","title":"<code>closed_interval(t_min: float, t_max: float) -&gt; TimeHorizon</code>  <code>classmethod</code>","text":"<p>Factory: T = [t_min, t_max] (bounded interval).</p> <p>Parameters:</p> Name Type Description Default <code>t_min</code> <code>float</code> <p>Lower bound</p> required <code>t_max</code> <code>float</code> <p>Upper bound</p> required <p>Returns:</p> Type Description <code>TimeHorizon</code> <p>TimeHorizon with interval constraints</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If t_min &gt;= t_max</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@classmethod\ndef closed_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n    \"\"\"\n    Factory: T = [t_min, t_max] (bounded interval).\n\n    Args:\n        t_min: Lower bound\n        t_max: Upper bound\n\n    Returns:\n        TimeHorizon with interval constraints\n\n    Raises:\n        ValueError: If t_min &gt;= t_max\n    \"\"\"\n    if t_min &gt;= t_max:\n        raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n    return cls(symbolic_set=syp.Interval(t_min, t_max), constraint=lambda t: t_min &lt;= t &lt;= t_max)\n</code></pre>"},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon.contains_time","title":"<code>contains_time(t: float) -&gt; bool</code>","text":"<p>Check if t is in T.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time point to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if t in T, False otherwise</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>def contains_time(self, t: float) -&gt; bool:\n    \"\"\"\n    Check if t is in T.\n\n    Args:\n        t: Time point to test\n\n    Returns:\n        bool: True if t in T, False otherwise\n    \"\"\"\n    return self.constraint(t)\n</code></pre>"},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon.contains_times","title":"<code>contains_times(t: NDArray[np.float64]) -&gt; bool</code>","text":"<p>Check if all times in t are in T.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NDArray[float64]</code> <p>Times to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all times in t are in T, False otherwise</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>def contains_times(self, t: NDArray[np.float64]) -&gt; bool:\n    \"\"\"\n    Check if all times in t are in T.\n\n    Args:\n        t: Times to test\n\n    Returns:\n        bool: True if all times in t are in T, False otherwise\n    \"\"\"\n    return np.all([self.contains_time(t) for t in t])\n</code></pre>"},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon.open_interval","title":"<code>open_interval(t_min: float, t_max: float) -&gt; TimeHorizon</code>  <code>classmethod</code>","text":"<p>Factory: T = (t_min, t_max) (open interval).</p> <p>Parameters:</p> Name Type Description Default <code>t_min</code> <code>float</code> <p>Lower bound</p> required <code>t_max</code> <code>float</code> <p>Upper bound</p> required Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@classmethod\ndef open_interval(cls, t_min: float, t_max: float) -&gt; 'TimeHorizon':\n    \"\"\"\n    Factory: T = (t_min, t_max) (open interval).\n\n    Args:\n        t_min: Lower bound\n        t_max: Upper bound\n    \"\"\"\n    if t_min &gt;= t_max:\n        raise ValueError(f\"Interval time horizon must have t_min &lt; t_max, got ({t_min}, {t_max})\")\n    return cls(symbolic_set=syp.Interval(t_min, t_max, True, True), constraint=lambda t: t_min &lt; t &lt; t_max)\n</code></pre>"},{"location":"api/core/euclidean/time_horizon/#PyDynSys.core.euclidean.time_horizon.TimeHorizon.real_line","title":"<code>real_line() -&gt; TimeHorizon</code>  <code>classmethod</code>","text":"<p>Factory: T = R (entire real line).</p> <p>This is the DEFAULT time horizon for non-autonomous systems.</p> <p>Returns:</p> Type Description <code>TimeHorizon</code> <p>TimeHorizon representing R</p> Source code in <code>src/PyDynSys/core/euclidean/time_horizon.py</code> <pre><code>@classmethod\ndef real_line(cls) -&gt; 'TimeHorizon':\n    \"\"\"\n    Factory: T = R (entire real line).\n\n    This is the DEFAULT time horizon for non-autonomous systems.\n\n    Returns:\n        TimeHorizon representing R\n    \"\"\"\n    return cls(symbolic_set=syp.Reals, constraint=lambda t: True)\n</code></pre>"},{"location":"api/core/euclidean/trajectory/","title":"Trajectory","text":""},{"location":"api/core/euclidean/trajectory/#full-docs","title":"Full Docs","text":""},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory","title":"<code>PyDynSys.core.euclidean.trajectory.Trajectory</code>","text":"<p>Represents a numerically computed trajectory on a subset of the real line \u211d.</p> <p>A trajectory is a composition of one or more segments with disjoint domains, providing seamless access to the complete solution across potentially non-contiguous time intervals.</p> <p>Key invariant: All segment domains are disjoint (validated in from_segments).</p> Fields <p>segments (List[EuclideanTrajectorySegment]): Trajectory segments in ascending domain order domains (List[Tuple[float, float]]): Domain intervals [t_i, t_{i+1}] in ascending order meta (Dict[str, Any]): Aggregate metadata from all segments</p> Properties <p>t: Concatenated evaluation times from all segments y: Concatenated states from all segments</p> Usage <p>Created via from_segments() factory. Primary user-facing class returned by system.trajectory() method. Provides seamless interpolation across segments.</p> Example <p>sys = AutonomousDS(...) traj = sys.trajectory(x0, t_span=(0, 10), t_eval=np.linspace(0, 10, 100)) x_at_5 = traj.interpolate(5.0)</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>class Trajectory: \n    \"\"\"\n    Represents a numerically computed trajectory on a subset of the real line \u211d.\n\n    A trajectory is a composition of one or more segments with disjoint domains,\n    providing seamless access to the complete solution across potentially\n    non-contiguous time intervals.\n\n    Key invariant: All segment domains are disjoint (validated in from_segments).\n\n    Fields: \n        segments (List[EuclideanTrajectorySegment]): Trajectory segments in ascending domain order\n        domains (List[Tuple[float, float]]): Domain intervals [t_i, t_{i+1}] in ascending order\n        meta (Dict[str, Any]): Aggregate metadata from all segments\n\n    Properties:\n        t: Concatenated evaluation times from all segments\n        y: Concatenated states from all segments\n\n    Usage:\n        Created via from_segments() factory. Primary user-facing class returned by\n        system.trajectory() method. Provides seamless interpolation across segments.\n\n    Example:\n        &gt;&gt;&gt; sys = AutonomousDS(...)\n        &gt;&gt;&gt; traj = sys.trajectory(x0, t_span=(0, 10), t_eval=np.linspace(0, 10, 100))\n        &gt;&gt;&gt; x_at_5 = traj.interpolate(5.0)\n    \"\"\"\n\n\n    ### --- Factory Methods --- ###\n\n\n    @classmethod\n    def from_segments(\n        cls,\n        segments: List[TrajectorySegment],\n        merge_policy: TrajectorySegmentMergePolicy = 'average'  # Default: average overlapping values\n    ) -&gt; 'Trajectory':\n        \"\"\"\n        Factory: Create trajectory from list of segments, merging overlaps if needed.\n\n        MERGE ALGORITHM: Iterative Fixed-Point Approach\n        ------------------------------------------------\n        This method implements an iterative fixed-point algorithm to merge overlapping\n        segments until all domains are disjoint (class invariant).\n\n        Problem: Cascading overlaps require multiple merge passes.\n        Example: Segments [[0,1], [0.5,2], [1,3]] have:\n          - Pass 1: Merge [0,1] + [0.5,2] \u2192 [0,2]\n          - Pass 2: Merge [0,2] + [1,3] \u2192 [0,3]\n\n        Algorithm:\n          1. Sort segments by domain start time (ensures left-to-right processing)\n          2. Fixed-point iteration:\n             a. Scan through current segment list left-to-right\n             b. For each consecutive pair, detect overlap\n             c. If overlap exists, merge the pair and add to result\n             d. If no overlap, add current segment to result\n             e. If any merges occurred, repeat from step 2a\n             f. If no merges occurred, fixed point reached \u2192 done\n\n        Invariant: At each iteration, segments in the working list are sorted by start time.\n        This ensures that after merging two consecutive segments, the merged segment\n        cannot overlap with any previously processed segments (they all ended before\n        the current segment started, by the inductive property of sorted order).\n\n        Termination: Guaranteed because:\n          - Each merge reduces the number of segments by 1\n          - Minimum segments = 1 (fully merged trajectory)\n          - Maximum iterations = n-1 (worst case: chain of n segments)\n\n        Args:\n            segments (List[EuclideanTrajectorySegment]): Segments to compose\n            merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps\n                - 'average' (DEFAULT): Average y values in overlap region\n                - 'left': Use left segment in overlap\n                - 'right': Use right segment in overlap\n                - 'stitch': Left interpolant until midpoint, then right\n\n        Returns:\n            EuclideanTrajectory: Composite trajectory with disjoint segment domains\n\n        Raises:\n            ValueError: If final domains are not disjoint (merging failed)\n            RuntimeError: If merge algorithm fails to converge (indicates bug)\n            NotImplementedError: If merge_policy is not 'average' (others not yet implemented)\n\n        Example:\n            &gt;&gt;&gt; seg1 = TrajectorySegment.from_scipy_solution(sol1, 'RK45')\n            &gt;&gt;&gt; seg2 = TrajectorySegment.from_scipy_solution(sol2, 'RK45')\n            &gt;&gt;&gt; traj = Trajectory.from_segments([seg1, seg2])\n        \"\"\"\n        if not segments:\n            raise ValueError(\"Cannot create trajectory from empty segment list\")\n\n        # Sort segments by domain start time (critical for correct merge order)\n        working_segments = sorted(segments, key=lambda seg: seg.domain[0])\n\n\n        # ITERATIVE FIXED-POINT MERGE ALGORITHM #\n        ## o(num_segments^2) worst case complexity\n        changed = True\n        iteration = 0\n        max_iterations = len(segments)  # Safety limit (should never be reached)\n        while changed and iteration &lt; max_iterations:\n            changed = False\n            merged_segments = []\n            i = 0\n\n            # pass through working segments, merging consecutive overlaps\n            while i &lt; len(working_segments):\n                current = working_segments[i]\n\n                if i + 1 &lt; len(working_segments):\n                    next_seg = working_segments[i + 1]\n                    overlap = cls._detect_overlap(current, next_seg)\n\n                    if overlap is not None:\n                        # Overlapping segments detected - merge them\n                        if merge_policy == 'average':\n                            merged = cls._merge_segments_average(current, next_seg, overlap)\n                            merged_segments.append(merged)\n                            i += 2  # Skip both segments (merged into one)\n                            changed = True  # Mark that we made progress\n                        elif merge_policy == 'left':\n                            merged = cls._merge_segments_left(current, next_seg, overlap)\n                            merged_segments.append(merged)\n                            i += 2  # Skip both segments (merged into one)\n                            changed = True  # Mark that we made progress\n                        elif merge_policy == 'right':\n                            merged = cls._merge_segments_right(current, next_seg, overlap)\n                            merged_segments.append(merged)\n                            i += 2  # Skip both segments (merged into one)\n                            changed = True  # Mark that we made progress\n                        elif merge_policy == 'stitch':\n                            merged = cls._merge_segments_stitch(current, next_seg, overlap)\n                            merged_segments.append(merged)\n                            i += 2  # Skip both segments (merged into one)\n                            changed = True  # Mark that we made progress\n                        else:\n                            raise ValueError(f\"Unknown merge policy: {merge_policy}\")\n                    else:\n                        # Disjoint segments - keep current and move forward\n                        merged_segments.append(current)\n                        i += 1\n                else:\n                    # Last segment - no next segment to check for overlap\n                    merged_segments.append(current)\n                    i += 1\n\n            # Update working list for next iteration (if needed)\n            working_segments = merged_segments\n            iteration += 1\n\n        if iteration &gt;= max_iterations:\n            # This should never happen in practice, but safety check\n            raise RuntimeError(\n                f\"Merge algorithm failed to converge after {max_iterations} iterations. \"\n                f\"This indicates a bug in the merge logic.\"\n            )\n\n        # Final merged segments (guaranteed disjoint by fixed-point property)\n        merged_segments = working_segments\n\n        # Create trajectory instance\n        trajectory = cls()\n        trajectory.segments = merged_segments\n        trajectory.domains = [seg.domain for seg in merged_segments]\n\n        # Aggregate metadata\n        trajectory.meta = {\n            'all_successful': all(seg.meta['success'] for seg in merged_segments),\n            'messages': [seg.meta['message'] for seg in merged_segments],\n            'methods': [seg.method for seg in merged_segments],\n        }\n\n\n        trajectory._validate_disjoint_domains() # Validate disjoint domains (class invariant)\n        return trajectory\n\n\n        ### --- Public Methods --- ###\n\n\n    def merge(\n        self,\n        other: 'Trajectory',\n        merge_policy: TrajectorySegmentMergePolicy = 'average'\n    ) -&gt; 'Trajectory':\n        \"\"\"\n        Join this trajectory with another trajectory.\n\n        Combines segments from both trajectories and merges any overlaps using\n        the specified merge policy. Uses the same iterative fixed-point merge\n        algorithm as from_segments() to handle cascading overlaps.\n\n        Args:\n            other (Trajectory): The other trajectory to join with self\n            merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps\n                - 'average' (DEFAULT): Average y values in overlap region\n                - 'left': Use left segment in overlap\n                - 'right': Use right segment in overlap\n                - 'stitch': Left interpolant until midpoint, then right\n\n        Returns:\n            Trajectory: New trajectory containing all segments from both trajectories,\n                with overlaps merged according to merge_policy\n\n        Raises:\n            ValueError: If final domains are not disjoint (merging failed)\n            RuntimeError: If merge algorithm fails to converge (indicates bug)\n            NotImplementedError: If merge_policy is not 'average' (others not yet implemented)\n\n        Example:\n            &gt;&gt;&gt; traj1 = sys1.trajectory(x0, t_span=(0, 5))\n            &gt;&gt;&gt; traj2 = sys2.trajectory(x1, t_span=(3, 10))\n            &gt;&gt;&gt; combined = traj1.join(traj2)  # Merges overlap in [3, 5]\n        \"\"\"\n        # Combine segments from both trajectories\n        combined_segments = list(self.segments) + list(other.segments)\n\n        # Use from_segments factory to merge overlaps and create new trajectory\n        return Trajectory.from_segments(combined_segments, merge_policy=merge_policy)\n\n    def in_domain(self, t: float) -&gt; bool:\n        \"\"\"\n        Check if time t is within trajectory domain (any segment).\n\n        Args:\n            t (float): Time point to check\n\n        Returns:\n            bool: True if t is in any segment's domain, False otherwise\n        \"\"\"\n        return any(seg.in_domain(t) for seg in self.segments)\n\n    def interpolate(self, t: float) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Seamlessly interpolate trajectory at time t.\n\n        KEY FEATURE: Unified interface across composite trajectories\n        ------------------------------------------------------------\n        This method provides seamless interpolation even when the trajectory is\n        composed of multiple disjoint segments. The user doesn't need to know\n        which segment contains t - we handle the dispatch automatically.\n\n        Example use case:\n          Bidirectional trajectory with domains [(-5, 0], [0, 5]]:\n            traj.interpolate(-3.0) \u2192 dispatches to backward segment\n            traj.interpolate(0.0)  \u2192 dispatches to forward segment (both have it, we pick first)\n            traj.interpolate(3.0)  \u2192 dispatches to forward segment\n            traj.interpolate(10.0) \u2192 raises ValueError (not in any domain)\n\n        Implementation: O(n) linear search through segments (optimize with binary search later)\n\n        Automatically finds the segment containing t and delegates to that segment's\n        interpolant. Provides unified interface across potentially disjoint domains.\n\n        Args:\n            t (float): Time point for evaluation\n\n        Returns:\n            NDArray[np.float64]: State vector x(t) at time t\n\n        Raises:\n            ValueError: If t not in any segment domain\n\n        Example:\n            &gt;&gt;&gt; traj = sys.trajectory(...)  # May have multiple segments\n            &gt;&gt;&gt; x_5 = traj.interpolate(5.0)  # Seamlessly finds right segment\n        \"\"\"\n        segment = self._find_segment_containing(t)\n\n        if segment is None:\n            raise ValueError(\n                f\"Time t={t} not in any segment domain. \"\n                f\"Available domains: {self.domains}\"\n            )\n\n        # This may further raise ValueError if segment has no interpolant (dense_output=False)\n        return segment.interpolate(t)\n\n\n        ### -- Properties --- ###\n\n\n    @property\n    def t(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Concatenated evaluation times from all segments.\n\n        Note: May contain duplicate values at segment boundaries (tangent domains).\n\n        Returns:\n            NDArray[np.float64]: All evaluation times, shape (total_points,)\n        \"\"\"\n        if not self.segments:\n            return np.array([])\n        return np.concatenate([seg.t for seg in self.segments])\n\n    @property\n    def y(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Concatenated states from all segments.\n\n        Returns:\n            NDArray[np.float64]: All states, shape (n_dim, total_points)\n        \"\"\"\n        if not self.segments:\n            return np.array([]).reshape(0, 0)\n        return np.concatenate([seg.y for seg in self.segments], axis=1)\n\n    @property\n    def success(self) -&gt; bool:\n        \"\"\"\n        Whether all segment integrations succeeded.\n\n        Convenience property for backwards compatibility with SciPyIvpSolution.\n\n        Returns:\n            bool: True if all segments successful, False otherwise\n        \"\"\"\n        return self.meta.get('all_successful', True)\n\n    @property\n    def message(self) -&gt; str:\n        \"\"\"\n        Aggregated messages from all segments.\n\n        Convenience property for backwards compatibility with SciPyIvpSolution.\n\n        Returns:\n            str: Combined message from all segments\n        \"\"\"\n        messages = self.meta.get('messages', [])\n        if not messages:\n            return \"No messages\"\n        if len(messages) == 1:\n            return messages[0]\n        return \" | \".join(messages)\n\n\n        ### --- Dunder Methods --- ### \n\n\n    def __str__(self) -&gt; str:\n        return f\"Trajectory(domains={self.domains})\"\n\n    def __repr__(self) -&gt; str:\n        return f\"Trajectory(domains={self.domains})\"\n\n    def __len__(self) -&gt; int:\n        return len(self.segments)\n\n    def __getitem__(self, index: Union[int, slice]) -&gt; Union[TrajectorySegment, List[TrajectorySegment]]:\n        if isinstance(index, slice):\n            return self.segments[index]  \n        return self.segments[index]      \n\n    def __add__(self, other: 'Trajectory') -&gt; 'Trajectory':\n        return self.merge(other)\n\n\n        ### --- Private Methods --- ###\n\n\n    @staticmethod\n    def _detect_overlap(\n        seg1: TrajectorySegment,\n        seg2: TrajectorySegment\n    ) -&gt; Optional[Tuple[float, float]]:\n        \"\"\"\n        Detect if two segments have overlapping domains.\n\n        Args:\n            seg1, seg2: Segments to check (assumed seg1.domain[0] &lt;= seg2.domain[0])\n\n        Returns:\n            Tuple[float, float]: Overlap interval [a, b] if overlap exists, else None\n        \"\"\"\n        # seg1 ends before seg2 starts \u2192 disjoint\n        if seg1.domain[1] &lt;= seg2.domain[0]:\n            return None\n\n        # Overlapping: intersection is [max(starts), min(ends)]\n        overlap_start = max(seg1.domain[0], seg2.domain[0])\n        overlap_end = min(seg1.domain[1], seg2.domain[1])\n\n        return (overlap_start, overlap_end)\n\n    @staticmethod\n    def _create_merged_interpolant(\n        seg1: TrajectorySegment,\n        seg2: TrajectorySegment,\n        overlap: Tuple[float, float],\n        merged_domain: Tuple[float, float]\n    ) -&gt; Optional[Callable[[float], NDArray[np.float64]]]:\n        \"\"\"\n        Create piecewise interpolant for merged segment.\n\n        PIECEWISE DEFINITION:\n        ---------------------\n        For merged segment with overlap [overlap_start, overlap_end]:\n\n        1. Pre-overlap region [seg1.domain[0], overlap_start):\n           c(t) = seg1.interpolant(t)\n\n        2. Overlap region [overlap_start, overlap_end]:\n           c(t) = (seg1.interpolant(t) + seg2.interpolant(t)) / 2\n\n        3. Post-overlap region (overlap_end, seg2.domain[1]]:\n           c(t) = seg2.interpolant(t)\n\n        This matches the discrete averaging policy: where both segments provide\n        values, we average them; elsewhere, we use the single available value.\n\n        Args:\n            seg1, seg2: Overlapping segments (seg1.domain[0] &lt;= seg2.domain[0] assumed)\n            overlap: Overlap interval [overlap_start, overlap_end]\n            merged_domain: Final domain [t_min, t_max] of merged segment\n\n        Returns:\n            Callable interpolant function, or None if either segment lacks interpolant\n        \"\"\"\n        overlap_start, overlap_end = overlap\n        seg1_start, seg1_end = seg1.domain\n        seg2_start, seg2_end = seg2.domain\n        merged_start, merged_end = merged_domain\n\n        # If either segment lacks interpolant, cannot create merged interpolant\n        if seg1.interpolant is None or seg2.interpolant is None:\n            return None\n\n        def merged_interpolant(t: float) -&gt; NDArray[np.float64]:\n            \"\"\"\n            Piecewise merged interpolant evaluating at time t.\n\n            Handles shape normalization for scipy interpolants which may return\n            shape (n_dim,) or (n_dim, 1).\n            \"\"\"         \n            # Helper to normalize scipy interpolant output shape\n            def normalize_result(result: NDArray) -&gt; NDArray[np.float64]:\n                \"\"\"Normalize scipy interpolant output to shape (n_dim,).\"\"\"\n                if result.ndim == 2:\n                    return result[:, 0]\n                return result\n\n            # Region 1: Pre-overlap (only seg1)\n            if seg1_start &lt;= t &lt; overlap_start:\n                result = seg1.interpolant(t)\n                return normalize_result(result)\n\n            # Region 2: Overlap (average both segments)\n            elif overlap_start &lt;= t &lt;= overlap_end:\n                result1 = seg1.interpolant(t)\n                result2 = seg2.interpolant(t)\n                # Normalize shapes, then average\n                result1 = normalize_result(result1)\n                result2 = normalize_result(result2)\n                return (result1 + result2) / 2\n\n            # Region 3: Post-overlap (only seg2)\n            elif overlap_end &lt; t &lt;= seg2_end:\n                result = seg2.interpolant(t)\n                return normalize_result(result)\n\n        return merged_interpolant\n\n    @staticmethod\n    def _merge_segments_average(\n        seg1: TrajectorySegment,\n        seg2: TrajectorySegment,\n        overlap: Tuple[float, float]\n    ) -&gt; TrajectorySegment:\n        \"\"\"\n        Merge two overlapping segments by averaging y values in overlap region.\n\n        MATHEMATICAL CONTEXT:\n        --------------------\n        When we have two numerical approximations of the same trajectory x(t) over\n        overlapping time intervals, we need to reconcile the competing values.\n\n        Example scenario:\n          Segment 1: [0, 1.5] computed with RK45, gives x(1.0) \u2248 0.5403\n          Segment 2: [0.5, 2] computed with DOP853, gives x(1.0) \u2248 0.5404\n\n        In overlap [0.5, 1.5], both segments provide approximations. The 'average'\n        policy takes the midpoint: x_merged(1.0) = (0.5403 + 0.5404)/2 = 0.54035\n\n        This is optimal when both segments have similar accuracy/trust levels.\n\n        Strategy:\n        1. Identify evaluation points in each region (pre-overlap, overlap, post-overlap)\n        2. In overlap: average y values at shared t points (within tolerance 1e-9)\n        3. Concatenate regions to form merged segment\n        4. Interpolant: Create piecewise interpolant matching the averaging policy\n\n        Args:\n            seg1, seg2: Overlapping segments (seg1.domain[0] &lt;= seg2.domain[0] assumed)\n            overlap: Overlap interval [a, b] where both segments are defined\n\n        Returns:\n            TrajectorySegment: Merged segment spanning union of domains\n        \"\"\"\n        overlap_start, overlap_end = overlap\n        tol = 1e-4 # Two points at t1 and t2 are considered \"same\" if |t1 - t2| &lt; 1e-4\n\n        # Split both segments into three regions:\n        #   1. Pre-overlap (only in seg1)\n        #   2. Overlap (in both segments)\n        #   3. Post-overlap (only in seg2)\n        t1_before = seg1.t[seg1.t &lt; overlap_start]\n        y1_before = seg1.y[:, seg1.t &lt; overlap_start]\n        t1_overlap = seg1.t[(seg1.t &gt;= overlap_start) &amp; (seg1.t &lt;= overlap_end)]\n        y1_overlap = seg1.y[:, (seg1.t &gt;= overlap_start) &amp; (seg1.t &lt;= overlap_end)]\n        t2_overlap = seg2.t[(seg2.t &gt;= overlap_start) &amp; (seg2.t &lt;= overlap_end)]\n        y2_overlap = seg2.y[:, (seg2.t &gt;= overlap_start) &amp; (seg2.t &lt;= overlap_end)]\n        t2_after = seg2.t[seg2.t &gt; overlap_end]\n        y2_after = seg2.y[:, seg2.t &gt; overlap_end]\n\n\n        # Merge overlap region by averaging at shared t points\n        ## Strategy: Take union of all t values, average where both exist\n        t_overlap_all = np.unique(np.concatenate([t1_overlap, t2_overlap]))\n        n_dim = seg1.y.shape[0]  # Phase space dimension\n        y_overlap_merged = np.zeros((n_dim, len(t_overlap_all)))\n\n        for i, t_val in enumerate(t_overlap_all):\n            # Check if this time point exists in each segment (within tolerance)\n            in_seg1 = np.any(np.abs(t1_overlap - t_val) &lt; tol)\n            in_seg2 = np.any(np.abs(t2_overlap - t_val) &lt; tol)\n\n            if in_seg1 and in_seg2:\n                # CASE 1: Shared point (exists in both segments)\n                idx1 = np.argmin(np.abs(t1_overlap - t_val))  # Find closest point in seg1\n                idx2 = np.argmin(np.abs(t2_overlap - t_val))  # Find closest point in seg2\n                y_overlap_merged[:, i] = (y1_overlap[:, idx1] + y2_overlap[:, idx2]) / 2\n\n            elif in_seg1:\n                # CASE 2: Only in seg1 (seg2 didn't evaluate here)\n                idx1 = np.argmin(np.abs(t1_overlap - t_val))\n                y_overlap_merged[:, i] = y1_overlap[:, idx1]\n\n            else:\n                # CASE 3: Only in seg2 (seg1 didn't evaluate here)\n                idx2 = np.argmin(np.abs(t2_overlap - t_val))\n                y_overlap_merged[:, i] = y2_overlap[:, idx2]\n\n        # Concatenate all three regions to form the complete merged segment\n        # Order: [pre-overlap from seg1] + [merged overlap] + [post-overlap from seg2]\n        t_merged = np.concatenate([t1_before, t_overlap_all, t2_after])\n        y_merged = np.concatenate([y1_before, y_overlap_merged, y2_after], axis=1)\n\n        # Create merged segment\n        merged = TrajectorySegment()\n        merged.t = t_merged\n        merged.y = y_merged\n        merged.domain = (float(t_merged[0]), float(t_merged[-1]))\n\n        # Create piecewise merged interpolant\n        # Piecewise definition:\n        #   - Pre-overlap: use seg1.interpolant\n        #   - Overlap: average (seg1.interpolant + seg2.interpolant) / 2\n        #   - Post-overlap: use seg2.interpolant\n        # Returns None if either segment lacks interpolant (dense_output=False)\n        merged.interpolant = Trajectory._create_merged_interpolant(\n            seg1, seg2, overlap, merged.domain\n        )\n\n        # Method string indicates multi-method composition\n        # e.g., \"RK45+DOP853\" shows this segment combines two different solvers\n        merged.method = f\"{seg1.method}+{seg2.method}\"\n\n        # Metadata: Aggregate success flags and messages from both segments\n        merged.meta = {\n            'success': seg1.meta['success'] and seg2.meta['success'],\n            'message': f\"Merged: {seg1.meta['message']} | {seg2.meta['message']}\",\n        }\n\n        return merged\n\n    def _merge_segments_stitch(\n        self, \n        seg1: TrajectorySegment, \n        seg2: TrajectorySegment, \n        overlap: Tuple[float, float]\n    ) -&gt; TrajectorySegment:\n        \"\"\"\n        Merge two segments by stitching their interpolants at the overlap point.\n\n        Args:\n            seg1 (TrajectorySegment): First segment\n            seg2 (TrajectorySegment): Second segment\n            overlap (Tuple[float, float]): Overlap interval [a, b]\n        \"\"\"\n        raise NotImplementedError(\"Merge policy 'stitch' not yet implemented for Trajectory class\")\n\n    def _merge_segments_left(\n        self, \n        seg1: TrajectorySegment, \n        seg2: TrajectorySegment, \n        overlap: Tuple[float, float]\n    ) -&gt; TrajectorySegment:\n        \"\"\"\n        Merge two segments by using the left segment's interpolant in the overlap region.\n\n        Args:\n            seg1 (TrajectorySegment): First segment\n            seg2 (TrajectorySegment): Second segment\n            overlap (Tuple[float, float]): Overlap interval [a, b]\n        \"\"\"\n        raise NotImplementedError(\"Merge policy 'left' not yet implemented for Trajectory class\")\n\n    def _merge_segments_right(\n        self, \n        seg1: TrajectorySegment, \n        seg2: TrajectorySegment, \n        overlap: Tuple[float, float]\n    ) -&gt; TrajectorySegment:\n        \"\"\"\n        Merge two segments by using the right segment's interpolant in the overlap region.\n\n        Args:\n            seg1 (TrajectorySegment): First segment\n            seg2 (TrajectorySegment): Second segment\n            overlap (Tuple[float, float]): Overlap interval [a, b]\n        \"\"\"\n        raise NotImplementedError(\"Merge policy 'right' not yet implemented for Trajectory class\")\n\n    def _validate_disjoint_domains(self) -&gt; None:\n        \"\"\"\n        Validate that all segment domains are disjoint (class invariant).\n\n        CLASS INVARIANT:\n        ---------------\n        After merging, all segment domains MUST be disjoint (non-overlapping).\n        This is enforced by:\n          - from_segments(): Detects and merges all overlaps before validation\n          - This method: Final check that merging succeeded\n\n        Mathematically: For domains [a_i, b_i], we require:\n          b_i &lt;= a_{i+1} for all consecutive pairs i, i+1\n\n        Tangent domains ([a,b] and [b,c]) are allowed (b_i = a_{i+1}).\n        Disjoint domains ([a,b] and [c,d] with b &lt; c) are allowed.\n        Overlapping domains ([a,b] and [c,d] with c &lt; b &lt; d) are NOT allowed after merging.\n\n        Checks that domains[i][1] &lt;= domains[i+1][0] for all consecutive pairs.\n        This ensures no overlap remains after merging.\n\n        Raises:\n            ValueError: If any domains overlap (indicates bug in merge logic)\n        \"\"\"\n        for i in range(len(self.domains) - 1):\n            current_end = self.domains[i][1]\n            next_start = self.domains[i + 1][0]\n\n            # Check for overlap: current segment extends past start of next segment\n            if current_end &gt; next_start:\n                raise ValueError(\n                    f\"Segment domains are not disjoint: \"\n                    f\"domain {i} ends at {current_end}, but domain {i+1} starts at {next_start}. \"\n                    f\"Overlapping domains detected after merging. This is a bug in merge logic.\"\n                )\n\n    def _find_segment_containing(self, t: float) -&gt; Optional[TrajectorySegment]:\n        \"\"\"\n        Find segment whose domain contains time t.\n\n        Uses linear search (optimize with binary search later if needed).\n\n        Args:\n            t (float): Time point to locate\n\n        Returns:\n            EuclideanTrajectorySegment if found, else None\n        \"\"\"\n        for segment in self.segments:\n            if segment.in_domain(t):\n                return segment\n        return None\n</code></pre>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.message","title":"<code>message: str</code>  <code>property</code>","text":"<p>Aggregated messages from all segments.</p> <p>Convenience property for backwards compatibility with SciPyIvpSolution.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Combined message from all segments</p>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.success","title":"<code>success: bool</code>  <code>property</code>","text":"<p>Whether all segment integrations succeeded.</p> <p>Convenience property for backwards compatibility with SciPyIvpSolution.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all segments successful, False otherwise</p>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.t","title":"<code>t: NDArray[np.float64]</code>  <code>property</code>","text":"<p>Concatenated evaluation times from all segments.</p> <p>Note: May contain duplicate values at segment boundaries (tangent domains).</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: All evaluation times, shape (total_points,)</p>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.y","title":"<code>y: NDArray[np.float64]</code>  <code>property</code>","text":"<p>Concatenated states from all segments.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: All states, shape (n_dim, total_points)</p>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.from_segments","title":"<code>from_segments(segments: List[TrajectorySegment], merge_policy: TrajectorySegmentMergePolicy = 'average') -&gt; Trajectory</code>  <code>classmethod</code>","text":"<p>Factory: Create trajectory from list of segments, merging overlaps if needed.</p>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.from_segments--merge-algorithm-iterative-fixed-point-approach","title":"MERGE ALGORITHM: Iterative Fixed-Point Approach","text":"<p>This method implements an iterative fixed-point algorithm to merge overlapping segments until all domains are disjoint (class invariant).</p> <p>Problem: Cascading overlaps require multiple merge passes. Example: Segments [[0,1], [0.5,2], [1,3]] have:   - Pass 1: Merge [0,1] + [0.5,2] \u2192 [0,2]   - Pass 2: Merge [0,2] + [1,3] \u2192 [0,3]</p> Algorithm <ol> <li>Sort segments by domain start time (ensures left-to-right processing)</li> <li>Fixed-point iteration:    a. Scan through current segment list left-to-right    b. For each consecutive pair, detect overlap    c. If overlap exists, merge the pair and add to result    d. If no overlap, add current segment to result    e. If any merges occurred, repeat from step 2a    f. If no merges occurred, fixed point reached \u2192 done</li> </ol> <p>Invariant: At each iteration, segments in the working list are sorted by start time. This ensures that after merging two consecutive segments, the merged segment cannot overlap with any previously processed segments (they all ended before the current segment started, by the inductive property of sorted order).</p> Guaranteed because: <ul> <li>Each merge reduces the number of segments by 1</li> <li>Minimum segments = 1 (fully merged trajectory)</li> <li>Maximum iterations = n-1 (worst case: chain of n segments)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>List[EuclideanTrajectorySegment]</code> <p>Segments to compose</p> required <code>merge_policy</code> <code>TrajectorySegmentMergePolicy</code> <p>Strategy for handling overlaps - 'average' (DEFAULT): Average y values in overlap region - 'left': Use left segment in overlap - 'right': Use right segment in overlap - 'stitch': Left interpolant until midpoint, then right</p> <code>'average'</code> <p>Returns:</p> Name Type Description <code>EuclideanTrajectory</code> <code>Trajectory</code> <p>Composite trajectory with disjoint segment domains</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If final domains are not disjoint (merging failed)</p> <code>RuntimeError</code> <p>If merge algorithm fails to converge (indicates bug)</p> <code>NotImplementedError</code> <p>If merge_policy is not 'average' (others not yet implemented)</p> Example <p>seg1 = TrajectorySegment.from_scipy_solution(sol1, 'RK45') seg2 = TrajectorySegment.from_scipy_solution(sol2, 'RK45') traj = Trajectory.from_segments([seg1, seg2])</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>@classmethod\ndef from_segments(\n    cls,\n    segments: List[TrajectorySegment],\n    merge_policy: TrajectorySegmentMergePolicy = 'average'  # Default: average overlapping values\n) -&gt; 'Trajectory':\n    \"\"\"\n    Factory: Create trajectory from list of segments, merging overlaps if needed.\n\n    MERGE ALGORITHM: Iterative Fixed-Point Approach\n    ------------------------------------------------\n    This method implements an iterative fixed-point algorithm to merge overlapping\n    segments until all domains are disjoint (class invariant).\n\n    Problem: Cascading overlaps require multiple merge passes.\n    Example: Segments [[0,1], [0.5,2], [1,3]] have:\n      - Pass 1: Merge [0,1] + [0.5,2] \u2192 [0,2]\n      - Pass 2: Merge [0,2] + [1,3] \u2192 [0,3]\n\n    Algorithm:\n      1. Sort segments by domain start time (ensures left-to-right processing)\n      2. Fixed-point iteration:\n         a. Scan through current segment list left-to-right\n         b. For each consecutive pair, detect overlap\n         c. If overlap exists, merge the pair and add to result\n         d. If no overlap, add current segment to result\n         e. If any merges occurred, repeat from step 2a\n         f. If no merges occurred, fixed point reached \u2192 done\n\n    Invariant: At each iteration, segments in the working list are sorted by start time.\n    This ensures that after merging two consecutive segments, the merged segment\n    cannot overlap with any previously processed segments (they all ended before\n    the current segment started, by the inductive property of sorted order).\n\n    Termination: Guaranteed because:\n      - Each merge reduces the number of segments by 1\n      - Minimum segments = 1 (fully merged trajectory)\n      - Maximum iterations = n-1 (worst case: chain of n segments)\n\n    Args:\n        segments (List[EuclideanTrajectorySegment]): Segments to compose\n        merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps\n            - 'average' (DEFAULT): Average y values in overlap region\n            - 'left': Use left segment in overlap\n            - 'right': Use right segment in overlap\n            - 'stitch': Left interpolant until midpoint, then right\n\n    Returns:\n        EuclideanTrajectory: Composite trajectory with disjoint segment domains\n\n    Raises:\n        ValueError: If final domains are not disjoint (merging failed)\n        RuntimeError: If merge algorithm fails to converge (indicates bug)\n        NotImplementedError: If merge_policy is not 'average' (others not yet implemented)\n\n    Example:\n        &gt;&gt;&gt; seg1 = TrajectorySegment.from_scipy_solution(sol1, 'RK45')\n        &gt;&gt;&gt; seg2 = TrajectorySegment.from_scipy_solution(sol2, 'RK45')\n        &gt;&gt;&gt; traj = Trajectory.from_segments([seg1, seg2])\n    \"\"\"\n    if not segments:\n        raise ValueError(\"Cannot create trajectory from empty segment list\")\n\n    # Sort segments by domain start time (critical for correct merge order)\n    working_segments = sorted(segments, key=lambda seg: seg.domain[0])\n\n\n    # ITERATIVE FIXED-POINT MERGE ALGORITHM #\n    ## o(num_segments^2) worst case complexity\n    changed = True\n    iteration = 0\n    max_iterations = len(segments)  # Safety limit (should never be reached)\n    while changed and iteration &lt; max_iterations:\n        changed = False\n        merged_segments = []\n        i = 0\n\n        # pass through working segments, merging consecutive overlaps\n        while i &lt; len(working_segments):\n            current = working_segments[i]\n\n            if i + 1 &lt; len(working_segments):\n                next_seg = working_segments[i + 1]\n                overlap = cls._detect_overlap(current, next_seg)\n\n                if overlap is not None:\n                    # Overlapping segments detected - merge them\n                    if merge_policy == 'average':\n                        merged = cls._merge_segments_average(current, next_seg, overlap)\n                        merged_segments.append(merged)\n                        i += 2  # Skip both segments (merged into one)\n                        changed = True  # Mark that we made progress\n                    elif merge_policy == 'left':\n                        merged = cls._merge_segments_left(current, next_seg, overlap)\n                        merged_segments.append(merged)\n                        i += 2  # Skip both segments (merged into one)\n                        changed = True  # Mark that we made progress\n                    elif merge_policy == 'right':\n                        merged = cls._merge_segments_right(current, next_seg, overlap)\n                        merged_segments.append(merged)\n                        i += 2  # Skip both segments (merged into one)\n                        changed = True  # Mark that we made progress\n                    elif merge_policy == 'stitch':\n                        merged = cls._merge_segments_stitch(current, next_seg, overlap)\n                        merged_segments.append(merged)\n                        i += 2  # Skip both segments (merged into one)\n                        changed = True  # Mark that we made progress\n                    else:\n                        raise ValueError(f\"Unknown merge policy: {merge_policy}\")\n                else:\n                    # Disjoint segments - keep current and move forward\n                    merged_segments.append(current)\n                    i += 1\n            else:\n                # Last segment - no next segment to check for overlap\n                merged_segments.append(current)\n                i += 1\n\n        # Update working list for next iteration (if needed)\n        working_segments = merged_segments\n        iteration += 1\n\n    if iteration &gt;= max_iterations:\n        # This should never happen in practice, but safety check\n        raise RuntimeError(\n            f\"Merge algorithm failed to converge after {max_iterations} iterations. \"\n            f\"This indicates a bug in the merge logic.\"\n        )\n\n    # Final merged segments (guaranteed disjoint by fixed-point property)\n    merged_segments = working_segments\n\n    # Create trajectory instance\n    trajectory = cls()\n    trajectory.segments = merged_segments\n    trajectory.domains = [seg.domain for seg in merged_segments]\n\n    # Aggregate metadata\n    trajectory.meta = {\n        'all_successful': all(seg.meta['success'] for seg in merged_segments),\n        'messages': [seg.meta['message'] for seg in merged_segments],\n        'methods': [seg.method for seg in merged_segments],\n    }\n\n\n    trajectory._validate_disjoint_domains() # Validate disjoint domains (class invariant)\n    return trajectory\n</code></pre>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.in_domain","title":"<code>in_domain(t: float) -&gt; bool</code>","text":"<p>Check if time t is within trajectory domain (any segment).</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time point to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if t is in any segment's domain, False otherwise</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>def in_domain(self, t: float) -&gt; bool:\n    \"\"\"\n    Check if time t is within trajectory domain (any segment).\n\n    Args:\n        t (float): Time point to check\n\n    Returns:\n        bool: True if t is in any segment's domain, False otherwise\n    \"\"\"\n    return any(seg.in_domain(t) for seg in self.segments)\n</code></pre>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.interpolate","title":"<code>interpolate(t: float) -&gt; NDArray[np.float64]</code>","text":"<p>Seamlessly interpolate trajectory at time t.</p>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.interpolate--key-feature-unified-interface-across-composite-trajectories","title":"KEY FEATURE: Unified interface across composite trajectories","text":"<p>This method provides seamless interpolation even when the trajectory is composed of multiple disjoint segments. The user doesn't need to know which segment contains t - we handle the dispatch automatically.</p> Example use case <p>Bidirectional trajectory with domains [(-5, 0], [0, 5]]:   traj.interpolate(-3.0) \u2192 dispatches to backward segment   traj.interpolate(0.0)  \u2192 dispatches to forward segment (both have it, we pick first)   traj.interpolate(3.0)  \u2192 dispatches to forward segment   traj.interpolate(10.0) \u2192 raises ValueError (not in any domain)</p> <p>Implementation: O(n) linear search through segments (optimize with binary search later)</p> <p>Automatically finds the segment containing t and delegates to that segment's interpolant. Provides unified interface across potentially disjoint domains.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time point for evaluation</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: State vector x(t) at time t</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If t not in any segment domain</p> Example <p>traj = sys.trajectory(...)  # May have multiple segments x_5 = traj.interpolate(5.0)  # Seamlessly finds right segment</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>def interpolate(self, t: float) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Seamlessly interpolate trajectory at time t.\n\n    KEY FEATURE: Unified interface across composite trajectories\n    ------------------------------------------------------------\n    This method provides seamless interpolation even when the trajectory is\n    composed of multiple disjoint segments. The user doesn't need to know\n    which segment contains t - we handle the dispatch automatically.\n\n    Example use case:\n      Bidirectional trajectory with domains [(-5, 0], [0, 5]]:\n        traj.interpolate(-3.0) \u2192 dispatches to backward segment\n        traj.interpolate(0.0)  \u2192 dispatches to forward segment (both have it, we pick first)\n        traj.interpolate(3.0)  \u2192 dispatches to forward segment\n        traj.interpolate(10.0) \u2192 raises ValueError (not in any domain)\n\n    Implementation: O(n) linear search through segments (optimize with binary search later)\n\n    Automatically finds the segment containing t and delegates to that segment's\n    interpolant. Provides unified interface across potentially disjoint domains.\n\n    Args:\n        t (float): Time point for evaluation\n\n    Returns:\n        NDArray[np.float64]: State vector x(t) at time t\n\n    Raises:\n        ValueError: If t not in any segment domain\n\n    Example:\n        &gt;&gt;&gt; traj = sys.trajectory(...)  # May have multiple segments\n        &gt;&gt;&gt; x_5 = traj.interpolate(5.0)  # Seamlessly finds right segment\n    \"\"\"\n    segment = self._find_segment_containing(t)\n\n    if segment is None:\n        raise ValueError(\n            f\"Time t={t} not in any segment domain. \"\n            f\"Available domains: {self.domains}\"\n        )\n\n    # This may further raise ValueError if segment has no interpolant (dense_output=False)\n    return segment.interpolate(t)\n</code></pre>"},{"location":"api/core/euclidean/trajectory/#PyDynSys.core.euclidean.trajectory.Trajectory.merge","title":"<code>merge(other: Trajectory, merge_policy: TrajectorySegmentMergePolicy = 'average') -&gt; Trajectory</code>","text":"<p>Join this trajectory with another trajectory.</p> <p>Combines segments from both trajectories and merges any overlaps using the specified merge policy. Uses the same iterative fixed-point merge algorithm as from_segments() to handle cascading overlaps.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Trajectory</code> <p>The other trajectory to join with self</p> required <code>merge_policy</code> <code>TrajectorySegmentMergePolicy</code> <p>Strategy for handling overlaps - 'average' (DEFAULT): Average y values in overlap region - 'left': Use left segment in overlap - 'right': Use right segment in overlap - 'stitch': Left interpolant until midpoint, then right</p> <code>'average'</code> <p>Returns:</p> Name Type Description <code>Trajectory</code> <code>Trajectory</code> <p>New trajectory containing all segments from both trajectories, with overlaps merged according to merge_policy</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If final domains are not disjoint (merging failed)</p> <code>RuntimeError</code> <p>If merge algorithm fails to converge (indicates bug)</p> <code>NotImplementedError</code> <p>If merge_policy is not 'average' (others not yet implemented)</p> Example <p>traj1 = sys1.trajectory(x0, t_span=(0, 5)) traj2 = sys2.trajectory(x1, t_span=(3, 10)) combined = traj1.join(traj2)  # Merges overlap in [3, 5]</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>def merge(\n    self,\n    other: 'Trajectory',\n    merge_policy: TrajectorySegmentMergePolicy = 'average'\n) -&gt; 'Trajectory':\n    \"\"\"\n    Join this trajectory with another trajectory.\n\n    Combines segments from both trajectories and merges any overlaps using\n    the specified merge policy. Uses the same iterative fixed-point merge\n    algorithm as from_segments() to handle cascading overlaps.\n\n    Args:\n        other (Trajectory): The other trajectory to join with self\n        merge_policy (TrajectorySegmentMergePolicy): Strategy for handling overlaps\n            - 'average' (DEFAULT): Average y values in overlap region\n            - 'left': Use left segment in overlap\n            - 'right': Use right segment in overlap\n            - 'stitch': Left interpolant until midpoint, then right\n\n    Returns:\n        Trajectory: New trajectory containing all segments from both trajectories,\n            with overlaps merged according to merge_policy\n\n    Raises:\n        ValueError: If final domains are not disjoint (merging failed)\n        RuntimeError: If merge algorithm fails to converge (indicates bug)\n        NotImplementedError: If merge_policy is not 'average' (others not yet implemented)\n\n    Example:\n        &gt;&gt;&gt; traj1 = sys1.trajectory(x0, t_span=(0, 5))\n        &gt;&gt;&gt; traj2 = sys2.trajectory(x1, t_span=(3, 10))\n        &gt;&gt;&gt; combined = traj1.join(traj2)  # Merges overlap in [3, 5]\n    \"\"\"\n    # Combine segments from both trajectories\n    combined_segments = list(self.segments) + list(other.segments)\n\n    # Use from_segments factory to merge overlaps and create new trajectory\n    return Trajectory.from_segments(combined_segments, merge_policy=merge_policy)\n</code></pre>"},{"location":"api/core/euclidean/trajectory_segment/","title":"TrajectorySegment","text":""},{"location":"api/core/euclidean/trajectory_segment/#full-docs","title":"Full Docs","text":""},{"location":"api/core/euclidean/trajectory_segment/#PyDynSys.core.euclidean.trajectory.TrajectorySegment","title":"<code>PyDynSys.core.euclidean.trajectory.TrajectorySegment</code>","text":"<p>Represents a numerically computed segment of a trajectory on a monotone increasing evaluation space. </p> <p>A segment corresponds to a single continuous solution from scipy.solve_ivp, representing the trajectory over a contiguous time interval with a single interpolant.</p> Fields <p>t (NDArray[np.float64]): Monotone increasing array of evaluation times, shape (len(t),) y (NDArray[np.float64]): Array of trajectory evaluations x(t), shape (n, len(t)) domain (Tuple[float, float]): Time domain [t[0], t[-1]] where segment is defined interpolant (Optional[Callable]): Continuous interpolant x(t) on domain, or None method (str): ODE solver method used ('RK45', 'LSODA', etc.) meta (Dict[str, Any]): Metadata about numerical solution (success, message, etc.)</p> Usage <p>Segments are created via from_scipy_solution() factory, not direct instantiation. Users primarily interact with EuclideanTrajectory, which aggregates segments.</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>class TrajectorySegment: \n    \"\"\"\n    Represents a numerically computed segment of a trajectory on a monotone increasing evaluation space. \n\n    A segment corresponds to a single continuous solution from scipy.solve_ivp, representing\n    the trajectory over a contiguous time interval with a single interpolant.\n\n    Fields: \n        t (NDArray[np.float64]): Monotone increasing array of evaluation times, shape (len(t),)\n        y (NDArray[np.float64]): Array of trajectory evaluations x(t), shape (n, len(t))\n        domain (Tuple[float, float]): Time domain [t[0], t[-1]] where segment is defined\n        interpolant (Optional[Callable]): Continuous interpolant x(t) on domain, or None\n        method (str): ODE solver method used ('RK45', 'LSODA', etc.)\n        meta (Dict[str, Any]): Metadata about numerical solution (success, message, etc.)\n\n    Usage:\n        Segments are created via from_scipy_solution() factory, not direct instantiation.\n        Users primarily interact with EuclideanTrajectory, which aggregates segments.\n    \"\"\"\n\n\n    ### --- Factory Methods --- ###\n\n\n    @classmethod\n    def from_scipy_solution(\n        cls, \n        sol: SciPyIvpSolution, \n        method: str\n    ) -&gt; 'TrajectorySegment':\n        \"\"\"\n        Factory: Create segment from scipy solve_ivp solution.\n\n        Handles backward integration (monotone decreasing t) by reversing arrays to\n        enforce monotone increasing time convention for all segments.\n\n        Args:\n            sol (SciPyIvpSolution): Wrapped scipy OdeResult from solve_ivp\n            method (str): ODE solver method used (e.g. 'RK45', 'LSODA')\n\n        Returns:\n            EuclideanTrajectorySegment: Segment with monotone increasing time\n\n        Example:\n            &gt;&gt;&gt; from scipy.integrate import solve_ivp\n            &gt;&gt;&gt; result = solve_ivp(fun, t_span, y0, t_eval, method, dense_output)\n            &gt;&gt;&gt; wrapped = SciPyIvpSolution(raw_solution=result) # not necessary, but provides type safety\n            &gt;&gt;&gt; segment = EuclideanTrajectorySegment.from_scipy_solution(wrapped, 'RK45') # default method is RK45\n        \"\"\"\n        segment = cls()\n        t = sol.t # shape = (n_points,)\n        y = sol.y # shape = (n_dim, n_points)\n\n        # Enforce monotone increasing time convention\n        if len(t) &gt; 1 and t[0] &gt; t[-1]:\n            # Backward integration detected (time decreases): reverse arrays\n            t = t[::-1]\n            y = y[:, ::-1]\n\n        segment.t = t\n        segment.y = y\n        segment.domain = (float(t[0]), float(t[-1]))\n\n        # Store interpolant (callable or None)\n        ## NOTE: this is some iff dense_output=True flag passed to solve_ivp fn.\n        segment.interpolant = sol.sol\n\n        segment.method = method\n        segment.meta = {\n            'success': sol.success,\n            'message': sol.message,\n        }\n\n        return segment\n\n\n        ### --- Public Methods --- ###\n\n\n    def in_domain(self, t: float) -&gt; bool:\n        \"\"\"\n        Check if time t is within segment domain.\n\n        Args:\n            t (float): Time point to check\n\n        Returns:\n            bool: True if t \u2208 [domain[0], domain[1]], False otherwise\n        \"\"\"\n        return self.domain[0] &lt;= t &lt;= self.domain[1]\n\n    def interpolant_at_time(self, t: float) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Evaluate interpolant at time t.\n\n        Uses scipy's dense output interpolant to compute x(t) continuously within\n        the segment domain. Raises errors if t is outside domain or if no interpolant\n        is available (dense_output=False in original solve_ivp call).\n\n        NOTE: For speed, we employ agressive programming here and assume \n            1. t is in domain \n            2. interpolant is available\n        If either of these fails, an esoteric error may be incurred. This is a worthwhile \n        tradeoff as this function may be called thousands of times (e.g. when plotting a trajectory).\n\n        Args:\n            t (float): Time point for evaluation\n\n        Returns:\n            NDArray[np.float64]: State vector x(t) at time t, shape (n,)\n\n        Example:\n            &gt;&gt;&gt; x_t = segment.interpolate(0.5)  # Evaluate at t=0.5\n        \"\"\"\n        result = self.interpolant(t)\n        if result.ndim == 2:\n            return result[:, 0]  # Extract column vector as 1D\n        return result\n</code></pre>"},{"location":"api/core/euclidean/trajectory_segment/#PyDynSys.core.euclidean.trajectory.TrajectorySegment.from_scipy_solution","title":"<code>from_scipy_solution(sol: SciPyIvpSolution, method: str) -&gt; TrajectorySegment</code>  <code>classmethod</code>","text":"<p>Factory: Create segment from scipy solve_ivp solution.</p> <p>Handles backward integration (monotone decreasing t) by reversing arrays to enforce monotone increasing time convention for all segments.</p> <p>Parameters:</p> Name Type Description Default <code>sol</code> <code>SciPyIvpSolution</code> <p>Wrapped scipy OdeResult from solve_ivp</p> required <code>method</code> <code>str</code> <p>ODE solver method used (e.g. 'RK45', 'LSODA')</p> required <p>Returns:</p> Name Type Description <code>EuclideanTrajectorySegment</code> <code>TrajectorySegment</code> <p>Segment with monotone increasing time</p> Example <p>from scipy.integrate import solve_ivp result = solve_ivp(fun, t_span, y0, t_eval, method, dense_output) wrapped = SciPyIvpSolution(raw_solution=result) # not necessary, but provides type safety segment = EuclideanTrajectorySegment.from_scipy_solution(wrapped, 'RK45') # default method is RK45</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>@classmethod\ndef from_scipy_solution(\n    cls, \n    sol: SciPyIvpSolution, \n    method: str\n) -&gt; 'TrajectorySegment':\n    \"\"\"\n    Factory: Create segment from scipy solve_ivp solution.\n\n    Handles backward integration (monotone decreasing t) by reversing arrays to\n    enforce monotone increasing time convention for all segments.\n\n    Args:\n        sol (SciPyIvpSolution): Wrapped scipy OdeResult from solve_ivp\n        method (str): ODE solver method used (e.g. 'RK45', 'LSODA')\n\n    Returns:\n        EuclideanTrajectorySegment: Segment with monotone increasing time\n\n    Example:\n        &gt;&gt;&gt; from scipy.integrate import solve_ivp\n        &gt;&gt;&gt; result = solve_ivp(fun, t_span, y0, t_eval, method, dense_output)\n        &gt;&gt;&gt; wrapped = SciPyIvpSolution(raw_solution=result) # not necessary, but provides type safety\n        &gt;&gt;&gt; segment = EuclideanTrajectorySegment.from_scipy_solution(wrapped, 'RK45') # default method is RK45\n    \"\"\"\n    segment = cls()\n    t = sol.t # shape = (n_points,)\n    y = sol.y # shape = (n_dim, n_points)\n\n    # Enforce monotone increasing time convention\n    if len(t) &gt; 1 and t[0] &gt; t[-1]:\n        # Backward integration detected (time decreases): reverse arrays\n        t = t[::-1]\n        y = y[:, ::-1]\n\n    segment.t = t\n    segment.y = y\n    segment.domain = (float(t[0]), float(t[-1]))\n\n    # Store interpolant (callable or None)\n    ## NOTE: this is some iff dense_output=True flag passed to solve_ivp fn.\n    segment.interpolant = sol.sol\n\n    segment.method = method\n    segment.meta = {\n        'success': sol.success,\n        'message': sol.message,\n    }\n\n    return segment\n</code></pre>"},{"location":"api/core/euclidean/trajectory_segment/#PyDynSys.core.euclidean.trajectory.TrajectorySegment.in_domain","title":"<code>in_domain(t: float) -&gt; bool</code>","text":"<p>Check if time t is within segment domain.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time point to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if t \u2208 [domain[0], domain[1]], False otherwise</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>def in_domain(self, t: float) -&gt; bool:\n    \"\"\"\n    Check if time t is within segment domain.\n\n    Args:\n        t (float): Time point to check\n\n    Returns:\n        bool: True if t \u2208 [domain[0], domain[1]], False otherwise\n    \"\"\"\n    return self.domain[0] &lt;= t &lt;= self.domain[1]\n</code></pre>"},{"location":"api/core/euclidean/trajectory_segment/#PyDynSys.core.euclidean.trajectory.TrajectorySegment.interpolant_at_time","title":"<code>interpolant_at_time(t: float) -&gt; NDArray[np.float64]</code>","text":"<p>Evaluate interpolant at time t.</p> <p>Uses scipy's dense output interpolant to compute x(t) continuously within the segment domain. Raises errors if t is outside domain or if no interpolant is available (dense_output=False in original solve_ivp call).</p> For speed, we employ agressive programming here and assume <ol> <li>t is in domain </li> <li>interpolant is available</li> </ol> <p>If either of these fails, an esoteric error may be incurred. This is a worthwhile  tradeoff as this function may be called thousands of times (e.g. when plotting a trajectory).</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time point for evaluation</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: State vector x(t) at time t, shape (n,)</p> Example <p>x_t = segment.interpolate(0.5)  # Evaluate at t=0.5</p> Source code in <code>src/PyDynSys/core/euclidean/trajectory.py</code> <pre><code>def interpolant_at_time(self, t: float) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Evaluate interpolant at time t.\n\n    Uses scipy's dense output interpolant to compute x(t) continuously within\n    the segment domain. Raises errors if t is outside domain or if no interpolant\n    is available (dense_output=False in original solve_ivp call).\n\n    NOTE: For speed, we employ agressive programming here and assume \n        1. t is in domain \n        2. interpolant is available\n    If either of these fails, an esoteric error may be incurred. This is a worthwhile \n    tradeoff as this function may be called thousands of times (e.g. when plotting a trajectory).\n\n    Args:\n        t (float): Time point for evaluation\n\n    Returns:\n        NDArray[np.float64]: State vector x(t) at time t, shape (n,)\n\n    Example:\n        &gt;&gt;&gt; x_t = segment.interpolate(0.5)  # Evaluate at t=0.5\n    \"\"\"\n    result = self.interpolant(t)\n    if result.ndim == 2:\n        return result[:, 0]  # Extract column vector as 1D\n    return result\n</code></pre>"},{"location":"api/vis/euclidean/","title":"Overview","text":""},{"location":"api/vis/euclidean/#pydynsysviseuclidean-submodule","title":"PyDynSys.vis.euclidean submodule","text":""},{"location":"api/vis/euclidean/#full-docs","title":"Full Docs","text":""},{"location":"api/vis/euclidean/#PyDynSys.vis.euclidean","title":"<code>PyDynSys.vis.euclidean</code>","text":"<p>Visualization utilities for Euclidean dynamical systems.</p>"},{"location":"api/vis/euclidean/#PyDynSys.vis.euclidean.plot_phase_space","title":"<code>plot_phase_space(phase_space, xlim, ylim, resolution=200, ax=None, **kwargs)</code>","text":"<p>Visualize a PhaseSpace using its constraint function.</p> <p>This is a general entry point for PhaseSpace visualization. Currently only 2D phase spaces are supported via plot_planar_phase_space.</p> <p>Parameters:</p> Name Type Description Default <code>phase_space</code> <code>PhaseSpace</code> <p>The PhaseSpace to visualize</p> required <code>xlim</code> <code>Tuple[float, float]</code> <p>Tuple (x_min, x_max) for plot bounds</p> required <code>ylim</code> <code>Tuple[float, float]</code> <p>Tuple (y_min, y_max) for plot bounds</p> required <code>resolution</code> <code>int</code> <p>Number of grid points per dimension (default: 200)</p> <code>200</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib Axes to plot on. If None, creates a new figure</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to matplotlib's imshow function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>matplotlib.axes.Axes: The matplotlib Axes object containing the plot</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If phase_space.dimension != 2</p> Source code in <code>src/PyDynSys/vis/euclidean/phase_space.py</code> <pre><code>def plot_phase_space(\n    phase_space: PhaseSpace,\n    xlim: Tuple[float, float],\n    ylim: Tuple[float, float],\n    resolution: int = 200,\n    ax: Optional[Axes] = None,\n    **kwargs\n) -&gt; Axes:\n    \"\"\"\n    Visualize a PhaseSpace using its constraint function.\n\n    This is a general entry point for PhaseSpace visualization. Currently only\n    2D phase spaces are supported via plot_planar_phase_space.\n\n    Args:\n        phase_space (core.euclidean.PhaseSpace): The PhaseSpace to visualize\n        xlim (Tuple[float, float]): Tuple (x_min, x_max) for plot bounds\n        ylim (Tuple[float, float]): Tuple (y_min, y_max) for plot bounds\n        resolution (int): Number of grid points per dimension (default: 200)\n        ax (Optional[matplotlib.axes.Axes]): Optional matplotlib Axes to plot on. If None, creates a new figure\n        **kwargs (Any): Additional arguments passed to matplotlib's imshow function\n\n    Returns:\n        matplotlib.axes.Axes: The matplotlib Axes object containing the plot\n\n    Raises:\n        NotImplementedError: If phase_space.dimension != 2\n    \"\"\"\n    if phase_space.dimension == 2:\n        return plot_planar_phase_space(\n            phase_space=phase_space,\n            xlim=xlim,\n            ylim=ylim,\n            resolution=resolution,\n            ax=ax,\n            **kwargs\n        )\n    else:\n        raise NotImplementedError(\n            f\"plot_phase_space only supports 2D PhaseSpaces currently, \"\n            f\"got dimension {phase_space.dimension}. \"\n            f\"Support for dimensions != 2 is planned for future releases.\"\n        )\n</code></pre>"},{"location":"api/vis/euclidean/#PyDynSys.vis.euclidean.plot_planar_phase_space","title":"<code>plot_planar_phase_space(phase_space, xlim, ylim, resolution=200, ax=None, **kwargs)</code>","text":"<p>Visualize a 2D PhaseSpace using its constraint function.</p> <p>Creates a grid of points and tests membership using the PhaseSpace's constraint callable, then visualizes the result using imshow for efficient boolean visualization.</p> <p>Parameters:</p> Name Type Description Default <code>phase_space</code> <code>PhaseSpace</code> <p>The PhaseSpace to visualize (must be 2D)</p> required <code>xlim</code> <code>Tuple[float, float]</code> <p>Tuple (x_min, x_max) for plot bounds</p> required <code>ylim</code> <code>Tuple[float, float]</code> <p>Tuple (y_min, y_max) for plot bounds</p> required <code>resolution</code> <code>int</code> <p>Number of grid points per dimension (default: 200)</p> <code>200</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib Axes to plot on. If None, creates a new figure</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to matplotlib's imshow function       (e.g., cmap, alpha, interpolation)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the plot</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If phase_space.dimension != 2</p> Source code in <code>src/PyDynSys/vis/euclidean/phase_space.py</code> <pre><code>def plot_planar_phase_space(\n    phase_space: PhaseSpace,\n    xlim: Tuple[float, float],\n    ylim: Tuple[float, float],\n    resolution: int = 200,\n    ax: Optional[Axes] = None,\n    **kwargs\n) -&gt; Axes:\n    \"\"\"\n    Visualize a 2D PhaseSpace using its constraint function.\n\n    Creates a grid of points and tests membership using the PhaseSpace's\n    constraint callable, then visualizes the result using imshow for efficient\n    boolean visualization.\n\n    Args:\n        phase_space: The PhaseSpace to visualize (must be 2D)\n        xlim: Tuple (x_min, x_max) for plot bounds\n        ylim: Tuple (y_min, y_max) for plot bounds\n        resolution: Number of grid points per dimension (default: 200)\n        ax: Optional matplotlib Axes to plot on. If None, creates a new figure\n        **kwargs: Additional arguments passed to matplotlib's imshow function\n                  (e.g., cmap, alpha, interpolation)\n\n    Returns:\n        The matplotlib Axes object containing the plot\n\n    Raises:\n        ValueError: If phase_space.dimension != 2\n    \"\"\"\n    if phase_space.dimension != 2:\n        raise ValueError(f\"plot_phase_space only supports 2D PhaseSpaces, got dimension {phase_space.dimension}\")\n\n    x = np.linspace(xlim[0], xlim[1], resolution)\n    y = np.linspace(ylim[0], ylim[1], resolution)\n    X, Y = np.meshgrid(x, y)\n\n    membership = np.zeros_like(X, dtype=bool)\n    for i in range(resolution):\n        for j in range(resolution):\n            point = np.array([X[i, j], Y[i, j]], dtype=np.float64)\n            membership[i, j] = phase_space.contains_point(point)\n\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Use imshow for simple, fast boolean visualization\n    extent = [xlim[0], xlim[1], ylim[0], ylim[1]]\n    default_kwargs = {\n        'cmap': 'Blues',\n        'alpha': 0.5,\n        'origin': 'lower',\n        'interpolation': 'nearest'\n    }\n    default_kwargs.update(kwargs)\n\n    im = ax.imshow(membership.astype(float), extent=extent, **default_kwargs)\n    ax.contour(X, Y, membership.astype(float), levels=[0.5], colors='black', linewidths=2)\n\n    ax.set_xlabel('$x_0$')\n    ax.set_ylabel('$x_1$')\n    ax.set_title('Phase Space Visualization')\n    ax.set_xlim(xlim)\n    ax.set_ylim(ylim)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n\n    return ax\n</code></pre>"},{"location":"api/vis/euclidean/phase_space/","title":"Phase Space Visualisation","text":""},{"location":"api/vis/euclidean/phase_space/#full-docs","title":"Full Docs","text":""},{"location":"api/vis/euclidean/phase_space/#PyDynSys.vis.euclidean.phase_space","title":"<code>PyDynSys.vis.euclidean.phase_space</code>","text":"<p>Visualization utilities for PhaseSpace objects.</p>"},{"location":"api/vis/euclidean/phase_space/#PyDynSys.vis.euclidean.phase_space.plot_phase_space","title":"<code>plot_phase_space(phase_space: PhaseSpace, xlim: Tuple[float, float], ylim: Tuple[float, float], resolution: int = 200, ax: Optional[Axes] = None, **kwargs) -&gt; Axes</code>","text":"<p>Visualize a PhaseSpace using its constraint function.</p> <p>This is a general entry point for PhaseSpace visualization. Currently only 2D phase spaces are supported via plot_planar_phase_space.</p> <p>Parameters:</p> Name Type Description Default <code>phase_space</code> <code>PhaseSpace</code> <p>The PhaseSpace to visualize</p> required <code>xlim</code> <code>Tuple[float, float]</code> <p>Tuple (x_min, x_max) for plot bounds</p> required <code>ylim</code> <code>Tuple[float, float]</code> <p>Tuple (y_min, y_max) for plot bounds</p> required <code>resolution</code> <code>int</code> <p>Number of grid points per dimension (default: 200)</p> <code>200</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib Axes to plot on. If None, creates a new figure</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to matplotlib's imshow function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>matplotlib.axes.Axes: The matplotlib Axes object containing the plot</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If phase_space.dimension != 2</p> Source code in <code>src/PyDynSys/vis/euclidean/phase_space.py</code> <pre><code>def plot_phase_space(\n    phase_space: PhaseSpace,\n    xlim: Tuple[float, float],\n    ylim: Tuple[float, float],\n    resolution: int = 200,\n    ax: Optional[Axes] = None,\n    **kwargs\n) -&gt; Axes:\n    \"\"\"\n    Visualize a PhaseSpace using its constraint function.\n\n    This is a general entry point for PhaseSpace visualization. Currently only\n    2D phase spaces are supported via plot_planar_phase_space.\n\n    Args:\n        phase_space (core.euclidean.PhaseSpace): The PhaseSpace to visualize\n        xlim (Tuple[float, float]): Tuple (x_min, x_max) for plot bounds\n        ylim (Tuple[float, float]): Tuple (y_min, y_max) for plot bounds\n        resolution (int): Number of grid points per dimension (default: 200)\n        ax (Optional[matplotlib.axes.Axes]): Optional matplotlib Axes to plot on. If None, creates a new figure\n        **kwargs (Any): Additional arguments passed to matplotlib's imshow function\n\n    Returns:\n        matplotlib.axes.Axes: The matplotlib Axes object containing the plot\n\n    Raises:\n        NotImplementedError: If phase_space.dimension != 2\n    \"\"\"\n    if phase_space.dimension == 2:\n        return plot_planar_phase_space(\n            phase_space=phase_space,\n            xlim=xlim,\n            ylim=ylim,\n            resolution=resolution,\n            ax=ax,\n            **kwargs\n        )\n    else:\n        raise NotImplementedError(\n            f\"plot_phase_space only supports 2D PhaseSpaces currently, \"\n            f\"got dimension {phase_space.dimension}. \"\n            f\"Support for dimensions != 2 is planned for future releases.\"\n        )\n</code></pre>"},{"location":"api/vis/euclidean/phase_space/#PyDynSys.vis.euclidean.phase_space.plot_planar_phase_space","title":"<code>plot_planar_phase_space(phase_space: PhaseSpace, xlim: Tuple[float, float], ylim: Tuple[float, float], resolution: int = 200, ax: Optional[Axes] = None, **kwargs) -&gt; Axes</code>","text":"<p>Visualize a 2D PhaseSpace using its constraint function.</p> <p>Creates a grid of points and tests membership using the PhaseSpace's constraint callable, then visualizes the result using imshow for efficient boolean visualization.</p> <p>Parameters:</p> Name Type Description Default <code>phase_space</code> <code>PhaseSpace</code> <p>The PhaseSpace to visualize (must be 2D)</p> required <code>xlim</code> <code>Tuple[float, float]</code> <p>Tuple (x_min, x_max) for plot bounds</p> required <code>ylim</code> <code>Tuple[float, float]</code> <p>Tuple (y_min, y_max) for plot bounds</p> required <code>resolution</code> <code>int</code> <p>Number of grid points per dimension (default: 200)</p> <code>200</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib Axes to plot on. If None, creates a new figure</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to matplotlib's imshow function       (e.g., cmap, alpha, interpolation)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the plot</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If phase_space.dimension != 2</p> Source code in <code>src/PyDynSys/vis/euclidean/phase_space.py</code> <pre><code>def plot_planar_phase_space(\n    phase_space: PhaseSpace,\n    xlim: Tuple[float, float],\n    ylim: Tuple[float, float],\n    resolution: int = 200,\n    ax: Optional[Axes] = None,\n    **kwargs\n) -&gt; Axes:\n    \"\"\"\n    Visualize a 2D PhaseSpace using its constraint function.\n\n    Creates a grid of points and tests membership using the PhaseSpace's\n    constraint callable, then visualizes the result using imshow for efficient\n    boolean visualization.\n\n    Args:\n        phase_space: The PhaseSpace to visualize (must be 2D)\n        xlim: Tuple (x_min, x_max) for plot bounds\n        ylim: Tuple (y_min, y_max) for plot bounds\n        resolution: Number of grid points per dimension (default: 200)\n        ax: Optional matplotlib Axes to plot on. If None, creates a new figure\n        **kwargs: Additional arguments passed to matplotlib's imshow function\n                  (e.g., cmap, alpha, interpolation)\n\n    Returns:\n        The matplotlib Axes object containing the plot\n\n    Raises:\n        ValueError: If phase_space.dimension != 2\n    \"\"\"\n    if phase_space.dimension != 2:\n        raise ValueError(f\"plot_phase_space only supports 2D PhaseSpaces, got dimension {phase_space.dimension}\")\n\n    x = np.linspace(xlim[0], xlim[1], resolution)\n    y = np.linspace(ylim[0], ylim[1], resolution)\n    X, Y = np.meshgrid(x, y)\n\n    membership = np.zeros_like(X, dtype=bool)\n    for i in range(resolution):\n        for j in range(resolution):\n            point = np.array([X[i, j], Y[i, j]], dtype=np.float64)\n            membership[i, j] = phase_space.contains_point(point)\n\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Use imshow for simple, fast boolean visualization\n    extent = [xlim[0], xlim[1], ylim[0], ylim[1]]\n    default_kwargs = {\n        'cmap': 'Blues',\n        'alpha': 0.5,\n        'origin': 'lower',\n        'interpolation': 'nearest'\n    }\n    default_kwargs.update(kwargs)\n\n    im = ax.imshow(membership.astype(float), extent=extent, **default_kwargs)\n    ax.contour(X, Y, membership.astype(float), levels=[0.5], colors='black', linewidths=2)\n\n    ax.set_xlabel('$x_0$')\n    ax.set_ylabel('$x_1$')\n    ax.set_title('Phase Space Visualization')\n    ax.set_xlim(xlim)\n    ax.set_ylim(ylim)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n\n    return ax\n</code></pre>"},{"location":"contributing/contributing/","title":"Contributing to PyDynSys","text":""},{"location":"examples/phase_spaces_and_time_horizons/","title":"Using Custom Phase Spaces and Time Horizons","text":"In\u00a0[1]: Copied! <pre>from PyDynSys.core.euclidean import PhaseSpace\nimport numpy as np\nimport sympy as syp\n</pre> from PyDynSys.core.euclidean import PhaseSpace import numpy as np import sympy as syp In\u00a0[2]: Copied! <pre># Create full 3D Euclidean space\nreal_plane = PhaseSpace.full(3)\n\nprint(f\"Full phase space: {real_plane}\")\nprint(f\"Dimension: {real_plane.dimension}\")\n\n# All points are contained in R^n\ntest_point = np.array([1.0, -5.0, 10.0], dtype=np.float64)\nprint(f\"\\nPoint {test_point} is in real_plane: {real_plane.contains_point(test_point)}\")\n</pre> # Create full 3D Euclidean space real_plane = PhaseSpace.full(3)  print(f\"Full phase space: {real_plane}\") print(f\"Dimension: {real_plane.dimension}\")  # All points are contained in R^n test_point = np.array([1.0, -5.0, 10.0], dtype=np.float64) print(f\"\\nPoint {test_point} is in real_plane: {real_plane.contains_point(test_point)}\") <pre>Full phase space: ProductSet(Reals, Reals, Reals)\nDimension: 3\n\nPoint [ 1. -5. 10.] is in real_plane: True\n</pre> In\u00a0[3]: Copied! <pre># Create unit box [0, 1] \u00d7 [0, 1] \u00d7 [0, 1]\nbounds = np.array([[0.0, 1.0], [0.0, 1.0], [0.0, 1.0]], dtype=np.float64)\nunit_box = PhaseSpace.box(bounds)\n\nprint(f\"Unit box: {unit_box}\")\nprint(f\"Dimension: {unit_box.dimension}\")\n\n# Test membership\ninside_point = np.array([0.5, 0.5, 0.5], dtype=np.float64)\noutside_point = np.array([1.1, 0.5, 0.5], dtype=np.float64)\nboundary_point = np.array([1.0, 1.0, 1.0], dtype=np.float64)  # On boundary\n\nprint(f\"\\nPoint {inside_point} is in unit_box: {unit_box.contains_point(inside_point)}\")\nprint(f\"Point {outside_point} is in unit_box: {unit_box.contains_point(outside_point)}\")\nprint(f\"Point {boundary_point} is in unit_box: {unit_box.contains_point(boundary_point)}\")  # Closed intervals\n</pre> # Create unit box [0, 1] \u00d7 [0, 1] \u00d7 [0, 1] bounds = np.array([[0.0, 1.0], [0.0, 1.0], [0.0, 1.0]], dtype=np.float64) unit_box = PhaseSpace.box(bounds)  print(f\"Unit box: {unit_box}\") print(f\"Dimension: {unit_box.dimension}\")  # Test membership inside_point = np.array([0.5, 0.5, 0.5], dtype=np.float64) outside_point = np.array([1.1, 0.5, 0.5], dtype=np.float64) boundary_point = np.array([1.0, 1.0, 1.0], dtype=np.float64)  # On boundary  print(f\"\\nPoint {inside_point} is in unit_box: {unit_box.contains_point(inside_point)}\") print(f\"Point {outside_point} is in unit_box: {unit_box.contains_point(outside_point)}\") print(f\"Point {boundary_point} is in unit_box: {unit_box.contains_point(boundary_point)}\")  # Closed intervals <pre>Unit box: ProductSet(Interval(0.0, 1.00000000000000), Interval(0.0, 1.00000000000000), Interval(0.0, 1.00000000000000))\nDimension: 3\n\nPoint [0.5 0.5 0.5] is in unit_box: True\nPoint [1.1 0.5 0.5] is in unit_box: False\nPoint [1. 1. 1.] is in unit_box: True\n</pre> In\u00a0[4]: Copied! <pre># Create a set of test points\npoint_set = np.array([\n    [0.5, 0.5, 0.5],  # Inside\n    [1.0, 1.0, 1.0],  # On boundary\n    [0.0, 0.0, 0.0],  # Corner\n    [1.1, 0.5, 0.5]   # Outside\n], dtype=np.float64)\n\nprint(\"Testing membership for unit_box:\")\nfor i, point in enumerate(point_set):\n    is_inside = unit_box.contains_point(point)\n    print(f\"  Point {i+1} {point}: {is_inside}\")\n\nprint(f\"\\nAll points in unit_box: {unit_box.contains_points(point_set)}\")\nprint(f\"All points in real_plane: {real_plane.contains_points(point_set)}\")\n</pre> # Create a set of test points point_set = np.array([     [0.5, 0.5, 0.5],  # Inside     [1.0, 1.0, 1.0],  # On boundary     [0.0, 0.0, 0.0],  # Corner     [1.1, 0.5, 0.5]   # Outside ], dtype=np.float64)  print(\"Testing membership for unit_box:\") for i, point in enumerate(point_set):     is_inside = unit_box.contains_point(point)     print(f\"  Point {i+1} {point}: {is_inside}\")  print(f\"\\nAll points in unit_box: {unit_box.contains_points(point_set)}\") print(f\"All points in real_plane: {real_plane.contains_points(point_set)}\") <pre>Testing membership for unit_box:\n  Point 1 [0.5 0.5 0.5]: True\n  Point 2 [1. 1. 1.]: True\n  Point 3 [0. 0. 0.]: True\n  Point 4 [1.1 0.5 0.5]: False\n\nAll points in unit_box: False\nAll points in real_plane: True\n</pre> In\u00a0[5]: Copied! <pre># Custom ellipsoid: (x/2)^2 + (y/1)^2 + (z/1.5)^2 &lt;= 1\n# Semi-axes: [2, 1, 1.5], centered at origin\ndimension = 3\nsemi_axes = np.array([2.0, 1.0, 1.5], dtype=np.float64)\n\n# Create symbolic representation using SymPy\nR_n = syp.Reals ** dimension\nx = syp.symbols('x0 x1 x2', real=True)\nellipsoid_condition = sum((x[i] / semi_axes[i])**2 for i in range(dimension)) &lt;= 1\nellipsoid_symbolic = syp.ConditionSet(syp.Tuple(*x), ellipsoid_condition, R_n)\n\n# Create callable constraint for fast membership testing\nellipsoid_constraint = lambda x: bool(np.sum((x / semi_axes)**2) &lt;= 1)\n\n# Create PhaseSpace with both representations\ncustom_ellipsoid = PhaseSpace(\n    dimension=dimension,\n    symbolic_set=ellipsoid_symbolic,\n    constraint=ellipsoid_constraint\n)\n\nprint(f\"Custom ellipsoid: {custom_ellipsoid}\")\nprint(f\"Dimension: {custom_ellipsoid.dimension}\")\n</pre> # Custom ellipsoid: (x/2)^2 + (y/1)^2 + (z/1.5)^2 &lt;= 1 # Semi-axes: [2, 1, 1.5], centered at origin dimension = 3 semi_axes = np.array([2.0, 1.0, 1.5], dtype=np.float64)  # Create symbolic representation using SymPy R_n = syp.Reals ** dimension x = syp.symbols('x0 x1 x2', real=True) ellipsoid_condition = sum((x[i] / semi_axes[i])**2 for i in range(dimension)) &lt;= 1 ellipsoid_symbolic = syp.ConditionSet(syp.Tuple(*x), ellipsoid_condition, R_n)  # Create callable constraint for fast membership testing ellipsoid_constraint = lambda x: bool(np.sum((x / semi_axes)**2) &lt;= 1)  # Create PhaseSpace with both representations custom_ellipsoid = PhaseSpace(     dimension=dimension,     symbolic_set=ellipsoid_symbolic,     constraint=ellipsoid_constraint )  print(f\"Custom ellipsoid: {custom_ellipsoid}\") print(f\"Dimension: {custom_ellipsoid.dimension}\") <pre>Custom ellipsoid: ConditionSet((x0, x1, x2), 0.25*x0**2 + 1.0*x1**2 + 0.444444444444444*x2**2 &lt;= 1, ProductSet(Reals, Reals, Reals))\nDimension: 3\n</pre> In\u00a0[6]: Copied! <pre># Test membership in custom ellipsoid\ntest_points = np.array([\n    [0.0, 0.0, 0.0],      # Center - inside\n    [2.0, 0.0, 0.0],      # On x-axis boundary - inside\n    [0.0, 1.0, 0.0],      # On y-axis boundary - inside\n    [0.0, 0.0, 1.5],      # On z-axis boundary - inside\n    [2.1, 0.0, 0.0],      # Outside x semi-axis\n    [1.0, 0.5, 0.75],     # Inside ellipsoid (not on axes)\n], dtype=np.float64)\n\nprint(\"Testing membership for custom ellipsoid:\")\nfor i, point in enumerate(test_points):\n    is_inside = custom_ellipsoid.contains_point(point)\n    print(f\"  Point {i+1} {point}: {is_inside}\")\n</pre> # Test membership in custom ellipsoid test_points = np.array([     [0.0, 0.0, 0.0],      # Center - inside     [2.0, 0.0, 0.0],      # On x-axis boundary - inside     [0.0, 1.0, 0.0],      # On y-axis boundary - inside     [0.0, 0.0, 1.5],      # On z-axis boundary - inside     [2.1, 0.0, 0.0],      # Outside x semi-axis     [1.0, 0.5, 0.75],     # Inside ellipsoid (not on axes) ], dtype=np.float64)  print(\"Testing membership for custom ellipsoid:\") for i, point in enumerate(test_points):     is_inside = custom_ellipsoid.contains_point(point)     print(f\"  Point {i+1} {point}: {is_inside}\") <pre>Testing membership for custom ellipsoid:\n  Point 1 [0. 0. 0.]: True\n  Point 2 [2. 0. 0.]: True\n  Point 3 [0. 1. 0.]: True\n  Point 4 [0.  0.  1.5]: True\n  Point 5 [2.1 0.  0. ]: False\n  Point 6 [1.   0.5  0.75]: True\n</pre> In\u00a0[7]: Copied! <pre>import matplotlib.pyplot as plt\nfrom PyDynSys.vis import plot_phase_space\n\n### --- Visualize a closed disk (circle) --- ###\n\ncenter = np.array([0.0, 0.0], dtype=np.float64)\nradius = 1.5\ndisk = PhaseSpace.closed_hypersphere(center, radius)\n\nfig, ax = plt.subplots(figsize=(6, 6))\n# increasing resolution for default=200 to 500, 200 is a tad blurry.\nplot_phase_space(disk, xlim=(-2, 2), ylim=(-2, 2), ax=ax, resolution=500)\nplt.title('Closed Disk: ||x|| \u2264 1.5')\nplt.show()\n</pre> import matplotlib.pyplot as plt from PyDynSys.vis import plot_phase_space  ### --- Visualize a closed disk (circle) --- ###  center = np.array([0.0, 0.0], dtype=np.float64) radius = 1.5 disk = PhaseSpace.closed_hypersphere(center, radius)  fig, ax = plt.subplots(figsize=(6, 6)) # increasing resolution for default=200 to 500, 200 is a tad blurry. plot_phase_space(disk, xlim=(-2, 2), ylim=(-2, 2), ax=ax, resolution=500) plt.title('Closed Disk: ||x|| \u2264 1.5') plt.show()  In\u00a0[8]: Copied! <pre>### --- Visualize a custom 2D ellipsoid --- ###\n\ndimension_2d = 2\nsemi_axes_2d = np.array([2.0, 1.0], dtype=np.float64)\n\nR_2 = syp.Reals ** dimension_2d\nx_2d = syp.symbols('x0 x1', real=True)\nellipsoid_condition_2d = sum((x_2d[i] / semi_axes_2d[i])**2 for i in range(dimension_2d)) &lt;= 1\nellipsoid_symbolic_2d = syp.ConditionSet(syp.Tuple(*x_2d), ellipsoid_condition_2d, R_2)\n\nellipsoid_constraint_2d = lambda x: bool(np.sum((x / semi_axes_2d)**2) &lt;= 1)\n\ncustom_ellipsoid_2d = PhaseSpace(\n    dimension=dimension_2d,\n    symbolic_set=ellipsoid_symbolic_2d,\n    constraint=ellipsoid_constraint_2d\n)\n\nfig, ax = plt.subplots(figsize=(6, 6))\n# increasing resolution for default=200 to 500, 200 is a tad blurry.\nplot_phase_space(custom_ellipsoid_2d, xlim=(-3, 3), ylim=(-2, 2), ax=ax, resolution=500)\nplt.title('Custom Ellipsoid: (x/2)^2 + (y/1)^2 &lt;= 1')\nplt.show()\n</pre> ### --- Visualize a custom 2D ellipsoid --- ###  dimension_2d = 2 semi_axes_2d = np.array([2.0, 1.0], dtype=np.float64)  R_2 = syp.Reals ** dimension_2d x_2d = syp.symbols('x0 x1', real=True) ellipsoid_condition_2d = sum((x_2d[i] / semi_axes_2d[i])**2 for i in range(dimension_2d)) &lt;= 1 ellipsoid_symbolic_2d = syp.ConditionSet(syp.Tuple(*x_2d), ellipsoid_condition_2d, R_2)  ellipsoid_constraint_2d = lambda x: bool(np.sum((x / semi_axes_2d)**2) &lt;= 1)  custom_ellipsoid_2d = PhaseSpace(     dimension=dimension_2d,     symbolic_set=ellipsoid_symbolic_2d,     constraint=ellipsoid_constraint_2d )  fig, ax = plt.subplots(figsize=(6, 6)) # increasing resolution for default=200 to 500, 200 is a tad blurry. plot_phase_space(custom_ellipsoid_2d, xlim=(-3, 3), ylim=(-2, 2), ax=ax, resolution=500) plt.title('Custom Ellipsoid: (x/2)^2 + (y/1)^2 &lt;= 1') plt.show()"},{"location":"examples/phase_spaces_and_time_horizons/#using-custom-phase-spaces-and-time-horizons","title":"Using Custom Phase Spaces and Time Horizons\u00b6","text":""},{"location":"examples/phase_spaces_and_time_horizons/#preamble","title":"Preamble\u00b6","text":"<p>Recall that we define a Euclidean dynamical system with a set $X \\subseteq \\mathbb{R}^n$ and a vector field $X \\to \\mathbb{R}^n$ (or, for non-autonomous systems, $F: X \\times T \\to \\mathbb{R}^n$ for some time horizon $T \\subseteq \\mathbb{R}$), supposing the equation $\\dot{{\\bf x}} = F({\\bf x})$ (or, for non-autonomous systems, $\\dot{{\\bf x}} = F({\\bf x}, t)$) holds over $X$ (or, for non-autonomous systems $X \\times T$). In this short example, we concern ourselves with the programmatic representation of the set $X$.</p> <p>We define $X$ in abstract with the class <code>PhaseSpace</code> from the <code>core.euclidean</code> module. This class holds 3 attributes: <code>dimension</code>, <code>symbolic</code> and <code>constraint</code>, of types <code>int</code>, <code>sympy.set</code> and <code>Callable[[NDArray[np.float64]], bool]</code>. The purpose of dimension is obvious, it holds the value of $n$. The <code>symbolic</code> parameter utilises sympy to hold a symbolic representation of $X$, and the <code>constraint</code> parameter provides a functional representation of $X$, it's indicator functional.</p> <p>In constructing a <code>PhaseSpace</code> instance, it is only necessary to provide  <code>symbolic</code> or <code>callable</code>, though we recommend providing both. If only a symbolic representation is provided, we use lambdification provided by <code>sympy</code> for membership testing. This is provably slow. If only an indicator functional is provided, less insight can be inferred from string representations of our <code>PhaseSpace</code> instance.</p> <p>TIME HORIZON LOGIC HERE</p>"},{"location":"examples/phase_spaces_and_time_horizons/#overview","title":"Overview\u00b6","text":"<p>The <code>PhaseSpace</code> class provides:</p> <ul> <li>Factory methods for common geometric shapes (boxes, hyperspheres)</li> <li>Symbolic representation using SymPy for mathematical operations</li> <li>Callable constraints for fast numerical membership testing</li> <li>Custom constraint support for arbitrary sets</li> <li>Visualisation utils via <code>vis.euclidean</code> The <code>TimeHorizon</code> class provides:</li> <li>PROVIDED STUFF HERE.</li> </ul> <p>For complete API documentation, see the PhaseSpace API reference AND TIME HORIZON LINK HERE.</p>"},{"location":"examples/phase_spaces_and_time_horizons/#phasespace","title":"PhaseSpace\u00b6","text":""},{"location":"examples/phase_spaces_and_time_horizons/#factories","title":"Factories\u00b6","text":""},{"location":"examples/phase_spaces_and_time_horizons/#full-euclidean-space","title":"Full Euclidean Space\u00b6","text":"<p>The <code>full()</code> factory creates a phase space representing $\\mathbb{R}^n$ (unbounded Euclidean space).</p>"},{"location":"examples/phase_spaces_and_time_horizons/#box-constraints","title":"Box Constraints\u00b6","text":"<p>The <code>box()</code> factory creates a box-constrained phase space $[a_1, b_1] \\times \\cdots \\times [a_n, b_n] \\subset \\mathbb{R}^n$</p>"},{"location":"examples/phase_spaces_and_time_horizons/#other-factories","title":"Other Factories\u00b6","text":"<p>The <code>PhaseSpace</code> class also provides:</p> <ul> <li><code>closed_hypersphere(center, radius)</code> - Closed hypersphere $\\{x \\in \\mathbb{R}^n : \\lVert x - center\\rVert &lt; radius\\}$</li> <li><code>open_hypersphere(center, radius)</code> - Open hypersphere $\\{x \\in \\mathbb{R}^n : \\lVert x - center\\rVert &lt; radius\\}$</li> </ul> <p>For details on these and all other methods, see the PhaseSpace API documentation.</p>"},{"location":"examples/phase_spaces_and_time_horizons/#membership-testing","title":"Membership Testing\u00b6","text":"<p>PhaseSpace provides two methods for membership testing:</p> <ul> <li><code>contains_point(x)</code> - Check if a single point is in the phase space</li> <li><code>contains_points(X)</code> - Check if all points in an array are in the phase space</li> </ul>"},{"location":"examples/phase_spaces_and_time_horizons/#custom-constraints","title":"Custom Constraints\u00b6","text":"<p>We allow for phase spaces outside of the scope of our factories too. Consider, for example, ellipsoids.</p>"},{"location":"examples/phase_spaces_and_time_horizons/#visualization","title":"Visualization\u00b6","text":"<p>For 2D phase spaces, we can visualize the set using the <code>plot_phase_space</code> function from <code>PyDynSys.vis</code>. This function creates a grid of points and tests membership using the constraint callable, then visualizes the result using <code>imshow</code> for efficient boolean visualization.</p> <p>Note: <code>xlim</code> and <code>ylim</code> are required parameters - you must specify the viewing bounds explicitly.</p>"},{"location":"examples/phase_spaces_and_time_horizons/#time-horizons","title":"Time Horizons\u00b6","text":"<p>Our <code>TimeHorizon</code> class provides factories:</p> <ul> <li>real_line</li> <li>closed_interval(t_min, t_max)</li> <li>open_interval(t_min, t_max)</li> </ul> <p>has identical attributes, minus dimension, to <code>PhaseSpace</code> and identical (with points renamed to times) exposed methods. As with <code>PhaseSpace</code>, we recommend users provide both the constraint and symbolic representation for performance reasons, though we support the case where at least one, but not necessarily both, is provided.</p> <p>The logic is essentially identical to a phase space with dimension = 1, and as such we elect to leave experimentation with this class to the reader.</p>"},{"location":"examples/phase_spaces_and_time_horizons/#future-work","title":"Future Work\u00b6","text":"<p>In the near future, we aim to further implement the following methods for <code>PhaseSpace</code>:</p> <ul> <li>volume (with `@property' decorator and caching ; rigorous if available, numerical via convex hull otherwise)</li> <li>union, intersection, symmetric difference, complement &amp; other set theoretic operators (leveraging sympy toolkit &amp; boolean logic for callables)</li> <li>numerical derivation (given points, compute convex hull; smoothing &amp; padding logic desired)</li> </ul> <p>And for <code>TimeHorizon</code>:</p> <ul> <li>length (with `@property' decorator and caching ; rigorous if available, numerical otherwise)</li> <li>union, intersection, symmetric difference, complement &amp; other set theoretic operators (leveraging sympy toolkit &amp; boolean logic for callables)</li> <li>numerical derivation (given points, compute bounds and express as union of closed intervals with optional padding)</li> </ul> <p>We additionally seek to provide:</p> <ul> <li><code>PyDynSys.vis</code> utils for 3d phase spaces, projections (e.g. PCA, chosen axis) for $n &gt; 3$ dimension phase spaces and plotting support for simple scalar (1d) phase spaces; all of which are aggregated in the <code>plot_phase_space</code> util.</li> <li>Support for scalar <code>TimeHorizon</code> plots, though this is a triviality.</li> <li>Support for <code>TimeHorizon</code> $\\times$ <code>PhaseSpace</code> plots, particularly useful for analysing non-autonomous system predicates.</li> </ul>"},{"location":"getting_started/installation/","title":"Installation Guide","text":""},{"location":"getting_started/installation/#pip","title":"Pip","text":"<p>TBD</p>"}]}